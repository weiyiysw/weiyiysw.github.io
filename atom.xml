<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEIYIYSW</title>
  <subtitle>天不老，情难绝。心似双丝网，中有千千结。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://weiyiysw.com/"/>
  <updated>2016-12-19T03:27:38.000Z</updated>
  <id>http://weiyiysw.com/</id>
  
  <author>
    <name>易世伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux下动态库及版本号控制</title>
    <link href="http://weiyiysw.com/2016/12/19/linux%E4%B8%8B%E5%8A%A8%E6%80%81%E5%BA%93%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8E%A7%E5%88%B6/"/>
    <id>http://weiyiysw.com/2016/12/19/linux下动态库及版本号控制/</id>
    <published>2016-12-19T02:58:38.000Z</published>
    <updated>2016-12-19T03:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><p>我们都知道在Linux系统下，动态库的命名遵循了特定的规则</p>
<pre><code>lib{name}.so
</code></pre><p>如上所示，其中{name}可以替换为你自己声明的动态库名称。</p>
<p>可能大部分的人都了解就到这里，并没有关注动态库文件后面的版本控制。如果你已经关注了，那么后面的就可以不用看啦。</p>
<h1 id="Linux下动态库的命名规范"><a href="#Linux下动态库的命名规范" class="headerlink" title="Linux下动态库的命名规范"></a>Linux下动态库的命名规范</h1><p>Linux下引入了一套命名机制，但是这个机制仅是一个约定，并不强迫大家都按照这种方法。</p>
<h2 id="Real-Name"><a href="#Real-Name" class="headerlink" title="Real Name"></a>Real Name</h2><p>共享库本身的文件名，共享库的命名必须是<code>libname.so.x.y.z</code>，这里xyz代表的是此库文件的版本号。</p>
<ul>
<li>前缀： lib</li>
<li>后缀： so</li>
<li>name：自定义的库文件名</li>
<li>x: Major Version Number，主版本号，不兼容。重大升级，不同主版本之间的库是不兼容的。</li>
<li>y: Minor Version Number, 次版本号，向下兼容。增量升级，增加一些新的接口但保留原有接口。高次版本的库向后兼容低次版本的库。</li>
<li>z: Release Version Number，发布版本号，互相兼容。诸如库的一些错误修改、性能改进等，不会添加新接口，也不会更改接口。主版本和次版本完全相同的情况下，不同发行版本之间完全兼容。</li>
</ul>
<h2 id="SO-NAME"><a href="#SO-NAME" class="headerlink" title="SO-NAME"></a>SO-NAME</h2><p>在Linux系统中，每个共享库都有一个对应的SO-NAME（共享库文件名去掉次版本号和发布版本号）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综合上述两点，当我们遵循了Linux的这种机制并生成了自己的动态库文件后。咱们可以对库文件设置软连接，就可以避免真实库文件版本数字一直在变动，而不得不调整调用的代码。</p>
<p>例如：有一个 libHelloWorld.so.x.y.z</p>
<pre><code>ln -s libHelloWorld.so.x.y.z libHelloWorld.so.x
</code></pre><p>在代码中，查找库文件此软连接的名字，在主版本未改动的情况下，动态库版本变动只需调整软连接即可。</p>
]]></content>
    
    <summary type="html">
    
      这篇简要介绍了Linux系统下动态库的命名规范，也是因为个人最初在项目中使用时，并未遵循此规范，导致部署复杂、困难。当然现在docker很火，但是这个由于项目原因，就并没有使用docker。
    
    </summary>
    
    
      <category term="linux" scheme="http://weiyiysw.com/tags/linux/"/>
    
      <category term="shared lib" scheme="http://weiyiysw.com/tags/shared-lib/"/>
    
      <category term="version" scheme="http://weiyiysw.com/tags/version/"/>
    
  </entry>
  
  <entry>
    <title>setup-hexo</title>
    <link href="http://weiyiysw.com/2016/12/18/setup-hexo/"/>
    <id>http://weiyiysw.com/2016/12/18/setup-hexo/</id>
    <published>2016-12-18T12:37:39.000Z</published>
    <updated>2016-12-18T13:41:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装Hexo相当简单。在安装前，你必须检查电脑中是否已经安装了下列应用程序：</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>如果你的电脑已经安装好了上述必备程序，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><p>如果你的电脑尚未安装所需要的程序，请按照以下安装指示完成安装。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul>
<li>windows：下载并安装<a href="https://git-scm.com/download/win" target="_blank" rel="external">git</a></li>
<li>Mac：使用Homebrew，MacPorts或下载安装程序安装。</li>
<li>Linux(Ubuntu\Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux(Fedora\Red Hat\CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>。</p>
<p>cURL:</p>
<pre><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh
</code></pre><p>Wget:</p>
<pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh
</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>
<pre><code>$ nvm install stable
</code></pre><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="external">安装程序</a> 来安装。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>所有必备的应用程序安装完成后，即可以使用npm安装Hexo。</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><blockquote>
<p>注意：采用Hexo写文章，需要去了解一下Markdown语法。Markdown简单易学，可以找一款适合你的Markdown的编辑器。</p>
</blockquote>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p>安装Hexo完成后，请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。</p>
<pre><code>$ hexo init &lt;folder&gt;
$ cd &lt;folder&gt;
$ npm install
</code></pre><p>新建完成后，指定文件夹的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>这个是配置文件，大部分的配置都在这里，按需修改。</p>
<h2 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h2><p>这个是主题文件夹，把主题下载到这个文件夹下即可。</p>
<h2 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h2><p>这个是模板文件夹，新建文章时Hexo会根据scaffolds来生成。</p>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>这里是应用程序信息。保持默认即可。</p>
<h1 id="与GitHub-Pages绑定"><a href="#与GitHub-Pages绑定" class="headerlink" title="与GitHub Pages绑定"></a>与GitHub Pages绑定</h1><p>Hexo博客搭建完成之后，我们执行<code>hexo s</code>就可以在本地访问自己的blog了。</p>
<p>您还可以把您的博客托管到网上，以便于大家分享。托管的有很多，在这里仅记录与GitHub Pages绑定。</p>
<h2 id="注册一个GitHub账号"><a href="#注册一个GitHub账号" class="headerlink" title="注册一个GitHub账号"></a>注册一个GitHub账号</h2><p>首先，你需要有一个github账号。注册过程很简单，就不描述了。这里需要注意，注册时您选择的用户名很重要（英文），设置一个喜欢的用户名就好。github的通知几乎都是邮件通知的，所以邮箱一定要是常用邮箱。</p>
<h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><p>注册好账号之后，登录GitHub。然后创建一个仓库，我们创建的仓库用于个人博客，这样的仓库只能创建一个。创建的仓库名填写的是我们之前注册的用户名，其他的保持默认即可。例如，我的用户名是weiyiysw，那么我就创建一个weiyiysw的仓库。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>仓库建立好之后，我们需要将我们的博客发布到GitHub上。</p>
<p>首先，我们需要修改我们Hexo博客根目录下的<code>_config.yml</code>文件，找到deploy，并按照如下配置，其中仓库替换为前一步github仓库地址即可。</p>
<pre><code>deploy:
    type: git
    repository: https://github.com/weiyiysw/weiyiysw.github.io.git
    branch: master
    message: [自定义提交信息]
</code></pre><p>保存此配置文件。</p>
<p>然后安装插件：</p>
<pre><code>$ npm install hexo-deployer-git --save
</code></pre><p>最后，在终端下执行如下命令：</p>
<pre><code>hexo clean (清楚缓存文件和生成的静态文件)
hexo generate (缩写 hexo g，生成静态文件)
hexo deploy (缩写 hexo d，部署网站)
</code></pre><p>待<code>hexo d</code>执行结束，即部署成功。这时候，您就可以访问自己的博客了。以我的为例，例如：<a href="https://weiyiysw.github.io" target="_blank" rel="external">https://weiyiysw.github.io</a>。</p>
<p>您只需把替换成您自己的用户名访问，即可。</p>
<pre><code>https://yourusername.github.io
</code></pre><blockquote>
<p>注意：您还可以自己通过购买属于自己的域名，然后将域名绑定到这。即可通过自己的域名访问。具体，请网上搜索教程。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      这是记录Hexo建立的过程以及部署到github Pages
    
    </summary>
    
      <category term="hexo" scheme="http://weiyiysw.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://weiyiysw.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vertx-core翻译</title>
    <link href="http://weiyiysw.com/2016/12/10/vertx-core/"/>
    <id>http://weiyiysw.com/2016/12/10/vertx-core/</id>
    <published>2016-12-10T13:55:52.000Z</published>
    <updated>2016-12-18T15:42:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vert-x的核心是一组被我们称为Vert-x-Core的Java-APIs"><a href="#Vert-x的核心是一组被我们称为Vert-x-Core的Java-APIs" class="headerlink" title="Vert.x的核心是一组被我们称为Vert.x Core的Java APIs"></a>Vert.x的核心是一组被我们称为Vert.x Core的Java APIs</h1><p>Vert.x core提供了下面这些功能：</p>
<ul>
<li>编写TCP clients和servers</li>
<li>编写HTTP clients和servers包括支持WebSockets</li>
<li>Event bus</li>
<li>Shared data - 本地的maps和分布式的集群式的maps</li>
<li>周期性和延迟运行</li>
<li>部署和卸载Verticles</li>
<li>数据包套接字</li>
<li>DNS客户端</li>
<li>访问文件系统</li>
<li>高可用</li>
<li>集群</li>
</ul>
<p>Vert.x core里的功能是相当底层的，在这里你不会找到像数据库访问、权限验证或者高层web功能的东西。那些东西你可以在Vert.x ext里找到。</p>
<p>Vert.x core很小并且很轻量级的。你可以仅使用你想要的那部分。它也可以完全的嵌入到你现在已经存在的应用。我们并不强迫你仅为了使用Vert.x而通过一种特殊的方式来架构你的应用。</p>
<p>你可以通过Vert.x支持的任何语言来使用Vert.x core。这有点酷，在这里我们并不强迫你直接使用Java API，换言之JavaScript或者Ruby都可以。毕竟不同的语言有不同的惯例和语法。强迫Ruby开发者使用Java语法来开发这是很奇怪的（例如）。相反，我们会为每一种语言生成一个符合语言习惯的、等效于Java APIs的Vert.x core。</p>
<p>从这开始，我们仅使用这个单词<strong>core</strong>代表Vert.x core。</p>
<p>如果你使用Maven或Gradle，添加接下来的依赖到你的项目中<code>dependencies</code>部分，这样你就可以使用Vert.x core API：</p>
<ul>
<li><p>Maven（在<code>pom.xml</code>文件里）</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.vertx&lt;/groupI&gt;
    &lt;artifactId&gt;vertx-core&lt;/artifactId&gt;
    &lt;version&gt;3.3.3&lt;/version&gt;    
&lt;/dependency&gt;
</code></pre></li>
<li><p>Gradle（在<code>build.gradle</code>文件里）</p>
<pre><code>compile io.vertx:vertx-core:3.3.3
</code></pre></li>
</ul>
<p>接下来，我们来讨论Vert.x core的不同的概念及特性。</p>
<hr>
<h3 id="从Vert-x开始"><a href="#从Vert-x开始" class="headerlink" title="从Vert.x开始"></a>从Vert.x开始</h3><hr>
<blockquote>
<p>注意：这里的大部分都是Java特有的 —— 换成其他语言时需要一些其他的特殊的部分</p>
</blockquote>
<p>在Vert.x的世界你几乎做不了什么，除非你可以和<code>Vertx</code>对象交流。</p>
<p>Vertx对象是Vert.x的控制中心，通过它，你几乎可以做任何事情，包括创建客户端及服务器、获取事件总线（event bus）的引用、设置定时器等及很多其他的东西。</p>
<p>因此，怎么来获取到一个实例呢？</p>
<p>如果你正在嵌入Vert.x，你可以简单的创建一个实例就像接下来这样：</p>
<pre><code>Vertx vertx = Vertx.vertx();
</code></pre><p>如果你要使用Verticles</p>
<blockquote>
<p>大多数的应用仅需要一个简单的Vert.x实例，但是如果你需要，创建多个Vert.x实例是可以的。例如，事件总线的隔离或不同组的服务器和客户端的隔离。</p>
</blockquote>
<h4 id="创建一个指定选项的Vertx对象"><a href="#创建一个指定选项的Vertx对象" class="headerlink" title="创建一个指定选项的Vertx对象"></a>创建一个指定选项的Vertx对象</h4><p>当创建一个Vertx对象时，如果默认的不适合，你可以指定一个选项。</p>
<pre><code>Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));
</code></pre><p><code>VertxOptions</code>对象有很多设置并且允许你配置它，如：集群、高可用、池大小及其他大量的设置。Javadoc文档详细的描述了全部的设置。</p>
<h4 id="创建一个集群式的Vert-x对象"><a href="#创建一个集群式的Vert-x对象" class="headerlink" title="创建一个集群式的Vert.x对象"></a>创建一个集群式的Vert.x对象</h4><p>如果你要创建一个集群的Vert.x（在event bus小节查看更多的关于集群event bus信息），通常你将使用异步的方式创建这个对象。</p>
<p>这是因为这通常会花费一些时间（可能几秒钟），在一个集群里将不同的Vert.x实例编组。在这段时间，我们并不希望阻塞调用线程，因此，我们把结果以异步的方式给你。</p>
<hr>
<h3 id="你用流式API编程吗？"><a href="#你用流式API编程吗？" class="headerlink" title="你用流式API编程吗？"></a>你用流式API编程吗？</h3><hr>
<p>你可能已经注意到了，前面的例子中都使用了流式API。</p>
<p>流式API是多个方法调用组成的链。例如：</p>
<pre><code>request.response().putHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;).write(&quot;some text&quot;).end();
</code></pre><p>流式的代码风格贯穿了整个Vert.x API。所以，你需要适应它。</p>
<p>链式的调用会让你写的代码紧凑些。当然，如果你不喜欢流式的方式，我们并不强迫你。你可以不管它，并按照你喜欢的方式写。你可能会这样写：</p>
<pre><code>HttpServerResponse response = request.response();
response.putHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);
response.write(&quot;some text&quot;);
response.end();
</code></pre><hr>
<h3 id="别调用我们，我们会通知你的"><a href="#别调用我们，我们会通知你的" class="headerlink" title="别调用我们，我们会通知你的"></a>别调用我们，我们会通知你的</h3><hr>
<p>Vert.x APIs大部分都是事件驱动的。这意味着，当Vert.x里发生了你感兴趣的事情时，Vert.x会通过回调的方式给你发送事件。</p>
<p>一些示例的事件如下:</p>
<ul>
<li>激活计时器</li>
<li>数据到达了socket</li>
<li>从磁盘中读取数据</li>
<li>发生了一个异常</li>
<li>Http server接收到了一个请求</li>
</ul>
<p>通过Vert.x APIs提供的<strong>handlers</strong>处理事件。例如：接收一个定时器事件，每一秒钟你都这样做：</p>
<pre><code>vertx.setPeriodic(1000, id -&gt; {
    // This handler will get called every second
    System.out.println(&quot;timer fired!&quot;);
});
</code></pre><p>或者接收一个Http请求：</p>
<pre><code>server.requestHandler(request -&gt; {
    // This handler will be called every time an Http request is received at the server
    request.response.end(&quot;Hello World!&quot;)
});
</code></pre><p>在过了一些时间之后，Vert.x有一个事件并将其传入到handler里，这在Vert.x里被称为异步性。</p>
<p>这为我们引导了Vert.x的一些重要的概念：</p>
<hr>
<h3 id="别阻塞我"><a href="#别阻塞我" class="headerlink" title="别阻塞我"></a>别阻塞我</h3><hr>
<p>除了很少的一些异常（例如：一些结尾为‘Sync’的文件系统的操作），在Vert.x里没有任何的APIs调用时会被阻塞。</p>
<p>如果一个结果可以马上提供，那么将会立刻把这个结果返回。要不然，你需要提供一个handler在一段时间之后来接收事件。</p>
<p>因为Vert.x APIs不会阻塞任何线程，这意味着你可以使用Vert.x来处理小数量线程的大量并发使用。</p>
<p>一个常规的阻塞API在调用时可能会以下这些情况阻塞：</p>
<ul>
<li>从一个socket读取数据</li>
<li>写数据到磁盘</li>
<li>发送一个消息给接收者并等待回复</li>
<li>其他很多的情况</li>
</ul>
<p>在所有上述的例子中，当你的线程正在等待一个结果时，这个线程其他什么都不能做，这实在是没有用的。</p>
<p>这意味着，当你需要大量的并发并且使用阻塞API时，你需要大量的线程来防止你的程序完全停止。</p>
<p>线程在它们所需要的内存（例如栈）和上下文切换时是有开销的。</p>
<p>对于现代应用的需要的并发水平，阻塞的方法并不适合扩展。</p>
<hr>
<h3 id="Reactor和Multi-Reactor"><a href="#Reactor和Multi-Reactor" class="headerlink" title="Reactor和Multi-Reactor"></a>Reactor和Multi-Reactor</h3><hr>
<p>我们前面提到了Vert.x APIs是事件驱动的，Vert.x传递事件到handlers当事件是可用的。</p>
<p>在大多数的例子中，Vert.x通过一个名为event loop的线程调用你的handler。</p>
<p>在Vert.x或你的应用中如果没有任何阻塞，这个event loop可以很愉快的运行，当事件到达的时候，可以成功的分发事件到不同的handlers。</p>
<p>因为没有任何阻塞，一个event loop可以在短时间内分发大量的时间。例如，一个单一的event loop可以很快的处理几千个HTTP请求。</p>
<p>我们把这个称为反应器模式。</p>
<p>你之前可能就听过这个，例如，Node.js就已经实现了这个模式。</p>
<p>在一个标准的反应堆模式的实现里，只有一个单一的event loop线程循环的运行并分发所有的事件到其对应的handlers里，当事件到达的时候。</p>
<p>使用一个单一的线程的麻烦在于这个线程同一事件只能运行在一个单一的核上，所以如果你想让你的单一线程的反应堆应用（例如你的Node.js应用）拓展到你的多核的服务器上，你不得不启动和管理很多不同的进程。</p>
<p>Vert.x的处理是不一样的。不同于一个单一的event loop，每个Vertx示例包含了多个event loop。默认的我们选择的数量是基于机器上可用的核心数量，但是这可以被覆盖。</p>
<p>这意味着一个单一的Vertx进程可以在整个服务器上扩展，不像Node.js需要多个进程。</p>
<p>我们将这种模式成为多核反应堆模式，用来区分单一线程的反应堆模式。</p>
<blockquote>
<p>即使一个Vertx实例包含了多个event loop，任何特别的handler将不会被并发执行，在大多数的例子中（除了worker verticles），他们总是会被完全相同的event loop调用。</p>
</blockquote>
<hr>
<h3 id="黄金法则——不要阻塞event-loop"><a href="#黄金法则——不要阻塞event-loop" class="headerlink" title="黄金法则——不要阻塞event loop"></a>黄金法则——不要阻塞event loop</h3><hr>
<p>我们已经知道Vert.x APIs是无阻塞的，也不会阻塞event loop，但是这并没有太多用如果你自己在你的handler里阻塞event loop。</p>
<p>如果你这样做了，event loop将不能做任何其他的事当它被阻塞了。如果你阻塞了Vertx实例所有的event loop，那么你的应用将会完全停止。</p>
<p>所以，不要去阻塞它！你已经被警告了。</p>
<p>阻塞的例子包括：</p>
<ul>
<li>Thread.sleep()</li>
<li>等待一个锁</li>
<li>等待互斥或监视器（如：同步代码）</li>
<li>做一个长时间数据库操作并且等待一个结果</li>
<li>做一个复杂的计算，会占用一些重要的时间</li>
<li>死循环</li>
</ul>
<p>如果上面提到的任何一个使event loop停止了做任何其他的事情并且大量时间，然后你应该马上到下一步(naughty step)，并且等待下一步指示。</p>
<p>所以…这个大量的时间具体多长呢？</p>
<p>一个string花多长时间呢？它真实的依赖于你的应用和你需要的并发量。</p>
<p>如果你有一个单一的event loop，你还想每秒处理10000个http请求，这是很明确的每个请求执行的时间最多不能超过0.1ms，因此，你的阻塞时间不能超过这个。</p>
<p>这个数学计算并不难，应该作为联系留给读者。</p>
<p>如果你的应用不响应，很可能你在某个地方阻塞了event loop。为了帮助你诊断这些问题，Vert.x会自动记录警告如果检测到一个event loop在一些时间内没有返回。如果你在日志中看到像这样的警告，你应该去检查你的代码了。</p>
<pre><code>Thread vertx-eventloop-thread-3 has been blocked for 20458ms
</code></pre><p>Vert.x还会提供堆栈跟踪来准确的定位阻塞发生的地方。</p>
<p>如果你想关闭这些警告或者修改设置，你可以在创建Vertx对象前，设置<code>VertxOptions</code>对象。</p>
<hr>
<h3 id="运行阻塞的代码"><a href="#运行阻塞的代码" class="headerlink" title="运行阻塞的代码"></a>运行阻塞的代码</h3><hr>
<p>在一个完美的世界中，那是没有战争或饥饿的。所有的API都是用异步的方式写的，阳光明媚，绿色的草地有跳来跳去的兔子和手牵手的小羊羔。</p>
<p>但是，真实的世界并不是这样子的。</p>
<p>事实上，大多数的库尤其是JVM的生态系统都是有同步的API，很多方法都有可能阻塞。一个很好的例子就是JDBC API，它本质上就是同步的，无论再怎么努力尝试，Vert.x即使使用魔法也不可能把它变成异步的。</p>
<p>我们不可能一晚上就将所有的同步API重写为异步的，所以我们需要提供一种方法让你能够在Vert.x应用中安全的使用使用传统的阻塞API。</p>
<p>就像前面讨论的，从一个event loop中你不能直接的调用一个阻塞的操作，如果那样做了，将会阻止event loop做其他有效的工作。那么，你该怎么做呢？</p>
<p>通过调用<code>executeBlocking</code>来完成，具体来说，将阻塞的代码放到此方法中执行，当阻塞代码执行结束后，通过异步的回调handler返回结果。</p>
<pre><code>vertx.executeBlocking(future -&gt; {
    // call some blocking api that takes a significant amount of time to return
    String result = someAPI.blockingMethod(&quot;Hello&quot;);
    future.complete(result);
}, res -&gt; {
    System.out.println(&quot;The result is: &quot; + res.result());
});
</code></pre><p>默认地，如果executeBlocking从相同的上下文里被调用多次（例如，相同的verticle实例），然后不同的executeBlocking是按序列执行的（一个按一个执行）。</p>
<p>如果你不关心你能调用的executeBlocking的执行顺序，指定<code>ordered</code>参数为<code>false</code>。这种情况下，任何一个executeBlocking可以在工作池上并行执行。</p>
<p>一个运行blocking代码可替换的方法是使用一个worker verticle。</p>
<p>默认地，阻塞代码被执行会阻塞Vert.x代码池，配置<code>setWorkerPoolSize</code>。</p>
<p>传统的池可以为了不同的目的而被创建：</p>
<pre><code>WorkerExecutor executor = vertx.createSharedWorkerExecutor(&quot;my-worker-pool&quot;);
executor.executeBlocking(future -&gt; {
// Call some blocking API that takes a significant amount of time to return
String result = someAPI.blockingMethod(&quot;hello&quot;);
future.complete(result);
}, res -&gt; {
System.out.println(&quot;The result is: &quot; + res.result());
});
</code></pre><p>工作执行必须被关闭，当它不再需要的时候：</p>
<pre><code>executor.close();
</code></pre><p>当多个工作者用相同的名字被创建后，它们将分享相同的池。这个工作池会被摧毁，当全部的工作执行者使用它被关闭后。</p>
<p>当一个执行者在Verticle里被创建后，Vert.x将会自动的为你关闭它，当Verticle卸载的时候。</p>
<p>工作执行者在被创建的时候可以被配置：</p>
<pre><code>int poolSize = 10;

// 2 minutes
long maxExecuteTime = 120000;

WorkerExecutor executor =     vertx.createSharedWorkerExecutor(&quot;my-worker-pool&quot;, poolSize, maxExecuteTime);
</code></pre><blockquote>
<p>当工作池被创建的时候配置文件就已经设置了。</p>
</blockquote>
<hr>
<h3 id="异步协调"><a href="#异步协调" class="headerlink" title="异步协调"></a>异步协调</h3><hr>
<p>协调多个异步的结果是可以通过Vert.x的<code>futures</code>来实现。它支持并行架构（并行运行多个异步的操作）和序列架构（异步链式操作）。</p>
<h4 id="并发架构"><a href="#并发架构" class="headerlink" title="并发架构"></a>并发架构</h4><p><code>CompositeFuture.all</code>携带了多个future参数（最多6个）并且返回一个future对象。如果返回的future成功了，那么所有的携带的所有future都成功了，如果返回的future失败了，那么至少是有一个携带的future失败了：</p>
<pre><code>Future&lt;HttpServer&gt; httpServerFuture = Future.future();
httpServer.listen(httpServerFuture.completer());

Future&lt;NetServer&gt; netServerFuture = Future.future();
netServer.listen(netServerFuture.completer());

CompositeFuture.all(httpServerFuture, netServerFuture).setHandler(ar -&gt; {
    if (ar.succeeded()) {
    // All servers started
    } else {
    // At least one server failed
    }
});
</code></pre><p>这些操作并发的运行，与返回的future对象关联的<code>handler</code>在上面的那些架构全部完成之后被调用。当一个操作失败了（传入的一个future被标记为失败），这个结果future也会被标记为失败。当全部的操作完成后，这个结果future成功的完成了。</p>
<p>或者，你可以传入一个future的List集合：</p>
<pre><code>CompositeFuture.all(Arrays.asList(future1, future2, future3));
</code></pre><p><code>all</code>构成方法等待知道所有的future对象都成功（或者一个失败），<code>any</code>构成方法等待第一个成功的future。<code>CompositeFuture.any</code>方法携带多个future参数（最多6个），返回一个future对象，当携带的多个future对象中有一个成功了则返回成功，如果携带的多个都失败了那么返回失败：</p>
<pre><code>CompositeFuture.any(future1, future2).setHandler(ar -&gt; {
    if (ar.succeeded()) {
        // At least one is succeeded
    } else {
        // All failed！
    }
});
</code></pre><p>也可以使用future的List集合：</p>
<pre><code>CompositeFuture.any(Arrays.asList(f1, f2, f3));
</code></pre><p><code>join</code>架构会等待直到所有的future都完成了，无论携带的future成功还是失败。<code>CompositeFuture.join</code>携带多个future参数（最多6个），返回一个future，当所有携带的future成功返回成功，当所有的future都已经执行完成并且至少有一个失败了返回失败。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">CompositeFuture</span><span class="selector-class">.join</span>(future1, future2, future3)<span class="selector-class">.setHandler</span>(ar -&gt; &#123;</div><div class="line">  <span class="selector-tag">if</span> (ar.succeeded()) &#123;</div><div class="line">    <span class="comment">// All succeeded</span></div><div class="line">  &#125; else &#123;</div><div class="line">    <span class="comment">// All completed and at least one failed</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>也可以使用future的List集合：</p>
<pre><code>CompositeFuture.join(Arrays.asList(future1, future2, future3));
</code></pre><h4 id="序列架构"><a href="#序列架构" class="headerlink" title="序列架构"></a>序列架构</h4><p>当<code>all</code>和<code>any</code>是并发架构的实现，<code>compose</code>可以被用作为链式的future（序列架构）。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">FileSystem fs = vertx.fileSystem();</div><div class="line">Future&lt;Void&gt; startFuture = Future.future();</div><div class="line"></div><div class="line">Future&lt;Void&gt; fut1 = Future.future();</div><div class="line">fs.createFile(<span class="string">"/foo"</span>, fut1.completer());</div><div class="line"></div><div class="line">fut1.compose(v -&gt; &#123;</div><div class="line">  // When the file is created (fut1),<span class="built_in"> execute </span>this:</div><div class="line">  Future&lt;Void&gt; fut2 = Future.future();</div><div class="line">  fs.writeFile(<span class="string">"/foo"</span>, Buffer.buffer(), fut2.completer());</div><div class="line"> <span class="built_in"> return </span>fut2;</div><div class="line">&#125;).compose(v -&gt; &#123;</div><div class="line">          // When the file is written (fut2),<span class="built_in"> execute </span>this:</div><div class="line">          Future&lt;Void&gt; fut3 = Future.future();</div><div class="line">          fs.move(<span class="string">"/foo"</span>, <span class="string">"/bar"</span>, fut3.completer());</div><div class="line">        &#125;,</div><div class="line">        // mark the start future as completed when all the chain has been completed,</div><div class="line">        //<span class="built_in"> or </span>mark it as failed<span class="built_in"> if </span>any step fails.</div><div class="line">        startFuture);</div></pre></td></tr></table></figure>
<p>在这个例子中，三个操作是链式的：</p>
<ol>
<li>一个文件被创建了（<code>fut1</code>）</li>
<li>写入某些东西到文件中（<code>fut2</code>）</li>
<li>移动这个文件（<code>fut3</code>）</li>
</ol>
<p>当这三步都成功了，这个最后的future(<code>startFuture</code>)将会完成并返回成功的结果。然而，如果其中一步失败了，这个最终的future也将会完成但返回失败的结果。</p>
<p>这个例子使用了：</p>
<ul>
<li><code>compose</code>：当当前的future完成了，运行提供的函数，然后返回一个future。当这个返回的future执行完成了，就表示这个架构执行完成了。</li>
<li><code>compose</code>：当当前的future完成了，运行提供的handler完成当前提供的<code>future</code>（下一个）。</li>
</ul>
<p>在第二个情形下，这个<code>Handler</code>应该执行完成，由<code>next</code>future报告是handler是否执行成功或失败。</p>
<p>你可以使用<code>completer</code>来完成一个future的操作结果或失败。这样避免了不得不像传统的那样写：<code>如果成功，然后这个future完成了或者这个future失败了</code>。</p>
<hr>
<h3 id="Verticles"><a href="#Verticles" class="headerlink" title="Verticles"></a>Verticles</h3><hr>
<p>Vert.x附带了一个简单，可扩展，类actor的部署和并发模型，你可以用它来保存你自己写的。</p>
<p>这个模型完全是可选的，Vert.x并不强迫你用这种方式创建你的应用，如果你不想的话。</p>
<p>该模型并不声称是严格的actor模型实现，但它确实具有相似之处，特别是在并发，扩展和部署方面。</p>
<p>为了使用这个模型，你把你的代码写成一些verticles。</p>
<p>Verticles是一大块的代码，需要通过Vert.x来部署。一个Vert.x实例默认包含N个event loop线程（N默认是CPU核心数*2）。可以用Vert.x支持的任何语言来写Verticles，一个单一的应用可以包含用多种语言写的verticles。</p>
<p>你可以认为一个verticle就像是一个<code>Actor Model</code>中的一个actor。</p>
<p>一个典型的应用将会由多个verticle实例组成，这些实例在同一时间运行在相同的Vert.x实例上。不同的verticle实例通过将消息发送到event bus上交流。</p>
<h4 id="写Verticles"><a href="#写Verticles" class="headerlink" title="写Verticles"></a>写Verticles</h4><p>一个Verticle类必须实现<code>Verticle</code>接口。</p>
<p>如果你想的话，你可以直接实现这个接口。但是，通常来说拓展抽象类<code>AbstractVerticle</code>是更加简单的。</p>
<p>下面就是一个verticle的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Called when verticle is deployed</span></div><div class="line">  public void start() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Optional - called when verticle is undeployed</span></div><div class="line">  public void stop() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常的，你想上面例子这样的重载这个开始方法就可以了。</p>
<p>当Vert.x部署verticle的时候，会调用它的start方法，当这个方法执行完成了，verticle将会被认为部署完成。</p>
<p>你也可以选择覆盖这个stop方法。这个方法在verticle卸载时会被Vert.x调用。当这个方法完成了，这个verticle会被认为卸载完成。</p>
<h4 id="异步的Verticle启动和停止"><a href="#异步的Verticle启动和停止" class="headerlink" title="异步的Verticle启动和停止"></a>异步的Verticle启动和停止</h4><p>某些时候，你想要在你的verticle启动的时候做一些事情，单着会花费一些时间，但是你并不想等这个verticle直到被认为部署好了。举个例子，你可能想要在开始方法中部署另外其他的verticles。</p>
<p>在start方法中，你不能阻塞并等待其他的verticle部署，因为那样将会打破Vert.x的黄金规则（永远不要阻塞它）。</p>
<p>那么，你该怎么做呢？</p>
<p>这个解决方式是通过实现一个异步的start方法。在这个版本里，这个异步的start方法带有了一个Future参数。当这个方法返回的时候，这个verticle并不会认为已经部署好了。</p>
<p>在一些时间之后，在你做完了你需要做的所有事情之后（例如：启动其他的verticles），你可以调用Future的complete方法（或fail方法）来通知你已经完成了。</p>
<p>下面是这个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  public void start(<span class="type">Future</span>&lt;<span class="type">Void</span>&gt; startFuture) &#123;</div><div class="line">    <span class="comment">// Now deploy some other verticle:</span></div><div class="line"></div><div class="line">    vertx.deployVerticle(<span class="string">"com.foo.OtherVerticle"</span>, res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">        startFuture.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        startFuture.fail(res.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相似的，这也有一个异步的stop方法。当你在verticle清除时需要占用一些时间时，你可以使用这个。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  public void start() &#123;</div><div class="line">    <span class="comment">// Do something</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void stop(<span class="type">Future</span>&lt;<span class="type">Void</span>&gt; stopFuture) &#123;</div><div class="line">    obj.doSomethingThatTakesTime(res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">        stopFuture.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        stopFuture.fail();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>INFO：你没有必要在verticle的stop方法中去说明卸载通过这个verticle启动的子verticle。Vert.x会自动的卸载所有的子verticle，当父verticle被卸载的时候。</p>
<h4 id="Verticle类型"><a href="#Verticle类型" class="headerlink" title="Verticle类型"></a>Verticle类型</h4><p>有三种不同类型的verticles：</p>
<p><strong>标准的verticles</strong></p>
<p>这是最普遍和有用的类型-这种类型的verticle执行时总是使用一个event loop线程。我们会在下一小节详细讨论。</p>
<p><strong>工作者verticles</strong></p>
<p>这种verticle从工作者池中获取一个线程来运行。一个实例从不会通过超过一个的线程并发执行。</p>
<p><strong>多线程的工作者Verticles</strong></p>
<p>这种Verticle从工作者池中获取一个线程来运行。一个实例可以被多个线程并发执行。</p>
<h4 id="标准的verticles"><a href="#标准的verticles" class="headerlink" title="标准的verticles"></a>标准的verticles</h4><p>标准的verticles被分配到一个event loop线程上，当它们被创建的时候这个start方法就被event loop调用了。当你从一个event loop上调用任何其他的Vert.x core API方法时，需要携带一个handler。然后Vert.x会保证这些handler会被调用，当被相同的event loop执行的时候。</p>
<p>这意味着，我们可以保证在你的verticle中的所有代码总是被同一个event loop执行（只要你不创建你自己的线程来调用它）。</p>
<p>这意味着你可以把你应用的所有代码写到一个单一的线程里，让Vert.x去操心线程及规模。不再需要担心同步和变化了，并且还可以避免许多其他情况下的竞态条件和死锁，防止普遍的手工处理的“传统”多线程应用程序开发。</p>
<h4 id="工作者verticles"><a href="#工作者verticles" class="headerlink" title="工作者verticles"></a>工作者verticles</h4><p>一个工作者verticle就像一个标准的verticle，但是它并不是由一个event loop执行的，它是通过在Vert.x工作者线程池中获取一个线程来执行。</p>
<p>工作者verticles为调用阻塞代码而设计的，因此他们并不会阻塞任何event loop。</p>
<p>如果你想要使用一个工作者verticle来运行阻塞代码，你也可以在event loop中通过executeBlocking来运行阻塞代码。</p>
<p>如果你想要部署一个工作者verticle，你需要设置<code>setWorker</code>为<code>true</code>。</p>
<pre><code>DeploymentOptions options = new DeploymentOptions().setWorker(true);
vertx.deployVerticle(&quot;com.mycompany.MyOrderProcessorVerticle&quot;, options);
</code></pre><p>工作者verticle实例从不会被Vert.x用超过一个的线程来并发执行，但是可以被多个线程在不同的时间执行。</p>
<h4 id="多线程工作者Verticles"><a href="#多线程工作者Verticles" class="headerlink" title="多线程工作者Verticles"></a>多线程工作者Verticles</h4><p>一个多线程工作者verticles就像一个普通的工作者线程verticle，但是它可以被不同的线程并发的执行。</p>
<blockquote>
<p>警告：多线程工作者Vertices是一个高级特性，大多数的应用并不需要这个。因为这些vertices里的并发性，你不得不非常的小心用标准的Java多线程编程技术来保持verticle状态的一致。</p>
</blockquote>
<h4 id="程序化部署verticles"><a href="#程序化部署verticles" class="headerlink" title="程序化部署verticles"></a>程序化部署verticles</h4><p>你可以使用一个<code>deployVerticle</code>方法来部署一个verticle，指定一个verticle名字或者你可以传入一个你自己的创建好的verticle实例。</p>
<blockquote>
<p>部署Verticle实例是Java独有的</p>
</blockquote>
<pre><code>Verticle myVerticle = new MyVerticle();
vertx.deployVerticle(myVerticle);
</code></pre><p>你也可以通过指定verticle的名字来部署verticles。</p>
<p>这个verticle名字用来查找特定的<code>VerticleFactory</code>——用来实例化真实的verticle实例。</p>
<p>不同的verticle工厂都可以用不同的语言来实例化verticles。由于众多其他的原因，例如加载服务或者从maven的运行时获取到verticles。</p>
<p>这允许你用采用任何Vert.x支持的语言来部署verticles，而不用关心这些verticles是用Vert.x支持的任何语言写的。</p>
<p>下面是一个示例：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.deployVerticle</span>(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Deploy a JavaScript verticle</span></div><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.deployVerticle</span>(<span class="string">"verticles/myverticle.js"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Deploy a Ruby verticle verticle</span></div><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.deployVerticle</span>(<span class="string">"verticles/my_verticle.rb"</span>);</div></pre></td></tr></table></figure>
<h4 id="映射verticle名字到verticle工厂的规则"><a href="#映射verticle名字到verticle工厂的规则" class="headerlink" title="映射verticle名字到verticle工厂的规则"></a>映射verticle名字到verticle工厂的规则</h4><p>当使用名字的方式部署verticles时，这个名字用来选择实际的verticle工厂实例化verticle。</p>
<p>verticle的名字可以有一个前缀——是一个字符串后跟着冒号，如果存在，那么久可以用来查找工厂。例如：</p>
<p>js:foo.js<br>groovy:com.mycompany.SomeGroovyCompiledVerticle // Use the Groovy verticle factory<br>service:com.mycompany:myorderservice // Uses the service verticle factory</p>
<p>如果没有前缀存在，Vert.x将会找一个后缀并用这个后缀来找队友的工厂。</p>
<p>foo.js // Will also use the JavaScript verticle factory<br>SomeScript.groovy // Will use the Groovy verticle factory</p>
<p>如果前缀和后缀都不存在，Vert.x将会假定它是一个Java的完全有资格的类名（FQCN），并尝试实例化它。</p>
<h4 id="Verticle工厂在哪"><a href="#Verticle工厂在哪" class="headerlink" title="Verticle工厂在哪"></a>Verticle工厂在哪</h4><p>大多数的Verticles工厂在Vert.x启动的时候从classpath加载。</p>
<p>如果你想的话，你可以使用<code>registerVerticleFactory</code>和<code>unregisterVerticleFactory</code>，程序化注册和取消注册一个verticle工厂。</p>
<h4 id="等待部署完成"><a href="#等待部署完成" class="headerlink" title="等待部署完成"></a>等待部署完成</h4><p>Verticle的部署是异步的并可能在调用部署返回之后的一段时间后完成。</p>
<p>如果你想要收到通知当部署完成的时候，你可以在部署时知道一个完成的handler：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Deployment id is: "</span> + res.<span class="literal">result</span>());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Deployment failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个完成的handler将会被传入一个包含了部署ID字符串的结果，如果部署成功了的话。</p>
<p>这个部署ID可以被在之后被使用，如果你想要卸载这次部署。</p>
<h4 id="卸载部署了的verticle"><a href="#卸载部署了的verticle" class="headerlink" title="卸载部署了的verticle"></a>卸载部署了的verticle</h4><p>部署是可以通过<code>undeploy</code>卸载的。</p>
<p>卸载对它自己来说是异步的，所以如果你想要被通知当卸载完成的时候，你可以部署一个指定完成的handler：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vertx.undeploy(deploymentID, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Undeployed ok"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Undeploy failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="指定verticle实例的数量"><a href="#指定verticle实例的数量" class="headerlink" title="指定verticle实例的数量"></a>指定verticle实例的数量</h4><p>当你使用一个verticle名字部署一个verticle时，你可以指定你想要部署verticle实例的数量：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DeploymentOptions <span class="keyword">options</span> = <span class="keyword">new</span> DeploymentOptions().setInstances(<span class="number">16</span>);</div><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, <span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>这对拓展到多核上是有用的。例如，你科恩个有一个web服务的verticle需要部署并且你的机器是是多核CPU，因此，你想部署多个实例以便充分使用上全部的核心数。</p>
<h4 id="给一个verticle传入配置文件"><a href="#给一个verticle传入配置文件" class="headerlink" title="给一个verticle传入配置文件"></a>给一个verticle传入配置文件</h4><p>配置使用JSON的格式可以传入到一个verticle里在部署的时候：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JsonObject <span class="built_in">config</span> = <span class="keyword">new</span> JsonObject().<span class="built_in">put</span>(<span class="string">"name"</span>, <span class="string">"tim"</span>).<span class="built_in">put</span>(<span class="string">"directory"</span>, <span class="string">"/blah"</span>);</div><div class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setConfig(<span class="built_in">config</span>);</div><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, options);</div></pre></td></tr></table></figure>
<p>这个配置可以通过<code>Context</code>对象或者直接使用<code>config</code>方法调用。</p>
<p>这个配置反悔了一个JSON格式的对象，所以你可以获取数据就像下面这样：</p>
<pre><code>System.out.println(&quot;Configuration: &quot; + config().getString(&quot;name&quot;));
</code></pre><h4 id="在verticle里访问环境变量"><a href="#在verticle里访问环境变量" class="headerlink" title="在verticle里访问环境变量"></a>在verticle里访问环境变量</h4><p>环境变量和系统属性是可以使用JAVA API来访问的。</p>
<pre><code>System.getProperty(&quot;prop&quot;);
System.getenv(&quot;HOME&quot;);
</code></pre><h4 id="verticle组隔离"><a href="#verticle组隔离" class="headerlink" title="verticle组隔离"></a>verticle组隔离</h4><p>默认地，Vert.x有一个平行的classpath。例如：当Vert.x部署verticles时，它是使用当前的classloader来做的，它并不创建一个新的。在大多数例子中，这是最简单、最清晰和最干净的事情。</p>
<p>然而，在一些例子中，你可能想在你的应用中部署一个verticle，它的类和其他的是隔离的。</p>
<p>这可能是个例子，例如，如果你想要在一个Vert.x实例中部署有着相同类名字两个不同版本的verticle，或者你想要两个不同的verticles使用不同的jar库版本。</p>
<p>当使用一个隔离组时，你需要提供一个你想要隔离的类名字的集合，将它放到<code>setIsolatedClasses</code>中。这可以是进入到一个全的类名，如<code>com.mycompany.myproject.engine.MyClass</code>，也可以是通配符的方式，可以匹配包或子包里的多个类，如：<code>com.mycompany.myproject.*</code>将会匹配在包<code>com.mycompany.myproject</code>下的任何类或任何子包。</p>
<p>请记住只有这个匹配的类会被隔离，任何其他的类都会通过当前的classloader加载。</p>
<p>额外的classpath也可以通过<code>setExtraClasspath</code>来设置，如果你想要加载的类或资源不在当前主classpath里。</p>
<blockquote>
<p>警告 使用这个特性时需要小心。Class-loaders可能会导致bug，并且会让调试变得困难，除其他外。</p>
</blockquote>
<p>下面是一个使用隔离组隔离verticle部署的例子：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DeploymentOptions <span class="keyword">options</span> = <span class="keyword">new</span> DeploymentOptions().setIsolationGroup(<span class="string">"mygroup"</span>);</div><div class="line"><span class="keyword">options</span>.setIsolatedClasses(Arrays.<span class="keyword">asList</span>(<span class="string">"com.mycompany.myverticle.*"</span>,</div><div class="line">                   <span class="string">"com.mycompany.somepkg.SomeClass"</span>, <span class="string">"org.somelibrary.*"</span>));</div><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.myverticle.VerticleClass"</span>, <span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>Verticles在部署的时候可以是高可用生效。在这个的内容中，当一个verticle部署在vert.x实力上后突然的死掉了，这个verticle会被集群里其他的vert.x实例重新部署。</p>
<p>为了运行一个启用高可用的verticle，只需要添加上<code>-ha</code>即可：</p>
<pre><code>vertx run my-verticle.js -ha
</code></pre><p>当启用了高可用是，不在需要添加<code>-cluster</code>。</p>
<p>关于高可用特性和配置的更多详细的信息在<a href="High Availability and Fail-Over">High Availability and Fail-Over</a>小节中。</p>
<h4 id="从命令行运行verticles"><a href="#从命令行运行verticles" class="headerlink" title="从命令行运行verticles"></a>从命令行运行verticles</h4><p>你可以在你的Maven或Gradle项目中通过添加Vert.x core库的dependency这个支持的方式直接使用Vert.x。</p>
<p>如果你原意，你可以可以直接在命令行这里执行Vert.x verticles。</p>
<p>为了这样做，你需要下载并按照整个Vert.x发行版，并且将<code>bin</code>目录添加到<code>PATH</code>环境变量里。也要确定环境变量中你有Java 8JDK。</p>
<blockquote>
<p>JDK是被需要来支持即时编译Java代码</p>
</blockquote>
<p>现在你就可以使用<code>vertx run</code>命令运行你的verticles。下面这就是例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Run a JavaScript verticle</span></div><div class="line">vertx <span class="keyword">run</span><span class="bash"> my_verticle.js</span></div><div class="line"></div><div class="line"><span class="comment"># Run a Ruby verticle</span></div><div class="line">vertx <span class="keyword">run</span><span class="bash"> a_n_other_verticle.rb</span></div><div class="line"></div><div class="line"><span class="comment"># Run a Groovy script verticle, clustered</span></div><div class="line">vertx <span class="keyword">run</span><span class="bash"> FooVerticle.groovy -cluster</span></div></pre></td></tr></table></figure>
<p>你甚至可以运行Java源代码而不用先编译。</p>
<pre><code>vertx run SomeJavaSource.java
</code></pre><p>Vert.x在运行前将会即时编译Java源码文件。这是真正有益于快速原型verticles和很好的演示。在执行的时候不再需要先设置Maven或Gradle环境。</p>
<p>当在命令行里执行vertx，为获取全部的信息有大量的选项可用，在命令行里输入<code>vertx</code>即可。</p>
<h4 id="Vert-x退出原因"><a href="#Vert-x退出原因" class="headerlink" title="Vert.x退出原因"></a>Vert.x退出原因</h4><p>Vert.x实例维护的线程并不是一个后台线程，所以他们将防止JVM退出。</p>
<p>如果你正在嵌入Vert.x并且你已经完成了它，你需要调用<code>close</code>方法结束它。</p>
<p>这将会关掉所有里面的线程池及关闭其他资源，并允许JVM退出。</p>
<h4 id="Context对象"><a href="#Context对象" class="headerlink" title="Context对象"></a>Context对象</h4><p>当Vert.x提供了一个时间给handler或调用Verticle的start或stop方法时，这个执行就已经被关联到了一个<code>Context</code>。通常的一个context是一个event-loop context并捆绑给一个特定的event loop线程。所以，content的执行总是会出现在完全相同的event loop线程上。在工作者verticle的例子中，运行阻塞代码，一个工作者context将会被关联到从工作者线程池获取到的执行的这个线程。</p>
<p>为获取这个context，使用<code>getOrCreateContext</code>方法：</p>
<pre><code>Context context = vertx.getOrCreateContext();
</code></pre><p>如果当前线程有一个context对象关联到它了，它会复用这个context对象。如果没有一个新的context实例被创建。你可以测试你获取到的这个context的类型：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Context context = vertx.getOrCreateContext();</div><div class="line"><span class="keyword">if</span> (context.isEventLoopContext()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context attached to Event Loop"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isWorkerContext()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context attached to Worker Thread"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isMultiThreadedWorkerContext()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context attached to Worker Thread - multi threaded worker"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (! Context.isOnVertxThread()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context not attached to a thread managed by vert.x"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你获取到一个context对象，你可以在这个context上一步的运行代码。换言之，你提交了一个任务，之后最终将会被同一个context运行：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vertx.getOrCreateContext<span class="function"><span class="params">()</span>.<span class="title">runOnContext</span><span class="params">( (v) -&gt; &#123;</span></span></div><div class="line">  System.out.println(<span class="string">"This will be executed asynchronously in the same context"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当有多个handler运行在同一个context里时，他们可能想要更新数据。这个context对象提供了方法来存储和获取共享在这个context里的数据。例如，运行<code>runOnContext</code>可以让你传入数据到某个特定的动作上：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final <span class="built_in">Context</span> <span class="built_in">context</span> = vertx.getOrCreateContext()<span class="comment">;</span></div><div class="line"><span class="built_in">context</span>.put(<span class="string">"data"</span>, <span class="string">"hello"</span>)<span class="comment">;</span></div><div class="line"><span class="built_in">context</span>.runOnContext((v) -&gt; &#123;</div><div class="line">  String hello = <span class="built_in">context</span>.get(<span class="string">"data"</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>context对象允许你使用<code>config</code>方法访问verticle配置。检查传入配置到verticle小节获取配置更详细的信息。</p>
<h4 id="执行周期动作和延时动作"><a href="#执行周期动作和延时动作" class="headerlink" title="执行周期动作和延时动作"></a>执行周期动作和延时动作</h4><p>这是很普遍的，在Vert.x里想要获取一个延时或周期性的动作。</p>
<p>在标准的verticles里你不能简单的使用线程休眠来达到演示的效果，因为这将会阻塞event loop线程。</p>
<p>你需要使用Vert.x timers来代替。Timers可以被设置为一次性或周期性。两者我们都将会讨论。</p>
<p><strong>一次性的Timers</strong></p>
<p>在一个确定好的延迟时间后一次调用事件handler，延迟时间以微妙表示。</p>
<p>激活一个定时器一次，使用<code>setTimer</code>方法，传入一个延迟时间和一个handler即可。</p>
<pre><code>long timerID = vertx.setTimer(1000, id -&gt; {
    System.out.println(&quot;And one second later this is printed&quot;);
});

System.out.println(&quot;First this is printed&quot;);
</code></pre><p>这个返回值是一个独特的timer id，在之后可以用来取消这个timer。这个handler也传入了这个timer id。</p>
<p><strong>周期性的Timers</strong></p>
<p>你可以使用<code>setPeriodic</code>方法设置一个周期性触发的定时器。</p>
<p>将有一个等于该周期的首次延迟。</p>
<p><code>setPeriodic</code>有一个独特的timer id返回值。可以在之后用来取消这个周期性定时器。</p>
<p>这个参数也传入到了定时器时间handler里：</p>
<p>记住这个定时器会在一个基本的周期后触发。如果你的周期性处理占据了一个大量的时间来执行，你的定时器时间可以连续执行或者更糟：堆一起运行。</p>
<p>在这种情形下，你可以考虑使用<code>setTimer</code>来代替。一旦你的处理完成了，你可以设置下一个定时器。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> timerID = vertx.setPeriodic(<span class="number">1000</span>, id -&gt; &#123;</div><div class="line">  System.out.<span class="built_in">println</span>(<span class="string">"And every second this is printed"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"First this is printed"</span>);</div></pre></td></tr></table></figure>
<p><strong>取消定时器</strong></p>
<p>要取消一个周期性的定时器，调用<code>cancelTimer</code>方法并制定一个timer id即可。例如：</p>
<pre><code>vertx.cancelTimer(timerID);
</code></pre><p><strong>在verticles里自动清除</strong></p>
<p>如果你在一个verticles里创建了一个定时器，那么这个定时器将会被自动关闭当这个verticle被卸载的时候。</p>
<h4 id="Verticle工作池"><a href="#Verticle工作池" class="headerlink" title="Verticle工作池"></a>Verticle工作池</h4><p>verticle使用Vert.x工作者池来执行阻塞动作，如：<code>executeBlocking</code>或工作者verticle。</p>
<p>一个不同的工作者池可以在部署的选项里指定：</p>
<pre><code>vertx.deployVerticle(&quot;the-verticle&quot;, new DeploymentOptions().setWorkPoolName(&quot;the-specific-pool&quot;));
</code></pre><hr>
<h3 id="The-Event-Bus"><a href="#The-Event-Bus" class="headerlink" title="The Event Bus"></a>The Event Bus</h3><hr>
<p>event bus是Vert.x的神经系统。</p>
<p>每个Vert.x实例都有一个单一的event bus实例，通过<code>eventBus</code>方法获取到它。</p>
<p>event bus允许你的应用中不同的部分之间通信，不用在乎这些部分使用什么语言写的、是否是在同一个vert.x实例中或者在不同的vert.x实例。</p>
<p>它甚至可以被桥接以允许运行在客户端的JavaScript在同一事件总线上通信。</p>
<p>event bus形成跨越多个服务器节点和多个浏览器的分布式对等消息传递系统。</p>
<p>event bus支持发布和订阅、点对点、请求和回复消息传递。</p>
<p>event bus API是很简单的。基本的调用时注册一个handler、取消注册一个handler、发送和发布消息。</p>
<p>首先从一些理论开始：</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>地址</strong></p>
<p>event bus发送消息到一个地址上。</p>
<p>Vert.x没有花哨的寻址方案。在Vert.x里一个地址就是一个简单的字符串。任何字符串都是有效的。然而，使用某种方案是明智的。例如，使用英文句号来划分命名空间。</p>
<p>一些有效的地址的例子：europe.news.feed1，acme.games.pacman，sausages，and X。</p>
<p><strong>Handlers</strong></p>
<p>消息是在handler里接收的。你可以在地址上注册一个handler。</p>
<p>大多数不同的handlers可以被注册到相同的地址上。</p>
<p>一个单一的handler可以注册在多个不同的地址上。</p>
<p><strong>发布和订阅消息</strong></p>
<p>event bus支持发布消息。</p>
<p>消息需要被发布到一个地址上。发布意味着分发消息给全部注册到这个地址上的handler。</p>
<p>这和发布/订阅消息传递模式有点像。</p>
<p><strong>点对点和请求-回复消息传递</strong></p>
<p>event bus也支持点对点消息传递。</p>
<p>消息会被发送到一个地址上。 Vert.x然后将它路由到在该地址注册的handlers之一。</p>
<p>如果那有超过一个的handler注册在低智商，将使用非严格的循环算法选择一个。</p>
<p>点对点的消息传递，在发送消息的时候可以指定一个可选的回复handler。</p>
<p>当消息被一个接受者收到了，然后被处理，这个接受者可以选择决定回复这个消息。如果接受者回复了消息，那么一个回复handler将会被调用。</p>
<p>当这个回复发送会给发送者，它依旧可以回复消息。这可以无限重复，并允许在两个不同的verticles之间建立对话。</p>
<p>这个普遍的消息传递模式被称为请求-回复模式。</p>
<p><strong>尽力交付</strong></p>
<p>Vert.x尽它最大的努力交付消息，并不会无故的扔掉消息。这被称为尽力交付。</p>
<p>然而，在全部的失败情形或部分event bus中，消息仍然可能会丢失。</p>
<p>如果你的应用关心这些丢失消息，你应该编写你的handler为idempotent，并等你的发送者恢复后再重试。</p>
<p><strong>消息类型</strong></p>
<p>开箱即用的Vert.x允许你使用任何原始的、简单的类型，如String或buffers，都可以作为消息被发送。</p>
<p>然而，这是很方便和普遍的方式，在Vert.x里以JSON格式发送消息。</p>
<p>JSON在所有的Vert.x支持的语言都很容易创建、阅读和解析。所以，它已经变成了Vert.x的一种通用格式。</p>
<p>当然如果你不想使用JSON格式，Vert.x也不会强迫你使用。</p>
<p>event bus非常灵活，并且还支持通过event bus发送任意对象。你可以通过给要发送的对象定义一个编解码器来实现。</p>
<h4 id="Event-Bus-API"><a href="#Event-Bus-API" class="headerlink" title="Event Bus API"></a>Event Bus API</h4><p>让我们来跳到API。</p>
<p><strong>获取到event bus</strong></p>
<p>你可以像接下来这样获取到一个event bus的引用：</p>
<pre><code>EventBus eb = vertx.eventBus();
</code></pre><p>对每个Vert.x实例来说，有且只有一个event bus实例。</p>
<p><strong>注册Handlers</strong></p>
<p>注册一个handler最简单的方法就是使用<code>consumer</code>。下面就是一个例子：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">EventBus eb = vertx.eventBus()<span class="comment">;</span></div><div class="line"></div><div class="line">eb.consumer(<span class="string">"news.uk.sport"</span>, message -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"I have received a message: "</span> + message.<span class="keyword">body());</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>当一个消息到达了你的handler，你的handler将会被调用，然后传入这个<code>message</code>。</p>
<p>调用consumer()方法返回了一个<code>MessageConsumer</code>对象实例。</p>
<p>这个对象随后可以用来取消注册handler，或者作为流使用handler。</p>
<p>或者你可以使用<code>consumer</code>来返回一个没有设置handler的MessageConsumer对象。然后像这样来设置一个handler。例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventBus eb = vertx.eventBus()<span class="comment">;</span></div><div class="line"></div><div class="line">MessageConsumer&lt;String&gt; consumer = eb.consumer(<span class="string">"news.uk.sport"</span>)<span class="comment">;</span></div><div class="line">consumer.handler(message -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"I have received a message: "</span> + message.<span class="keyword">body());</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>当注册一个handler到一个集群event bus，这会花费一些时间来注册到集群的所有节点。</p>
<p>如果你想要收到通知，当注册已经全部结束了，你可以在MessageConsumer对象上注册一个<code>completion handler</code>。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">consumer.completionHandler(res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"The handler registration has reached all nodes"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Registration failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>取消注册Handlers</strong></p>
<p>取消注册一个handler，调用<code>unregister</code>。</p>
<p>如果是在一个集群上的event bus，取消注册会花费一些时间遍历到所有的节点，如果你想要接收到通知，当取消注册完成后，使用<code>unregister</code>。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">consumer.unregister(res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"The handler un-registration has reached all nodes"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Un-registration failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>发布消息</strong></p>
<p>发布消息时很简单的。只需要使用<code>publish</code>并指定要发布的地址就可以了。</p>
<pre><code>eventBus.publish(&quot;news.uk.sport&quot;, &quot;Yay! Someone kicked a ball&quot;);
</code></pre><p>消息就会被交付到所有注册了这个news.uk.sport地址上。</p>
<p><strong>发送消息</strong></p>
<p>发送消息将导致在接收消息的地址处仅注册一个处理程序。这是点对点消息模式。以非严格的循环方式选择handler。</p>
<p>你可以使用<code>send</code>发送一个消息</p>
<pre><code>eventBus.send(&quot;news.uk.sport&quot;, &quot;Yay! Someone kicked a ball&quot;);
</code></pre><p><strong>在消息上设置标题</strong></p>
<p>发送到event bus的消息可以包含头。</p>
<p>这可以通过提供一个指定的<code>DeliveryOptions</code>参数，当发送或发布消息时：</p>
<pre><code>DeliveryOptions options = new DeliveryOptions();
options.addHeader(&quot;some-header&quot;, &quot;some-value&quot;);
eventBus.send(&quot;news.uk.sport&quot;, &quot;Yay! Someone kicked a ball&quot;, options);
</code></pre><p><strong>消息排序</strong></p>
<p>Vert.x将会交付消息到任何一个特定的handler里，其顺序和从任何一个特定的发送者一致。</p>
<p><strong>消息对象</strong></p>
<p>这个对象在消息handler里接收到的是一个<code>Message</code>对象。</p>
<p>这个消息<code>body</code>和这个被发送或发布的对象是相符的。</p>
<p>通过<code>headers</code>消息的头是可用的。</p>
<p><strong>确认消息和发送回复</strong></p>
<p>当event bus尝试使用<code>send</code>方法发送消息给一个在event bus上注册的<code>MessageConsumer</code>对象。</p>
<p>在一些情形下，这对发送者是有用的，当知道了消费者接收到了消息并按加工了它。</p>
<p>为了确认消息已经被消费者加工过了，可以通过调用<code>reply</code>方法回复一个消息。</p>
<p>当这种情况发生时，它导致一个回复被发送回发送者，并且回复处理程序被调用与回复。</p>
<p>一个例子将会让这段话更加清晰：</p>
<p>接收者：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MessageConsumer&lt;<span class="keyword">String</span>&gt; consumer = eventBus.consumer(<span class="string">"news.uk.sport"</span>);</div><div class="line">consumer.handler(<span class="keyword">message</span> -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"I have received a message: "</span> + <span class="keyword">message</span>.body());</div><div class="line">  <span class="keyword">message</span>.reply(<span class="string">"how interesting!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>发送者：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eventBus.send(<span class="string">"news.uk.sport"</span>, <span class="string">"Yay! Someone kicked a ball across a patch of grass"</span>, ar -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Received reply: "</span> + ar.result().<span class="keyword">body</span>());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个回复可以包含一个消息体——能够携带有用的信息。</p>
<p>什么“处理”实际上意味着应用程序定义，完全取决于消息消费者做什么，而不是Vert.x event bus本身知道或关心的东西。</p>
<p>一些例子：</p>
<ul>
<li>一个简单的消息消费者实现了一个返回当天的时间的服务，这个服务将会确认这个在的回复体里包含了当天时间的消息。</li>
<li>一个消息消费者实现了一个持久队列，可能会返回<code>true</code>以此确认消息成功持久化存储了，返回<code>false</code>表示没有持久化存储。</li>
<li>一个消息消费者执行一个订单，可能会返回<code>true</code>来确认订单已经执行，然后就可以从数据库中删除了。</li>
</ul>
<p><strong>发送超时</strong></p>
<p>当发送一个消息带有回复的handler时，你可以在<code>DeliveryOptions</code>指定一个超时时间。</p>
<p>如果在这个超时时间内没有收到回复，这个回复handler将会调用失败。</p>
<p>默认的超时时间是30秒。</p>
<p><strong>发送失败</strong></p>
<p>消息发送失败可能是有其他原因导致的，包括：</p>
<ul>
<li>没有可用的handler发送消息。</li>
<li>接受者明确的用<code>fail</code>表示消息接收失败。</li>
</ul>
<p>在所有的情形中，回复的handler会用调用特定的失败。</p>
<p><strong>消息编解码</strong></p>
<p>你可以发送任何你喜欢的对象到event bus，如果你为它定义并注册了一个<code>message codec</code>。</p>
<p>消息编解码器有一个名字，你可以在<code>DeliverOptions</code>指定这个名字当发送或发布消息的时候：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eventBus.registerCodec(myCodec);</div><div class="line"></div><div class="line">DeliveryOptions <span class="keyword">options</span> = <span class="keyword">new</span> DeliveryOptions().setCodecName(myCodec.name());</div><div class="line"></div><div class="line">eventBus.send(<span class="string">"orders"</span>, <span class="keyword">new</span> MyPOJO(), <span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>如果你总是想要为一个特定的类型使用相同的编解码器，那么你可以注册一个默认的编解码器，然后你就可以不用在每次发送的<code>DeliveryOptions</code>里去指定编解码器了。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eventBus.registerDefaultCodec(<span class="type">MyPOJO</span>.<span class="keyword">class</span>, myCodec);</div><div class="line"></div><div class="line">eventBus.send(<span class="string">"orders"</span>, <span class="function"><span class="keyword">new</span> <span class="title">MyPOJO</span>());</span></div></pre></td></tr></table></figure>
<p>你可以用<code>unregisterCodec</code>取消注册一个消息编解码器。</p>
<p>消息解码器并不总是需要对相同类型编码和解码。例如，你可以写一个允许发送一个MyPOJO类对象的解码器，但是当消息送到这个handler时，这个消息是会被作为一个MyOtherPOJO类到达。</p>
<p><strong>集群Event Bus</strong></p>
<p>Event Bus并不仅仅存在一个单一的Vert.x实例中。通过在网络上将不同的Vert.x实例聚合在一起，他们可以形成一个单一的分布式事件总线。</p>
<p><strong>集群编程</strong></p>
<p>如果您以编程方式创建Vert.x实例，则通过将Vert.x实例配置为集群来获取集群事件总线；</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VertxOptions <span class="keyword">options</span> = <span class="keyword">new</span> VertxOptions();</div><div class="line">Vertx.clusteredVertx(<span class="keyword">options</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    Vertx vertx = res.result();</div><div class="line">    EventBus eventBus = vertx.eventBus();</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed: "</span> + res.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>你应该要确保在你的classpath中有一个<code>ClusterManager</code>实现，例如，默认地是<code>HazelcastClusterManager</code>。</p>
<p><strong>集群命令行</strong></p>
<p>你可以在命令行中运行Vert.x集群</p>
<pre><code>vertx run my-verticle.js -cluster
</code></pre><h4 id="在verticles里自动清除"><a href="#在verticles里自动清除" class="headerlink" title="在verticles里自动清除"></a>在verticles里自动清除</h4><p>如果你在verticles内部注册了event bus handlers，这些handlers将会被自动取消注册当这个verticle被卸载时。</p>
<hr>
<h3 id="配置event-bus"><a href="#配置event-bus" class="headerlink" title="配置event bus"></a>配置event bus</h3><hr>
<p>Event bus是可以被配置的。大概event bus是集群时，这是特别有用的。基于event bus使用TCP连接来发送和接收消息，<code>EventBusOptions</code>可以让你配置所有关于TCP连接的部分。当event bus扮演一个服务器和客户端，相关的配置为<code>NetClientOptions</code>和<code>NetServerOptions</code>。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">VertxOptions <span class="keyword">options</span> = <span class="keyword">new</span> VertxOptions()</div><div class="line">    .setEventBusOptions(<span class="keyword">new</span> EventBusOptions()</div><div class="line">        .setSsl(<span class="keyword">true</span>)</div><div class="line">        .setKeyStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"keystore.jks"</span>).setPassword(<span class="string">"wibble"</span>))</div><div class="line">        .setTrustStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"keystore.jks"</span>).setPassword(<span class="string">"wibble"</span>))</div><div class="line">        .setClientAuth(ClientAuth.REQUIRED)</div><div class="line">    );</div><div class="line"></div><div class="line">Vertx.clusteredVertx(<span class="keyword">options</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    Vertx vertx = res.result();</div><div class="line">    EventBus eventBus = vertx.eventBus();</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed: "</span> + res.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>前一个代码片段描述了通过event bus怎么使用一个SSL连接，代替了普通的TCP连接。</p>
<p><strong>警告</strong>：要在集群模式下强制实施安全性，必须将集群管理器配置为使用加密或强制执行安全性。想要更深入的了解，请翻阅到集群管理部分。</p>
<p>event bus配置在所有的集群节点上都是要保持一致。</p>
<p><code>EventBusOptions</code>也允许你指定event bus是否是一个集群、端口或者主机。你只需要设置<code>setClustered</code>、<code>getClusterHost</code>、<code>getClusterPort</code>。</p>
<p>当在容器中使用时，你可能需要配置Public主机和端口：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">VertxOptions <span class="keyword">options</span> = <span class="keyword">new</span> VertxOptions()</div><div class="line">    .setEventBusOptions(<span class="keyword">new</span> EventBusOptions()</div><div class="line">        .setClusterPublicHost(<span class="string">"whatever"</span>)</div><div class="line">        .setClusterPublicPort(<span class="number">1234</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">Vertx.clusteredVertx(<span class="keyword">options</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    Vertx vertx = res.result();</div><div class="line">    EventBus eventBus = vertx.eventBus();</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed: "</span> + res.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>不像其他的语言，Java没有JSON的原生类支持，所以我们提供了两个类，使得在Vert.x应用程序中处理JSON有点容易。</p>
<h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><p><code>JsonObject</code>类表示JSON对象。</p>
<p>一个JSON对象基本上就是一个map，key为string类型，value为JSON支持的三种类型之一（string, number, boolean）。</p>
<p>JSON对象也支持null值。</p>
<p><strong>创建JSON对象</strong></p>
<p>用默认的构造方法可以创建一个空的JSON对象。</p>
<p>你可以从String类型表示形式创建JSON对象，像这样</p>
<pre><code>String jsonString = &quot;{\&quot;foo\&quot;:\&quot;bar\&quot;}&quot;;
JsonObject object = new JsonObject(jsonString);
</code></pre><p><strong>将条目放入到JSON对象</strong></p>
<p>使用<code>put</code>方法可以把值放入到一个JSON对象中。</p>
<p>这个方法可以被链式的调用，因为流式API：</p>
<pre><code>JsonObject object = new JsonObject();
object.put(&quot;foo&quot;, &quot;bar&quot;).put(&quot;num&quot;, 123).put(&quot;mybool&quot;, true);
</code></pre><p><strong>从JSON对象中获取值</strong></p>
<p>你可以从一个JSON对象中获取到一个值，你着急需要使用<code>getXXX</code>方法。例如：</p>
<pre><code>String val = jsonObject.getString(&quot;some-key&quot;);
int intVal = jsonObject.getInteger(some-other-key);
</code></pre><p><strong>重新编码JSON对象转为String</strong></p>
<p>你可以使用<code>encode</code>方法重新编码对象，使其转为一个String格式。</p>
<h4 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h4><p><code>JsonArray</code>类表示JSON数组。</p>
<p>一个JSON数组是值（string, number, boolean）的序列。</p>
<p>JSON数组可以包含null值。</p>
<p><strong>创建一个JSON数组</strong></p>
<p>可以用默认的构造方法创建一个空的JSON数组对象。</p>
<p>你可以从String表示形式创建JSON数组，就像这样：</p>
<pre><code>String jsonString = &quot;[\&quot;foo\&quot;,\&quot;bar\&quot;]&quot;;
JsonArray array = new JsonArray(jsonString);
</code></pre><p><strong>添加条目到JSON对象里</strong></p>
<p>你可以通过<code>add</code>方法添加条目到一个JSON数组对象中。</p>
<pre><code>JsonArray array = new JsonArray();
array.add(&quot;foo&quot;).add(123).add(false);
</code></pre><p><strong>从JSON数组中获取值</strong></p>
<p>你可以是用<code>getXXX</code>方法从JSON数组中获取值，例如：</p>
<pre><code>String val = array.getString(0);
Integer intVal = array.getInteger(1);
Boolean boolean = array.getBoolean(2);
</code></pre><p><strong>重新编码将JSON数组转为String</strong></p>
<p>你可以使用<code>encode</code>方法重新编码JSON数组，将其转变为String格式。</p>
<hr>
<h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><hr>
<p>大多数数据在Vert.x里都是是使用buffers传递。</p>
<p>一个buffer是一个0或多个字节的序列，可以从中读取或写入并且根据需要自动扩展以容纳写入到里面的任何字节。你可能想到buffer是一个智能字节数组。</p>
<h4 id="创建Buffers"><a href="#创建Buffers" class="headerlink" title="创建Buffers"></a>创建Buffers</h4><p>Buffer可以通过一个静态方法<code>Buffer.buffer</code>创建。</p>
<p>Buffer可以初始化为string数组或byte数组，或空的buffer也可以被创建。</p>
<p>下面是创建buffer的一些例子：</p>
<p>创建一个新的空buffer：</p>
<pre><code>Buffer buffer = Buffer.buffer();
</code></pre><p>根据一个String创建一个buffer，这个String将会在buffer中用UTF-8重新编码。</p>
<pre><code>Buffer buffer = Buffer.buffer(&quot;some string&quot;);
</code></pre><p>根据一个String创建一个buffer，并制定一个编码格式：</p>
<pre><code>Buffer buffer = Buffer.buffer(&quot;some string&quot;, &quot;UTF-16&quot;);
</code></pre><p>根据一个byte数组创建一个buffer</p>
<pre><code>byte[] bytes = new byte[]{1, 3, 5};
Buffer buff = Buffer.buffer(bytes);
</code></pre><p>创建一个buffer可以在初始化时制定大小。如果你知道你的buffer将会有一个确定的数量被写入，你在创建buffer时可以指定这个大小。这会让这个buffer在初始化的时候分配到足够的内存，并且比当数据被写入它时多次自动调整大小的缓冲器更高效。</p>
<p>注意，这种方式创建的buffer是空的。这并不会在创建buffer时用0来填充这指定的大小。</p>
<pre><code>Buffer buff = Buffer.buffer(10000);
</code></pre><h4 id="写入到一个Buffer"><a href="#写入到一个Buffer" class="headerlink" title="写入到一个Buffer"></a>写入到一个Buffer</h4><p>Buffer有两种写入的方式：追加和随机访问。在任意情况下，buffer为了包含这些字节数总是会自动的扩展大小。用buffer时不可能获取到一个<code>IndexOutOfBoundsException</code>。</p>
<p><strong>追加写入</strong></p>
<p>为了把数据以追加的方式写入到buffer里，你需要用<code>appendXXX</code>方法。Append方法存在多种追加的类型。</p>
<p><code>appendXXX</code>方法的返回值就是buffer本身，所以这可以写成链式的：</p>
<pre><code>Buffer buff = Buffer.buffer();
buff.appendInt(123).appendString(&quot;Hello\n&quot;);
socket.write(buff);
</code></pre><p><strong>随机写入</strong></p>
<p>你也可以把数据写入到buffer的指定位置，通过使用<code>setXXX</code>方法。Set方法存在多种数据类型。所有的set方法都可以把索引位置作为第一个参数，索引位置表示在这个buffer中从这个位置开始写入数据。</p>
<p>buffer为了容纳数据总是会自动扩展大小。</p>
<pre><code>Buffer buff = Buffer.buffer();

buff.setInt(1000, 123);
buff.setString(0, &quot;hello&quot;);
</code></pre><h4 id="从Buffer中读取内容"><a href="#从Buffer中读取内容" class="headerlink" title="从Buffer中读取内容"></a>从Buffer中读取内容</h4><p>从buffer中读取数据使用<code>getXXX</code>方法。Get方法存在多种数据类型。这些方法的第一个参数是buffer里的一个索引，表示从这个位置获取数据。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Buffer </span><span class="keyword">buff </span>= <span class="keyword">Buffer.buffer();</span></div><div class="line">for (int i = <span class="number">0</span><span class="comment">; i &lt; buff.length(); i += 4) &#123;</span></div><div class="line">  System.out.println(<span class="string">"int value at "</span> + i + <span class="string">" is "</span> + <span class="keyword">buff.getInt(i));</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用无符号数"><a href="#使用无符号数" class="headerlink" title="使用无符号数"></a>使用无符号数</h4><p>无符号数可以被读取或追加或设置到一个buffer中，使用<code>getUnsignedXXX</code>、<code>appendUnsignedXXX</code>、<code>setUnsignedXXX</code>方法。这有益于优化实现最小化带宽消耗的网络协议编解码器。</p>
<p>在接下来的例子中，值200被设置到特定的位置仅用了一个字节长度。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Buffer </span><span class="keyword">buff </span>= <span class="keyword">Buffer.buffer(128);</span></div><div class="line">int pos = <span class="number">15</span><span class="comment">;</span></div><div class="line"><span class="keyword">buff.setUnsignedByte(pos, </span>(<span class="keyword">short) </span><span class="number">200</span>)<span class="comment">;</span></div><div class="line">System.out.println(<span class="keyword">buff.getUnsignedByte(pos));</span></div></pre></td></tr></table></figure>
<p>控制台会显示200。</p>
<h4 id="Buffer长度"><a href="#Buffer长度" class="headerlink" title="Buffer长度"></a>Buffer长度</h4><p>使用<code>length</code>来获取buffer的长度。buffer的长度是buffer中字节的最大数量+1。</p>
<h4 id="复制Buffer"><a href="#复制Buffer" class="headerlink" title="复制Buffer"></a>复制Buffer</h4><p>使用<code>copy</code>方法可以复制一个buffer。</p>
<h4 id="分片buffer（Slicing-buffer）"><a href="#分片buffer（Slicing-buffer）" class="headerlink" title="分片buffer（Slicing buffer）"></a>分片buffer（Slicing buffer）</h4><p>一个切片buffer是在原始buffer上得到的一个新的buffer。例如，它并不复制基本的数据。使用<code>slice</code>是创建了一个分片的buffer。</p>
<h4 id="buffer复用"><a href="#buffer复用" class="headerlink" title="buffer复用"></a>buffer复用</h4><p>在将一个buffer写入到一个socket或者一个类似的地方，这个buffer将不能被复用。</p>
<hr>
<h3 id="写TCP服务器和客户端"><a href="#写TCP服务器和客户端" class="headerlink" title="写TCP服务器和客户端"></a>写TCP服务器和客户端</h3><hr>
<p>Vert.x让你很简单的编写一个无阻塞的TCP客户端和服务器。</p>
<h4 id="创建一个TCP服务器"><a href="#创建一个TCP服务器" class="headerlink" title="创建一个TCP服务器"></a>创建一个TCP服务器</h4><p>创建TCP服务器最近爱的的方式就是全部使用默认的选项，就像接下来这样：</p>
<pre><code>NetServer server = vertx.createNetServer();
</code></pre><h4 id="配置一个TCP服务器"><a href="#配置一个TCP服务器" class="headerlink" title="配置一个TCP服务器"></a>配置一个TCP服务器</h4><p>如果你不想要这个默认的，当创建一个服务器是，你可以传入一个<code>NetServerOptions</code>实例来配置它：</p>
<pre><code>NetServerOptions options = new NetServerOptions.setPort(4321);
NetServer server = vertx.createNetServer(options);
</code></pre><h4 id="服务器开始监听"><a href="#服务器开始监听" class="headerlink" title="服务器开始监听"></a>服务器开始监听</h4><p>为了告诉服务器监听到达的请求，你可以用其中一种<code>listen</code>方法。</p>
<p>为了告诉服务器监听主机和端口，如在选项中指定：</p>
<pre><code>NetServer server = vertx.createNetServer();
server.listen();
</code></pre><p>或者在调用listen方法时指定主机和端口，忽略在选项中的配置：</p>
<pre><code>NetServer server = vertx.createNetServer();
server.listen(1234, &quot;localhost&quot;);
</code></pre><p>默认的主机是<code>0.0.0.0</code>，这意味着监听所有可用的地址，同时默认的端口是0，这是个特殊的端口会教服务器去找一个本地没有使用的随机端口来监听。</p>
<p>实际上绑定端口是异步的，所以这个服务器可能实际上没有绑定上，直到一段时间后调用的listen方法获得了返回。</p>
<p>如果你想要收到通知，当服务器已经开始监听了，你可以在<code>listen</code>方法里提供一个handler调用。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetServer server = vertx.createNetServer();</div><div class="line">server.<span class="built_in">listen</span>(<span class="number">1234</span>, <span class="string">"localhost"</span>, res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now listening!"</span>);</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Failed to bind!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="监听一个随机端口"><a href="#监听一个随机端口" class="headerlink" title="监听一个随机端口"></a>监听一个随机端口</h4><p>如果0被用作监听端口，这个服务器将会找到一个没使用的随机端口来监听。</p>
<p>为了找到服务器监听的真实端口你可以调用<code>actualPort</code>。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetServer server = vertx.createNetServer();</div><div class="line">server.<span class="built_in">listen</span>(<span class="number">0</span>, <span class="string">"localhost"</span>, res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now listening on actual port: "</span> + server.actualPort());</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Failed to bind!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="有连接到达时获取到通知"><a href="#有连接到达时获取到通知" class="headerlink" title="有连接到达时获取到通知"></a>有连接到达时获取到通知</h4><p>当一个连接到达时，想要获得通知，你需要设置一个<code>connectHandler</code>：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NetServer <span class="keyword">server</span> = vertx.createNetServer();</div><div class="line"><span class="keyword">server</span>.connectHandler(socket -&gt; &#123;</div><div class="line">  <span class="comment">// Handle the connection in here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当一个链接到达时，handler会用<code>NetSocket</code>实例调用。</p>
<p>实际的连接是一个类socket接口，让你读取和写入数据也可以做很多其他的事情就如关闭socket。</p>
<h4 id="从socket读取数据"><a href="#从socket读取数据" class="headerlink" title="从socket读取数据"></a>从socket读取数据</h4><p>为了从socket读取收，你需要在socket上设置一个<code>handler</code>。</p>
<p>这个handler会用一个<code>Buffer</code>的实例调用，在socket上每次有数据到达的时候。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServer server = vertx.createNetServer()<span class="comment">;</span></div><div class="line">server.connectHandler(socket -&gt; &#123;</div><div class="line">  socket.handler(<span class="keyword">buffer </span>-&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"I received some bytes: "</span> + <span class="keyword">buffer.length());</span></div><div class="line">  &#125;)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h4 id="写数据到一个socket"><a href="#写数据到一个socket" class="headerlink" title="写数据到一个socket"></a>写数据到一个socket</h4><p>你可以通过<code>write</code>方法写入数据到socket。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Buffer <span class="built_in">buffer</span> = Buffer.<span class="built_in">buffer</span>().appendFloat(<span class="number">12.34</span>f).appendInt(<span class="number">123</span>);</div><div class="line">socket.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</div><div class="line"></div><div class="line"><span class="comment">// Write a string in UTF-8 encoding</span></div><div class="line">socket.<span class="built_in">write</span>(<span class="string">"some data"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Write a string using the specified encoding</span></div><div class="line">socket.<span class="built_in">write</span>(<span class="string">"some data"</span>, <span class="string">"UTF-16"</span>);</div></pre></td></tr></table></figure>
<p>写入操作是异步的，可能不会出现直到调用写入方法收到返回。</p>
<h4 id="关闭handler"><a href="#关闭handler" class="headerlink" title="关闭handler"></a>关闭handler</h4><p>如果你想收到通知当关闭一个socket时，你可以在socket上设置<code>closeHandler</code>：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">socket.<span class="keyword">closeHandler(v </span>-&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"The socket has been closed"</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>你可以设置一个<code>exceptionHandler</code>来接收任何发生在这个socket上的异常。</p>
<h4 id="event-bus写入handler"><a href="#event-bus写入handler" class="headerlink" title="event bus写入handler"></a>event bus写入handler</h4><p>每个socket自动注册一个handler到event bus上，当这个handler上收到了任何buffer时，它将buffer写入给它自己。</p>
<p>这能让你写数据到socket上，通过这个handler将buffer数据发送到不同的verticle中甚至不同的Vert.x实例中。</p>
<p>这个handler的地址通过<code>writeHandlerID</code>方法设置。</p>
<h4 id="本地和远程地址"><a href="#本地和远程地址" class="headerlink" title="本地和远程地址"></a>本地和远程地址</h4><p><code>NetSocket</code>的本地地址可以使用<code>localAddress</code>获取。</p>
<p><code>NetSocket</code>的远程地址可以使用<code>remoteAddress</code>获取。</p>
<h4 id="从classpath发送文件或资源"><a href="#从classpath发送文件或资源" class="headerlink" title="从classpath发送文件或资源"></a>从classpath发送文件或资源</h4><p>文件和classpath的资源可以使用<code>sendFile</code>直接被写入到socket里。这是一种很高效的发送文件的方式，因为只要操作系统支持，它就可以被操作系统内核直接处理。</p>
<p>请看从classpath服务文件那一章节了解限制及解决方式或禁用它。</p>
<pre><code>socket.sendFile(&quot;myfile.dat&quot;);
</code></pre><h4 id="流socket"><a href="#流socket" class="headerlink" title="流socket"></a>流socket</h4><p><code>NetSocket</code>实例也是<code>ReadStream</code>和<code>WriteStream</code>实例，所以他们可以用来导出数据或者从其他读取和写入流。</p>
<p>查看流和导出章节获取更多信息。</p>
<h4 id="升级连接到SSL-TLS"><a href="#升级连接到SSL-TLS" class="headerlink" title="升级连接到SSL/TLS"></a>升级连接到SSL/TLS</h4><p>一个不是SSL/TLS连接可以使用<code>upgradeToSsl</code>升级到SSL/TLS连接。</p>
<p>服务器或客户端必须配置为SSL/TLS才能正确的工作。请查看SSL/TLS章节获取更多信息。</p>
<h4 id="关闭一个TCP服务器"><a href="#关闭一个TCP服务器" class="headerlink" title="关闭一个TCP服务器"></a>关闭一个TCP服务器</h4><p>调用<code>close</code>方法关闭服务器。关闭服务器的时候回关闭所有打开的连接和释放服务器所有的资源。</p>
<p>这个关闭方法实际上是异步的，并且可能没有完成直到一段后收到了回调。如果你想要被通知，当实际上关闭完成了的时候，你可以传入一个handler。</p>
<p>这个handler将会被调用，当完全关闭的时候。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server.<span class="built_in">close</span>(res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now closed"</span>);</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"close failed"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="在verticles自动清除"><a href="#在verticles自动清除" class="headerlink" title="在verticles自动清除"></a>在verticles自动清除</h4><p>如果你在verticle里面创建TCP服务器和客户端，这些服务器和客户端将会自动的关闭当这个verticle关闭的时候。</p>
<h4 id="扩展和分享TCP服务器"><a href="#扩展和分享TCP服务器" class="headerlink" title="扩展和分享TCP服务器"></a>扩展和分享TCP服务器</h4><p>任何TCP服务器的handlers总是执行在相同的event loop线程上。</p>
<p>这意味着如果你运行了在多核处理器上运行了一个服务器，你仅有一个实例被部署了，并且在你的服务器上最多只有一个核心被使用了。</p>
<p>为了让你的服务器能够使用多个核心，你需要部署这个服务器多个实例。</p>
<p>你可以在你的代码中编程实例化更多实例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  NetServer server = vertx.createNetServer();</div><div class="line">  server.connectHandler(socket -&gt; &#123;</div><div class="line">    socket.handler(<span class="built_in">buffer</span> -&gt; &#123;</div><div class="line">      <span class="comment">// Just echo back the data</span></div><div class="line">      socket.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  server.<span class="built_in">listen</span>(<span class="number">1234</span>, <span class="string">"localhost"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者，如果你使用verticles，你只需要在命令行使用<code>-instancces</code>选项简单的部署多个服务器实例verticle：</p>
<pre><code>vertx run com.mycompany.MyVerticle -instances 10
</code></pre><p>或者在程序中部署你的verticle</p>
<pre><code>DeploymentOptions options = new DeploymentOptions().setInstances(10);
vertx.deployVerticle(&quot;com.mycompany.MyVerticle&quot;, options);
</code></pre><p>一旦你这样做了，你会发现这个回声服务器和之前工作的一样，但是你机器上全部的核心都可以被利用上并且更多的工作可以被处理。</p>
<p>在这一点上，你可能会问你自己“你怎么可能有多个服务器监听在相同的主机和端口？当然，你会得到端口冲突只要你尝试和部署多个实例。”</p>
<p>Vert.x在这里施了一点点小魔法。</p>
<p>当与现有的服务器相同的主机和端口上部署另一个服务器时，它实际上并不尝试创建一个新的服务器去监听主机和端口。</p>
<p>相反，在里面它会保持一个单一的服务器，并且随着传入连接的到达，它以循环的方式将其分配给任何连接的handlers。</p>
<p>因此Vert.x TCP服务器可以扩展到超过可用的核心数，而每个实例保持单线程。</p>
<h4 id="创建一个TCP客户端"><a href="#创建一个TCP客户端" class="headerlink" title="创建一个TCP客户端"></a>创建一个TCP客户端</h4><p>最简单的方式创建一个TCP客户端，全部使用默认的选项就像下面这样：</p>
<pre><code>NetClient client = vertx.createNetClient();
</code></pre><h4 id="配置TCP客户端"><a href="#配置TCP客户端" class="headerlink" title="配置TCP客户端"></a>配置TCP客户端</h4><p>如果你不想要默认的配置，你可以在创建的实例的时候传入一个<code>NetClientOptions</code>对象进行配置：</p>
<pre><code>NetClientOptions options = new NetClientOptions().setConnectTimeout(10000);
NetClient client = vertx.createNetClient(options);
</code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>为了连接到服务器你需要使用<code>connect</code>方法，指定端口和服务器主机。并且调用一个handler，当连接成功时返回一个包含了<code>NetSocket</code>的结果或者当连接失败时返回失败。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setConnectTimeout(<span class="number">10000</span>);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div><div class="line">client.connect(<span class="number">4321</span>, <span class="string">"localhost"</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Connected!"</span>);</div><div class="line">    NetSocket socket = res.result();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed to connect: "</span> + res.cause().getMessage());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="尝试配置连接"><a href="#尝试配置连接" class="headerlink" title="尝试配置连接"></a>尝试配置连接</h4><p>一个客户端可以配配置为自动重连服务器在发生了不能连接的时间后。这个配置通过<code>setReconnectInterval</code>和<code>setReconnectAttempts</code>完成。</p>
<blockquote>
<p>当前Vert.x将不会尝试重连如果连接失败，间隔性尝试重连仅应用于初始化连接。</p>
</blockquote>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">NetClientOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetClientOptions</span>().</span></div><div class="line">    <span class="title">setReconnectAttempts</span>(<span class="number">10</span>).</div><div class="line">    <span class="title">setReconnectInterval</span>(<span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="title">NetClient</span> <span class="title">client</span> = <span class="title">vertx</span>.<span class="title">createNetClient</span>(options);</div></pre></td></tr></table></figure>
<p>默认地，多连接尝试是被禁用了。</p>
<h4 id="记录网络活动"><a href="#记录网络活动" class="headerlink" title="记录网络活动"></a>记录网络活动</h4><p>为了调试，网络活动应该被记录下来：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().setLogActivity(true);</div><div class="line"></div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().setLogActivity(true);</div><div class="line"></div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>网络活动被Netty记录了，使用的级别为<code>DEBUG</code>、名字为<code>io.netty.handler.logging.LoggingHandler</code>。当记录网络活动时，下面这些你需要记住：</p>
<ul>
<li>日志并不是Vert.x做的，而是由Netty</li>
<li>这并不是一个生产环境的属性</li>
</ul>
<p>Netty会尝试用这个顺序定位下面日志的实现：</p>
<ul>
<li>slf4j</li>
<li>log4j</li>
<li>JDK</li>
</ul>
<p>在类路径上存在slf4j和log4j类足以获取日志记录实现。</p>
<p>这个日志实现可以强制指定为一个特定的实现，通过直接设置Netty的内部日志实现：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Force logging to SLF4J</span></div><div class="line"><span class="selector-tag">InternalLoggerFactory</span><span class="selector-class">.setDefaultFactory</span>(Log4JLoggerFactory.INSTANCE);</div></pre></td></tr></table></figure>
<h4 id="配置服务器和客户端使用SSL-TLS"><a href="#配置服务器和客户端使用SSL-TLS" class="headerlink" title="配置服务器和客户端使用SSL/TLS"></a>配置服务器和客户端使用SSL/TLS</h4><p>TCP客户端和服务器可以被配置为使用TLS-早先的TLS版本就是大家熟知的SSL。</p>
<p>服务器和客户端的API是相同的不管SSL/TLS是否使用了，它能够通过配置<code>NetClientOptions</code>或<code>NetServerOptions</code>实例用来创建服务器和客户端。</p>
<p><strong>在服务器上启用SSL/TLS</strong></p>
<p>用<code>ssl</code>方法启用SSL/TLS。</p>
<p>默认是关闭的。</p>
<p><strong>为服务器指定密钥和证书</strong></p>
<p>SSL/TLS服务器通常需要提供证书给客户端，以便客户端确认服务器的身份。</p>
<p>证书和密钥在服务器端有几种配置的方法：</p>
<p>第一个方法是通过指定一个Java key-store的位置，Java key-store包含了证书和私钥。</p>
<p>Java key stores可以使用JDK附属的实用程序keytool管理。</p>
<p>key store的密码也应该提供：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setKeyStoreOptions(</div><div class="line">    <span class="keyword">new</span> JksOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/server-keystore.jks"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetServer server = vertx.createNetServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>或者你可以读取key store内容到你自己的buffer里并直接提供：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-keystore.jks"</span>);</div><div class="line"><span class="attribute">JksOptions jksOptions</span> = new JksOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setKeyStoreOptions(jksOptions);</div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的密钥和证书，通常以<code>.pfx</code>或<code>.p12</code>结尾，也可以通过和JKS key stores类似的方式加载：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setPfxKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PfxOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/server-keystore.pfx"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetServer server = vertx.createNetServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用Buffer来配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-keystore.pfx"</span>);</div><div class="line"><span class="attribute">PfxOptions pfxOptions</span> = new PfxOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPfxKeyCertOptions(pfxOptions);</div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>提供服务器私钥和证书的另一种方式是把他们分开成以<code>.pem</code>结尾的文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setPemKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PemKeyCertOptions().</div><div class="line">        setKeyPath(<span class="string">"/path/to/your/server-key.pem"</span>).</div><div class="line">        setCertPath(<span class="string">"/path/to/your/server-cert.pem"</span>)</div><div class="line">);</div><div class="line">NetServer server = vertx.createNetServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-key.pem"</span>);</div><div class="line"><span class="attribute">Buffer myCertAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-cert.pem"</span>);</div><div class="line"><span class="attribute">PemKeyCertOptions pemOptions</span> = new PemKeyCertOptions().</div><div class="line">    setKeyValue(myKeyAsABuffer).</div><div class="line">    setCertValue(myCertAsABuffer);</div><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPemKeyCertOptions(pemOptions);</div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>记住pem的配置，私钥并没有被加密。</p>
<p><strong>指定服务器的信任</strong></p>
<p>SSL/TLS服务器可以使用一个证书验证来确认客户端的身份。</p>
<p>服务器端证书验证有多种配置方式：</p>
<p>Java trust stores可以通过JDK附属的实用程序keytool管理。</p>
<p>trust store的密钥需要被提供：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>ClientAuth(ClientAuth.REQUIRED).</div><div class="line">    <span class="built_in">set</span>TrustStoreOptions(</div><div class="line">        new JksOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.jks"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>或者你可以读取trust store到你自己的buffer中，然后直接提供：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="type">Buffer</span> myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.jks"</span>);</div><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setTrustStoreOptions</span>(</div><div class="line">        new <span class="type">JksOptions</span>().</div><div class="line">            <span class="title">setValue</span>(myTrustStoreAsABuffer).</div><div class="line">            <span class="title">setPassword</span>("password-of-your-truststore")</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的证书通常以<code>.pfx</code>或<code>.p12</code>结尾，也可以通过和JKS trust store类似的方式加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>ClientAuth(ClientAuth.REQUIRED).</div><div class="line">    <span class="built_in">set</span>PfxTrustOptions(</div><div class="line">        new PfxOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.pfx"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="type">Buffer</span> myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.pfx"</span>);</div><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setPfxTrustOptions</span>(</div><div class="line">        new <span class="type">PfxOptions</span>().</div><div class="line">            <span class="title">setValue</span>(myTrustStoreAsABuffer).</div><div class="line">            <span class="title">setPassword</span>("password-of-your-truststore")</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p>另一种方式提供服务器验证是使用一系列的<code>.pem</code>文件。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setPemTrustOptions</span>(</div><div class="line">        new <span class="type">PemTrustOptions</span>().</div><div class="line">            <span class="title">addCertPath</span>("/path/to/your/server-ca.pem")</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="type">Buffer</span> myCaAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-ca.pfx"</span>);</div><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setPemTrustOptions</span>(</div><div class="line">        new <span class="type">PemTrustOptions</span>().</div><div class="line">            <span class="title">addCertValue</span>(myCaAsABuffer)</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p><strong>客户端启用SSL/TLS</strong></p>
<p>网络客户端配置使用SSL是很简单的。使用SSL和使用标准的sockets又完全相同的API。</p>
<p>在NetClient上调用函数setSSL(true)就可以启用SSL了。</p>
<p><strong>客户端信任配置</strong></p>
<p>在客户端如果<code>trustALL</code>方法被设置为true，那么客户端将会信任所有的服务器证书。这个连接依旧会被加密，但是这种模式是脆弱的，因为有中间人攻击的存在，你不能确定你连接的是谁。用这个模式需要很小心。默认这个值是false。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().</div><div class="line">    setSsl(<span class="keyword">true</span>).</div><div class="line">    setTrustAll(<span class="keyword">true</span>);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>如果<code>trustAll</code>没有设置，那么客户端trust store就必须配置，并要包含客户端信任的服务器证书。</p>
<p>默认地，客户端主机验证被禁用了。为了启用主机验证，在你的客户端上需要设置算法（仅支持HTTPS和LDAPS）：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">        setSsl(true).</div><div class="line">        setHostnameVerificationAlgorithm(<span class="string">"HTTPS"</span>);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>和服务器配置一样，客户端trust也有几种配置的方案：</p>
<p>第一种方法是指定Java trust-store的位置，Java trust-store包含了证书权限。</p>
<p>这仅是标准的Java key store，和服务器端的key store是一样的。客户端trust store的位置可以通过<code>jks options</code>对象的<code>path</code>函数设置。如果一个服务器在连接的时候提供了一个证书，这个证书并不被客户端的trust store信任，那么这个连接将不会成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetClientOptions options = new NetClientOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>TrustStoreOptions(</div><div class="line">        new JksOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.jks"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetClient client = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myTrustStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.jks"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setTrustStoreOptions(</div><div class="line">        new JksOptions().</div><div class="line">            setValue(myTrustStoreAsABuffer).</div><div class="line">            setPassword(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的证书，通常是以<code>.pfx</code>和<code>.p12</code>结尾，也可以通过和JKS trust stores相似的方式加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetClientOptions options = new NetClientOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>PfxTrustOptions(</div><div class="line">        new PfxOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.pfx"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetClient client = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myTrustStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.pfx"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPfxTrustOptions(</div><div class="line">        new PfxOptions().</div><div class="line">            setValue(myTrustStoreAsABuffer).</div><div class="line">            setPassword(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>另一种提供服务器证书的方法是使用一个<code>.pem</code>文件的列表。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().</div><div class="line">    setSsl(<span class="keyword">true</span>).</div><div class="line">    setPemTrustOptions(</div><div class="line">        <span class="keyword">new</span> PemTrustOptions().</div><div class="line">            addCertPath(<span class="string">"/path/to/your/ca-cert.pem"</span>)</div><div class="line">    );</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myTrustStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/ca-cert.pem"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPemTrustOptions(</div><div class="line">        new PemTrustOptions().</div><div class="line">            addCertValue(myTrustStoreAsABuffer)</div><div class="line">    );</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p><strong>为客户端指定密钥和证书</strong></p>
<p>如果服务器端请求客户端验证，那么客户端必须在建立连接的时候给服务器提供自己的证书。客户端证书有下面几种配置方式：</p>
<p>第一种方法，通过指定包含了密钥和证书的Java key-store位置。这也是一个常规的Java key store。客户端keystore的位置也可以通过<code>jks options</code>的<code>path</code>方法设置。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setSsl(<span class="keyword">true</span>).setKeyStoreOptions(</div><div class="line">    <span class="keyword">new</span> JksOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/client-keystore.jks"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-keystore.jks"</span>);</div><div class="line"><span class="attribute">JksOptions jksOptions</span> = new JksOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setKeyStoreOptions(jksOptions);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的证书通常以<code>.pfx</code>或<code>.p12</code>结尾，也可以通过和JKS key store类似的方式加载：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setSsl(<span class="keyword">true</span>).setPfxKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PfxOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/client-keystore.pfx"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-keystore.pfx"</span>);</div><div class="line"><span class="attribute">PfxOptions pfxOptions</span> = new PfxOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPfxKeyCertOptions(pfxOptions);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>另一种提供分离的客户端私钥和证书的方式是使用<code>.pem</code>文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setSsl(<span class="keyword">true</span>).setPemKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PemKeyCertOptions().</div><div class="line">        setKeyPath(<span class="string">"/path/to/your/client-key.pem"</span>).</div><div class="line">        setCertPath(<span class="string">"/path/to/your/client-cert.pem"</span>)</div><div class="line">);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-key.pem"</span>);</div><div class="line"><span class="attribute">Buffer myCertAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-cert.pem"</span>);</div><div class="line"><span class="attribute">PemKeyCertOptions pemOptions</span> = new PemKeyCertOptions().</div><div class="line">    setKeyValue(myKeyAsABuffer).</div><div class="line">    setCertValue(myCertAsABuffer);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPemKeyCertOptions(pemOptions);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>记住在pem的配置中，私钥是没有被加密的。</p>
<p><strong>吊销证书</strong></p>
<p>信任是可以配置的，通过使用一个证书吊销列表（CRL）吊销的证书将不再被信任。使用<code>crlPath</code>配置crl的路径：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">NetClientOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetClientOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setTrustStoreOptions</span>(trustOptions).</div><div class="line">    <span class="title">addCrlPath</span>("/path/to/your/crl.pem");</div><div class="line"><span class="title">NetClient</span> <span class="title">client</span> = <span class="title">vertx</span>.<span class="title">createNetClient</span>(options);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myCrlAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/crl.pem"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setTrustStoreOptions(trustOptions).</div><div class="line">    addCrlValue(myCrlAsABuffer);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p><strong>配置加密套件</strong></p>
<p>默认地，TLS配置将会使在JVM里运行的Vert.x的加密套件。这个加密套件可以被配置启用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    addEnabledCipherSuite(<span class="string">"ECDHE-RSA-AES128-GCM-SHA256"</span>).</div><div class="line">    addEnabledCipherSuite(<span class="string">"ECDHE-ECDSA-AES128-GCM-SHA256"</span>).</div><div class="line">    addEnabledCipherSuite(<span class="string">"ECDHE-RSA-AES256-GCM-SHA384"</span>).</div><div class="line">    addEnabledCipherSuite(<span class="string">"CDHE-ECDSA-AES256-GCM-SHA384"</span>);</div><div class="line">NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>加密套件可以通过<code>NetServerOptions</code>和<code>NetClientOptions</code>配置。</p>
<p><strong>配置TLS协议版本</strong></p>
<p>默认地，TLS配置可以使用这些协议版本：SSLv2Hello，TLSv1，TLSv1.1，TLSv1.2。协议版本可以被明确的配置，增加可用协议：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    addEnabledSecureTransportProtocol(<span class="string">"TLSv1.1"</span>).</div><div class="line">    addEnabledSecureTransportProtocol(<span class="string">"TLSv1.2"</span>);</div><div class="line">    NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>协议版本可以通过<code>NetServerOptions</code>和<code>NetClientOptions</code>配置。</p>
<p><strong>SSL engine</strong></p>
<p>engine实现是可以被配置，用OpenSSL来代替JDK实现。OpenSSL比JDK engine提供了更好的实现和CPU使用率，以及与JDK版本独立性。</p>
<p>要使用的engine选项是</p>
<ul>
<li><code>getSslEngineOptions</code>选项当它被设置的时候</li>
<li>要不然<code>JdkSSLEngineOptions</code></li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = <span class="keyword">new</span> <span class="type">NetServerOptions</span>().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions);</div><div class="line"></div><div class="line"><span class="comment">// Use JDK SSL engine explicitly</span></div><div class="line">options = <span class="keyword">new</span> <span class="type">NetServerOptions</span>().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    setJdkSslEngineOptions(<span class="keyword">new</span> <span class="type">JdkSSLEngineOptions</span>());</div><div class="line"></div><div class="line"><span class="comment">// Use OpenSSL engine</span></div><div class="line">options = <span class="keyword">new</span> <span class="type">NetServerOptions</span>().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    setOpenSslEngineOptions(<span class="keyword">new</span> <span class="type">OpenSSLEngineOptions</span>());</div></pre></td></tr></table></figure>
<p><strong>应用层协议协商</strong></p>
<p>ALPN是TLS扩展的一部分，全称是应用层协议协商。它用在了HTTP/2：在TLS握手阶段客户端给出一个它支持的应用层协议列表，服务器告诉客户端它支持哪一个协议。</p>
<p>Java 8并不支持开箱即用的ALPN，所以ALPN应该通过其他的方式启用：</p>
<ul>
<li>OpenSSL支持</li>
<li>Jetty-ALPN支持</li>
</ul>
<p>要使用的engine选项是</p>
<ul>
<li><code>getSslEngineOptions</code>选项当设置的时候</li>
<li><code>JdkSSLEngineOptions</code>当ALPN可用于JDK时</li>
<li><code>OpenSSLEngineOptions</code>当ALPN可用于OpenSSL时</li>
</ul>
<p><strong>OpenSSL ALPN支持</strong></p>
<p>OpenSSL提供原生的ALPN支持。</p>
<p>OpenSSL需要配置<code>setOpenSslEngineOptions</code>和在classpath里使用<code>netty-tcnative</code>jar包。使用tcnnative可能需要OpenSSL已经安装在你的操作系统上，具体取决于实现。</p>
<p><strong>Jetty-ALPN</strong></p>
<p>Jetty-ALPN是一个小jar包覆盖了一些Java8发行版的类，以便于支持ALPN。</p>
<p>这个JVM必须在<code>bootclasspath</code>带有<em>alpn-boot-${version}.jar</em>启动：</p>
<pre><code>-Xbootclasspath/p:/path/to/alpn-boot${version}.jar
</code></pre><p>${version}依赖于JVM的版本。例如，8.1.7.v20160121用于OpenJDK1.8.0u74。完整的列表在Jetty-ALPN页面可看到。</p>
<p>这个主要的缺点就是以言语JVM的版本。</p>
<p>为了解决这个问题，可以使用Jetty ALPN agent替代。这个代理是一个JVM代理将会为JVM运行它时选择正确的ALPN版本：</p>
<pre><code>-javaagent:/path/to/plan/agent
</code></pre><h4 id="使用代理进行客户端连接"><a href="#使用代理进行客户端连接" class="headerlink" title="使用代理进行客户端连接"></a>使用代理进行客户端连接</h4><p><code>NetClient</code>支持HTTP/1.x、SOCKS4a或SOCKS5代理。</p>
<p>代理可以在<code>NetClientOptions</code>里配置，通过设置一个包含了代理类型、主机名、端口和可选的用户名和密码<code>ProxyOptions</code>对象。</p>
<p>下面是一个例子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NetClientOptions options = new NetClientOptions()</div><div class="line">    .<span class="built_in">set</span>ProxyOptions(new ProxyOptions().<span class="built_in">set</span>Type(ProxyType.SOCKS5)</div><div class="line">        .<span class="built_in">set</span>Host(<span class="string">"localhost"</span>).<span class="built_in">set</span>Port(<span class="number">1080</span>)</div><div class="line">        .<span class="built_in">set</span>Username(<span class="string">"username"</span>).<span class="built_in">set</span>Password(<span class="string">"secret"</span>));</div><div class="line">NetClient client = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>DNS解析总是在代理服务器上完成的，为了实现一个SOCKS4客户端代理的功能，它必须在本地解析DNS地址。</p>
<hr>
<h3 id="编写HTTP服务器和客户端"><a href="#编写HTTP服务器和客户端" class="headerlink" title="编写HTTP服务器和客户端"></a>编写HTTP服务器和客户端</h3><hr>
<p>Vert.x让你编写无阻塞的HTTP客户端和服务器是很简单的。</p>
<p>Vert.x支持HTTP/1.0、HTTP/1.1、HTTP/2协议。</p>
<p>HTTP基本的API和HTTP/1.x、HTTP/2是一样的，具体的API特性可用于处理HTTP/2协议。</p>
<h4 id="创建HTTP服务器"><a href="#创建HTTP服务器" class="headerlink" title="创建HTTP服务器"></a>创建HTTP服务器</h4><p>最简单的方式创建一个HTTP服务器，就是全是用默认的选项，像接下来这样：</p>
<pre><code>HttpServer server = vertx.createHttpServer();
</code></pre><h4 id="配置HTTP服务器"><a href="#配置HTTP服务器" class="headerlink" title="配置HTTP服务器"></a>配置HTTP服务器</h4><p>如果你不想要默认的配置，你可以在创建的时候通过传入<code>HttpServerOptions</code>实例来配置：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpServerOptions options</span> = new HttpServerOptions().setMaxWebsocketFrameSize(1000000);</div><div class="line"></div><div class="line"><span class="attribute">HttpServer server</span> = vertx.createHttpServer(options);</div></pre></td></tr></table></figure>
<h4 id="配置HTTP-2服务器"><a href="#配置HTTP-2服务器" class="headerlink" title="配置HTTP/2服务器"></a>配置HTTP/2服务器</h4><p>Vert.x支持HTTP/2 over TLS <code>h2</code>和TCP <code>h2c</code>。</p>
<ul>
<li><code>h2</code>标识通过ALPN在TLS上使用HTTP/2协议。</li>
<li><code>h2c</code>标识在TCP上使用明文HTTP/2协议，这种连接通过HTTP / 1.1升级请求或直接建立。</li>
</ul>
<p>为了处理<code>h2</code>请求，TLS必须通过<code>setUseAlpn</code>启用：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HttpServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> HttpServerOptions()</div><div class="line">    .setUseAlpn(<span class="keyword">true</span>)</div><div class="line">    .setSsl(<span class="keyword">true</span>)</div><div class="line">    .setKeyStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"/path/to/my/keystore"</span>));</div><div class="line"></div><div class="line">HttpServer server = vertx.createHttpServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>ALPN是TLS的延展部分，用于在客户端和服务器开始交换数据之前协商协议。</p>
<p>客户端不支持ALPN，依旧能够使用一个经典的SSL握手。</p>
<p>ALPN通常会协商<code>h2</code>协议，当然<code>Http/1.1</code>协议也可以被使用，如果服务器和客户端决定这样。</p>
<p>为了处理<code>h2c</code>请求，TLS必须禁用，服务器将会升级到HTTP/2，在任何请求HTTP/1.1想要升级到HTTP/2。它将会直接接受一个用<code>PRI * HTTP/2.0\r\nSM\r\n</code>开头的<code>h2c</code>连接。</p>
<blockquote>
<p>大多数浏览器不支持<code>h2c</code>，所以服务web网站是，你应该使用<code>h2</code>而不是<code>h2c</code>。</p>
</blockquote>
<p>当一个服务器接受一个HTTP/2连接，它发送它的<code>初始化设置</code>给客户端。这个设置定义了客户端怎么使用连接，默认的服务器初始化设置为：</p>
<ul>
<li><code>getMaxConcurrentStreams</code>：100是HTTP/2 RFC文档推荐的。</li>
<li>给其他的默认HTTP/2设置值</li>
</ul>
<h4 id="记录服务器网络活动"><a href="#记录服务器网络活动" class="headerlink" title="记录服务器网络活动"></a>记录服务器网络活动</h4><p>为了调试的目的，网络活动可以被记录。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpServerOptions options</span> = new HttpServerOptions().setLogActivity(true);</div><div class="line"></div><div class="line"><span class="attribute">HttpServer server</span> = vertx.createHttpServer(options);</div></pre></td></tr></table></figure>
<p>查看记录网络活动章节获取详细信息。</p>
<h4 id="请求到了后获取到通知"><a href="#请求到了后获取到通知" class="headerlink" title="请求到了后获取到通知"></a>请求到了后获取到通知</h4><p>要让服务器监听到达的请求，你可以使用一个<code>listen</code>方法。</p>
<p>要让服务器监听主机和端口，在选项中指定即可：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServer server = vertx.createHttpServer()<span class="comment">;</span></div><div class="line">server.listen()<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>或者在调用listen的时候指定主机和端口，从而覆盖选项中配置的：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServer <span class="keyword">server</span> = vertx.createHttpServer();</div><div class="line"><span class="keyword">server</span>.listen(<span class="number">8080</span>, <span class="string">"myhost.com"</span>);</div></pre></td></tr></table></figure>
<p>默认的主机是<code>0.0.0.0</code>，意味着监听所有可用的地址，并且默认的端口是80.</p>
<p>实际的绑定是异步的所以服务器可能没有实际绑定上，直到一段时间过后这个listen方法返回了。</p>
<p>如果你想要接收到通知，当服务器在实际监听的时候，你可以提供一个handler给<code>listen</code>调用。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HttpServer server = vertx.createHttpServer();</div><div class="line">server.<span class="built_in">listen</span>(<span class="number">8080</span>, <span class="string">"myhost.com"</span>, res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now listening!"</span>);</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Failed to bind!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="请求到达时获取到通知"><a href="#请求到达时获取到通知" class="headerlink" title="请求到达时获取到通知"></a>请求到达时获取到通知</h4><p>为了获取到通知当一个请求到达时，你需要设置一个<code>requestHandler</code>：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HttpServer <span class="keyword">server</span> = vertx.createHttpServer();</div><div class="line"><span class="keyword">server</span>.requestHandler(request -&gt; &#123;</div><div class="line">  <span class="comment">// Handle the request in here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>当一个请求到达时，这个请求handler被调用并传入一个<code>HttpServerRequest</code>实例。这个对象代表了服务器端的HTTP请求。</p>
<p>这个handler被调用，当请求头完全被读取的时候。</p>
<p>如果请求包含请求体，这个请求体将会在这个请求handler被调用一段时间后到达。</p>
<p>这个服务器请求对象允许你获取<code>uri</code>、<code>path</code>、<code>params</code>和<code>headers</code>，以及在里面的其他东西。</p>
<p>每个服务器请求对象都关联到了一个服务器回复对象。你使用<code>response</code>来获取一个<code>HttpServerResponse</code>对象的引用。</p>
<p>这有一个简单的例子，服务器处理一个请求并回复给它一个hello world。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.createHttpServer</span>()<span class="selector-class">.requestHandler</span>(request -&gt; &#123;</div><div class="line">  <span class="selector-tag">request</span><span class="selector-class">.response</span>()<span class="selector-class">.end</span>(<span class="string">"Hello world"</span>);</div><div class="line">&#125;)<span class="selector-class">.listen</span>(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p><strong>请求版本</strong></p>
<p>HTTP的版本可以在请求中用<code>version</code>获取到。</p>
<p><strong>请求方法</strong></p>
<p>使用<code>method</code>获取HTTP请求的方法。（例如：它可能是GET、POST、PUT、DELETE、HEAD、OPTION等）。</p>
<p><strong>请求URI</strong></p>
<p>使用<code>uri</code>从请求中获取URI。</p>
<p>注意，这是在HTTP请求中传递的实际URI，它几乎总是相对的URI。</p>
<p>URI是定义在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="external">5.1.2节 HTTP说明——请求URI</a></p>
<p><strong>请求路径</strong></p>
<p>使用<code>path</code>返回URI的路径部分。</p>
<p>例如，如果请求URI是这样：<code>a/b/c/page.html？param1=abc&amp;param2=xyz</code></p>
<p>然后这个路径将是<code>/a/b/c/page.html</code>。</p>
<p><strong>请求查询</strong></p>
<p>使用<code>query</code>方法返回URI的查询部分。</p>
<p>例如，如果请求URI是这样：<code>a/b/c/page.html？param1=abc&amp;param2=xyz</code></p>
<p>然后这个查询将是<code>param1=abc&amp;param2=xyz</code></p>
<p><strong>请求头</strong></p>
<p>使用<code>headers</code>方法返回HTTP请求的头。</p>
<p>这返回了一个<code>MultiMap</code>的实例，<code>MultiMap</code>就像是一个普通的Map或Hash，但是它允许多个值对应一个相同的键值，这是因为HTTP允许一个键值对应多个头值。</p>
<p>它有大小写不敏感的键值，意味着你可以像下面这样做：</p>
<pre><code>MultiMap headers = request.headers();

// Get the User-Agent:
System.out.println(&quot;User agent is &quot; + headers.get(&quot;user-agent&quot;));

// You can also do this and get the same result:
System.out.println(&quot;User agent is &quot; + headers.get(&quot;User-Agent&quot;));
</code></pre><p><strong>请求主机</strong></p>
<p>使用<code>host</code>方法返回HTTP请求的主机。</p>
<p>HTTP/1.1请求是返回主机头，HTTP/1请求是返回<code>:authority</code>伪头。</p>
<p><strong>请求参数</strong></p>
<p>使用<code>params</code>方法返回HTTP请求的参数。</p>
<p>就像<code>headers</code>方法返回一个<code>MultiMap</code>一样，这可能有多个参数对应一个相同的名字。</p>
<p>请求参数是在请求URI上发送的，在路径后面。例如，如果一个URI是这样的：</p>
<pre><code>/page.html?param1=abc&amp;param2=xyz
</code></pre><p>然后这个参数将包含下面这些：</p>
<pre><code>param1：‘abc’
param2: &apos;xyz&apos;
</code></pre><p>注意，这些请求的参数可以从请求URL里获取。如果你有一个表格属性，并且提交属于HTML表格的一部分到请求体中发送，这将是一个<code>multi-part/form-data</code>请求，他们将不会出现在这个参数这里。</p>
<p><strong>远程地址</strong></p>
<p>请求里的发送者地址可以用<code>remoteAddress</code>方法获取。</p>
<p><strong>绝对URI</strong></p>
<p>传入到一个HTTP请求里的URI通常都是相对的。如果你想要从请求中获取一个绝对的URI，你可以用<code>absoluteURI</code>方法得到。</p>
<p><strong>结束handler</strong></p>
<p>当请求完成的时候，请求的<code>endHandler</code>方法被调用，包括任何请求体都已经被完全读取。</p>
<p><strong>从请求体中读取数据</strong></p>
<p>通常的一个HTTP请求包含了我们要读取的请求体。就像前面提到的请求handler在请求头到达的时候就被调用了，所以这个请求对象在那时候并没有一个请求体。</p>
<p>这是因为请求体可能会很大（例如：一个上传的文件），并且我们通常并不想在调用处理之前缓存整个请求体到内存中，如果那样做，将会导致耗尽服务器的可用内存。</p>
<p>为了获取请求体，你可以在请求上调用<code>handler</code>，这将会在每次请求体的块到达时被调用。下面这是例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.handler(<span class="built_in">buffer</span> -&gt; &#123;</div><div class="line">	System.out.<span class="built_in">println</span>(<span class="string">"I have received a chunk of the body of length "</span> + <span class="built_in">buffer</span>.length);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>传入到handler里的是一个<code>Buffer</code>对象，并且这个handler可以被多次调用当数据从网络中到达时，依赖于请求体的大小。</p>
<p>在一些情景中（例如，请求体很小）你想要将整个请求体缓存到内存中，所以你自己可以像接下来这样获取到全部的请求体：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Buffer </span>totalBuffer = <span class="keyword">Buffer.buffer();</span></div><div class="line"></div><div class="line">request.handler(<span class="keyword">buffer </span>-&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"I have received a chunk of the body of length "</span> + <span class="keyword">buffer.length());</span></div><div class="line">	totalBuffer.appendBuffer(<span class="keyword">buffer);</span></div><div class="line">&#125;)<span class="comment">;</span></div><div class="line"></div><div class="line">request.endHandler(v -&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"Full body received, length = "</span> + totalBuffer.length())<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>这是一个很普遍的例子，所以Vert.x给你提供了一个<code>bodyHandler</code>来这样做。当全部的请求体接收到后，这个<code>bodyHandler</code>将会被调用一次：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.<span class="keyword">bodyHandler(totalBuffer </span>-&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"Full body received, length = "</span> + totalBuffer.length())</div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>导出请求</strong></p>
<p>请求对象是从一个<code>ReadStream</code>，所以你可以导出请求体到任何一个<code>WriteStream</code>实例。</p>
<p>查看章节<a href="">流和导出</a>获取更详细的解释。</p>
<p><strong>处理HTML表格</strong></p>
<p>HTML表格要么用<code>application/x-www-form-urlencoded</code>或者<code>multipart/form-data</code>内容类型来提交。</p>
<p>URL encode forms类型，表格属性在URL中被重新编码，就像普通的查询参数一样。</p>
<p>multi-partform类型，表格属性在请求体中被重新编码，因此，这些表格属性是不可用的直到请求体从电报中被完全的读取到。</p>
<p>Multi-part forms也可以包含文件上传。</p>
<p>如果你想要获取multi-part form的属性，你应该通过调用<code>setExcepMultipart</code>并设置为true来告诉Vert.x，在请求体被读取之前你期望获取到这样一个表格，然后一旦完整的请求体被读取完时，你应该使用<code>formAttributes</code>方法获取真实的属性。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">request</span>.requestHandler(request -&gt;</span> &#123;</div><div class="line">	request.setExcepMultipart(<span class="literal">true</span>);</div><div class="line">	<span class="function"><span class="title">request</span>.endHandler(v -&gt;</span> &#123;</div><div class="line">		<span class="comment">// The body has now been fully read, so retrieve the form attributes</span></div><div class="line">		MultiMap formAttributes = request.formAttributes();</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>处理文件上传</strong></p>
<p>Vert.x可以处理文件上传，在重新编码为一个multi-part的请求体里。</p>
<p>为了获取文件上传，你可以告诉Vert.x期望获取一个multi-part表格并且在请求上设置一个<code>uploadHandler</code>方法。</p>
<p>这个handler将会被调用一次，当所有的上传都到达服务器之后。</p>
<p>传入到这个handler里的对象是一个<code>HttpServerFileUpload</code>实例：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">server</span>.requestHandler(request -&gt;</span> &#123;</div><div class="line">	request.setExpectMultipart(<span class="literal">true</span>);</div><div class="line">	<span class="function"><span class="title">request</span>.uploadHandler(upload -&gt;</span> &#123;</div><div class="line">		System.out.println(<span class="string">"Got a file upload "</span> + upload.<span class="keyword">name</span>());</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>文件上传可能会很大，我们并不提供一个单一的buffer获取到完整的上传，因为那样做会导致耗尽内存，相反的，上传的数据是按块被接收的：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">request</span>.uploadHandler(upload -&gt;</span> &#123;</div><div class="line">	<span class="function"><span class="title">upload</span>.handler(chunk -&gt;</span> &#123;</div><div class="line">		System.out.println(<span class="string">"Received a chunk of the upload of length "</span> + chunk.length());</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上传对象是一个<code>ReadStream</code>，所以你可以导出请求体到任何<code>WriteStream</code>实例。查看章节<a href="">流和导出</a>获取更详细的内容。</p>
<p>如果你仅想要上传一个文件到磁盘的某个地方，你可以使用<code>streamToFileSystem</code>方法：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.uploadHandler(upload -&gt; &#123;</div><div class="line">	upload.streamToFileSystem(<span class="string">"myupload_directory/"</span> + upload.filename())<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>警告：确定你将在生成环境的系统上检查文件名，避免恶意的客户端上传文件到你文件系统的任意位置。查看<a href="">security notes</a>获取更多信息。</p>
</blockquote>
<p><strong>接收自定义HTTP/2帧</strong></p>
<p>HTTP/2是一个带有多个HTTP请求/回复模型的帧协议。这个协议允许大多数帧被发送和接收。</p>
<p>为了接收自定义帧，你可以是在请求上用<code>customFrameHandler</code>方法，这将会被调用在每次一个自定义帧到达时。下面这是例子：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">request</span>.customFrameHandler(frame -&gt; &#123;</div><div class="line"></div><div class="line">  <span class="type">System</span>.out.println(<span class="string">"Received a frame type="</span> + frame.<span class="keyword">type</span>() +</div><div class="line">      <span class="string">" payload"</span> + frame.payload().toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>HTTP/2帧并不受流控制——帧handler将会被马上调用当自定义帧到达的时候，无论请求是否停止。</p>
<p><strong>非标准HTTP方法</strong></p>
<p>这个<code>OTHER</code>的HTTP方法作为一个非标准方法使用，在这个例子中，<code>rawMethod</code>返回了客户端发送的HTTP方法。</p>
<h4 id="返回responses"><a href="#返回responses" class="headerlink" title="返回responses"></a>返回responses</h4><p>服务器返回的对象是<code>HttpServerResponse</code>的一个实例，是从具有响应的请求中获取的。</p>
<p>你可以使用响应对象把一个响应歇会给HTTP客户端。</p>
<p><strong>设置状态码和消息</strong></p>
<p>默认地HTTP状态码是返回200，代表OK。</p>
<p>使用<code>setStatusCode</code>设置一个不同的状态码。</p>
<p>你也可以用<code>setStatusMessage</code>指定一个自定义的状态信息。</p>
<p>如果你不指定状态信息，默认地与状态码相对于的信息会被返回。</p>
<blockquote>
<p>对于HTTP / 2，状态将不存在于响应中，因为协议将不向客户端发送消息</p>
</blockquote>
<p><strong>编写HTTP回复</strong></p>
<p>为了编写数据写回到HTTP回复中，你可以使用操作<code>write</code>。</p>
<p>在回复结束前可以被调用多次。这有几种调用的方式：</p>
<p>用单一的一个buffer：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(buffer);</div></pre></td></tr></table></figure>
<p>用一个字符串，在这个例子中，字符串将会用UTF-8重新编码，并将结果写到报文中。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(<span class="string">"hello world!"</span>);</div></pre></td></tr></table></figure>
<p>用一个带编码的字符串。在这个例子中，字符串将会使用特定的编码格式编码，并将结果写入到报文中。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(<span class="string">"hello world!"</span>, <span class="string">"UTF-16"</span>);</div></pre></td></tr></table></figure>
<p>编写一个响应是异步的，并总是立马返回在将写操作加入到队列中后。</p>
<p>如果你仅写一个单一的字符串或buffer到HTTP响应中，你可以在写完后在一个单一的调用中调用<code>end()</code>结束这个响应。</p>
<p>第一次调用write会将响应头中的结果写入响应。因此，如果你不使用HTTP分块，在写入响应前你必须设置<code>Content-Length</code>头，要不然就太晚了。如果你使用HTTP分块，你就不用担心了。</p>
<p><strong>结束HTTP响应</strong></p>
<p>一旦你完成了HTTP响应，你应该用<code>end</code>方法结束它。</p>
<p>这可以有好几种方式完成：</p>
<p>没有参数，这个响应只是简单的结束。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(<span class="string">"hello world!"</span>);</div><div class="line"><span class="built_in">response</span>.<span class="keyword">end</span>();</div></pre></td></tr></table></figure>
<p>这也可以用字符串或buffer调用，就和<code>write</code>方法一样。在这个情形下，这和用字符串或buffer调用写入函数并紧接着调用一个无参的结束方法是一样的。例如：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"hello world!"</span>);</div></pre></td></tr></table></figure>
<p><strong>关闭底层连接</strong></p>
<p>你可以使用<code>close</code>方法关闭这个底层的TCP连接。</p>
<p>没有keep-alive的连接将会被Vert.x自动关闭，当响应已经结束时。</p>
<p>Keep-alive连接默认的不会被Vert.x自动关闭。如果你想要关闭一个keep-alive连接在一段空闲时间之后，你可以配置<code>setIdleTimeout</code>。</p>
<p>HTTP/2连接在关闭响应之前会发送一个<code>GOAWAY</code>帧。</p>
<p><strong>设置响应头</strong></p>
<p>HTTP响应头可以用<code>headers</code>直接添加到响应中：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse response = request.response()<span class="comment">;</span></div><div class="line"><span class="keyword">MultiMap </span>headers = response.headers()<span class="comment">;</span></div><div class="line">headers<span class="meta">.set</span>(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)<span class="comment">;</span></div><div class="line">headers<span class="meta">.set</span>(<span class="string">"other-header"</span>, <span class="string">"wibble"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>或者你可以是用<code>putHeader</code></p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>).putHeader(<span class="string">"other-header"</span>, <span class="string">"wibble"</span>);</div></pre></td></tr></table></figure>
<p>响应头必须全部添加在任何部分的响应体被写入之前。</p>
<p><strong>分块的HTTP响应和trailers</strong></p>
<p>Vert.x支持HTTP分块传输编码。</p>
<p>这允许HTTP响应主体以块形式写入，并且通常在大的响应主体被流式传输到客户端并且总大小不是预先知道时使用。</p>
<p>设置HTTP响应为分块模式，像下面这样：</p>
<pre><code>HttpServerResponse response = request.response();
response.setChunked(true);
</code></pre><p>默认是不分块的。当在分块模式下，每次调用一个<code>write</code>方法将会产生一个新的HTTP分块被写入。</p>
<p>当在一个分块模式下，你也可以写一个HTTP响应trailers到响应中。这些实际上写入到了响应的最后一个分块。</p>
<blockquote>
<p>注意：分块的响应对HTTP/2流是没有效果的。</p>
</blockquote>
<p>为了在响应中添加一个trailers，把他们直接加入到<code>trailers</code>。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.setChunked(<span class="literal">true</span>);</div><div class="line">MultiMap trailers = <span class="built_in">response</span>.trailers();</div><div class="line">trailers.<span class="keyword">set</span>(<span class="string">"X-wibble"</span>, <span class="string">"woobble"</span>).<span class="keyword">set</span>(<span class="string">"X-quux"</span>, <span class="string">"flooble"</span>);</div></pre></td></tr></table></figure>
<p>或者使用<code>putTrailer</code></p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.setChunked(<span class="literal">true</span>);</div><div class="line"><span class="built_in">response</span>.putTrailer(<span class="string">"X-wibble"</span>, <span class="string">"woobble"</span>).putTrailer(<span class="string">"X-quux"</span>, <span class="string">"flooble"</span>);</div></pre></td></tr></table></figure>
<p><strong>直接从磁盘或类路径提供文件</strong></p>
<p>如果你想要写一个web服务器，一种方式是从磁盘提供文件，将会用<code>AsyncFile</code>打开它并且导入到HTTP响应。</p>
<p>否则你可以使用<code>readFile</code>加载它并直接将它写入到响应中。</p>
<p>或者，Vert.x提供了一个方法在一个操作中允许直接从磁盘或文件系统提供一个文件给一个HTTP响应。在底层操作系统支持的情况下，这可能导致OS直接将字节从文件传输到socket，而根本不通过用户空间被复制。</p>
<p>这个通过使用<code>sendFile</code>完成，并且对大文件来说都很有效，但是可能会导致小文件变慢。</p>
<p>这是一个很简单的web服务器，它使用sendFile从文件系统中提供文件：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(<span class="built_in">request</span> -&gt; &#123;</div><div class="line">  <span class="built_in">String</span> file = <span class="string">""</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">request</span>.path().equals(<span class="string">"/"</span>)) &#123;</div><div class="line">    file = <span class="string">"index.html"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">request</span>.path().contains(<span class="string">".."</span>)) &#123;</div><div class="line">    file = <span class="built_in">request</span>.path();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">request</span>.<span class="built_in">response</span>().sendFile(<span class="string">"web/"</span> + file);</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p>发送一个文件是异步的并且可能没有完成直到一段时间后这个调用已经返回了。如果你想要收到通知，当文件被写入的时候，你可以使用<code>sendFile</code>。</p>
<p>请看这个章节关于<a href="">从类路径提供文件</a>获取关于类路径的限制。</p>
<blockquote>
<p>注意：当你在HTTPS下使用<code>sendFile</code>，它将会复制到用户控件，因为如果直接从内核直接从磁盘拷贝数据到socket里，它不会给我们使用任何加密的机会。<br>警告：如果你想要用Vert.x直接编写web服务器。如果要使用Vert.x直接编写Web服务器，请注意用户不能利用路径访问要从中提供服务的目录或类路径之外的文件。使用Vert.x Web可能更安全。</p>
</blockquote>
<p>当需要只服务一个文件的一段，从一个给定的字节开始，你可以做到这一点：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(request -&gt; &#123;</div><div class="line">  <span class="keyword">long</span> offset = <span class="number">0</span>;</div><div class="line">  <span class="built_in">try</span> &#123;</div><div class="line">    offset = Long.parseLong(request.getParam(<span class="string">"start"</span>));</div><div class="line">  &#125; <span class="built_in">catch</span> (NumberFormatException e) &#123;</div><div class="line">    <span class="comment">// error handling...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> <span class="built_in">end</span> = Long.MAX_VALUE;</div><div class="line">  <span class="built_in">try</span> &#123;</div><div class="line">    <span class="built_in">end</span> = Long.parseLong(request.getParam(<span class="string">"end"</span>));</div><div class="line">  &#125; <span class="built_in">catch</span> (NumberFormatException e) &#123;</div><div class="line">    <span class="comment">// error handling...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  request.response().sendFile(<span class="string">"web/mybigfile.txt"</span>, offset, <span class="built_in">end</span>);</div><div class="line">&#125;).<span class="built_in">listen</span>(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p>如果要从偏移量开始发送文件直到结束，您不需要提供长度，在这种情况下，您可以执行以下操作：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(request -&gt; &#123;</div><div class="line">  <span class="keyword">long</span> offset = <span class="number">0</span>;</div><div class="line">  <span class="built_in">try</span> &#123;</div><div class="line">    offset = Long.parseLong(request.getParam(<span class="string">"start"</span>));</div><div class="line">  &#125; <span class="built_in">catch</span> (NumberFormatException e) &#123;</div><div class="line">    <span class="comment">// error handling...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  request.response().sendFile(<span class="string">"web/mybigfile.txt"</span>, offset);</div><div class="line">&#125;).<span class="built_in">listen</span>(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p><strong>导出响应</strong></p>
<p>服务器响应是<code>WriteStream</code>一个实例，所以你可以从任一的<code>ReadStream</code>导出它。例如：<code>AsyncFile</code>、<code>NetSocket</code>、<code>WebSocket</code>或<code>HttpServerRequest</code>。</p>
<p>这是一个例子，对任一的PUT方法都在响应中回显请求体。它对请求体进行导出，因此，它将会在任何情况下都会工作，即使HTTP请求体比能够适应的内存大的多的时候：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(<span class="built_in">request</span> -&gt; &#123;</div><div class="line">  HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">request</span>.method() == HttpMethod.PUT) &#123;</div><div class="line">    <span class="built_in">response</span>.setChunked(<span class="literal">true</span>);</div><div class="line">    Pump.pump(<span class="built_in">request</span>, <span class="built_in">response</span>).start();</div><div class="line">    <span class="built_in">request</span>.endHandler(v -&gt; <span class="built_in">response</span>.<span class="keyword">end</span>());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">response</span>.setStatusCode(<span class="number">400</span>).<span class="keyword">end</span>();</div><div class="line">  &#125;</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p><strong>编写HTTP/2帧</strong></p>
<p>HTTP/2是具有用于HTTP请求/响应模型大量的帧的帧协议。这个协议允许其他大量的帧被发送和接收。</p>
<p>为了发送这些真，你可以在响应里使用<code>writeCustomFrame</code>方法。这是一个例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> frameType = <span class="number">40</span>；</div><div class="line"><span class="keyword">int</span> frameStatus = <span class="number">10</span>;</div><div class="line"></div><div class="line">Buffer payload = Buffer.<span class="built_in">buffer</span>(<span class="string">"some data"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Sending a frame to the client</span></div><div class="line">response.writeCustomFrame(frameType, frameStatus, payload);</div></pre></td></tr></table></figure>
<p>这些帧会马上被发送并且不受流表控制。当这些帧被发送了，它可能将会在其他<code>DATA</code>帧之前完成。</p>
<p><strong>流重置</strong></p>
<p>HTTP/1.x并不允许一个干净的请求流或响应流重置。例如，当一个客户端上传一个服务器已经存在的资源时，这个服务器需要接受这个完整的响应。</p>
<p>HTTP/2支持在请求/响应的任何时间流重置：</p>
<pre><code>request.response().reset();
</code></pre><p>默认地一个<code>NO_ERROR</code>(0)的错误码会被发送，要用另一个错误码代替发送可以这样：</p>
<pre><code>request.response().reset(8);
</code></pre><p>HTTP/2指定定义了一系列的<a href="">错误码</a>可用。</p>
<p>流重置事件使用<code>request handler</code>和<code>response handler</code>，这个请求处理器会被通知：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">request</span>.<span class="built_in">response</span>().exceptionHandler(<span class="built_in">err</span> -&gt; &#123;</div><div class="line">	<span class="keyword">if</span> (<span class="built_in">err</span> instanceof StreamResetException) &#123;</div><div class="line">		StreamResetException reset = (StreamResetException) <span class="built_in">err</span>;</div><div class="line">		System.out.println(<span class="string">"Stream reset "</span> + reset.getCode());</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>服务器推送</strong></p>
<p>服务器推送是HTTP/2的一个新特性，可以为一个单一的客户端请求，平行的发送多个响应。</p>
<p>当服务器处理一个请求时，它可以推送一个请求/响应到客户端：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse response = request.response();</div><div class="line"></div><div class="line"><span class="comment">// Push main.js to the client</span></div><div class="line">response.push(HttpMethod.GET, <span class="string">"/main.js"</span>, ar -&gt; &#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// The server is ready to push the response</span></div><div class="line">    HttpServerResponse pushedResponse = ar.result();</div><div class="line"></div><div class="line">    <span class="comment">// Send main.js response</span></div><div class="line">    pushedResponse.</div><div class="line">        putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>).</div><div class="line">        end(<span class="string">"alert(\"</span>Push response hello\<span class="string">")"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Could not push client resource "</span> + ar.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Send the requested resource</span></div><div class="line">response.sendFile(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;script src=\"</span>/main.js\<span class="string">"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"</span>);</div></pre></td></tr></table></figure>
<p>当这个服务器准备好推送响应是，推送响应的handler被调用并且这个handler可以发送响应。</p>
<p>这个推送响应的handler可能接受一个失败，例如客户端可能取消推送因为它在缓存中已经有<code>main.js</code>并且不再需要了。</p>
<p>这个<code>push</code>方法必须被调用在初始化响应结束之前，然而推送的响应可以在之后被重写。</p>
<h4 id="HTTP压缩"><a href="#HTTP压缩" class="headerlink" title="HTTP压缩"></a>HTTP压缩</h4><h4 id="创建HTTP客户端"><a href="#创建HTTP客户端" class="headerlink" title="创建HTTP客户端"></a>创建HTTP客户端</h4><h4 id="记录客户端网络活动"><a href="#记录客户端网络活动" class="headerlink" title="记录客户端网络活动"></a>记录客户端网络活动</h4><h4 id="发出请求"><a href="#发出请求" class="headerlink" title="发出请求"></a>发出请求</h4><h4 id="处理http-response"><a href="#处理http-response" class="headerlink" title="处理http response"></a>处理http response</h4><h4 id="允许客户端压缩"><a href="#允许客户端压缩" class="headerlink" title="允许客户端压缩"></a>允许客户端压缩</h4><h4 id="HTTP-1-x池和keep-alive"><a href="#HTTP-1-x池和keep-alive" class="headerlink" title="HTTP/1.x池和keep alive"></a>HTTP/1.x池和keep alive</h4><h4 id="HTTP-1-1-pipe-lining"><a href="#HTTP-1-1-pipe-lining" class="headerlink" title="HTTP/1.1 pipe-lining"></a>HTTP/1.1 pipe-lining</h4><h4 id="HTTP-2-multiplexing"><a href="#HTTP-2-multiplexing" class="headerlink" title="HTTP/2 multiplexing"></a>HTTP/2 multiplexing</h4><h4 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h4><h4 id="HTTPClient用法"><a href="#HTTPClient用法" class="headerlink" title="HTTPClient用法"></a>HTTPClient用法</h4><h4 id="服务器分享"><a href="#服务器分享" class="headerlink" title="服务器分享"></a>服务器分享</h4><h4 id="通过Vert-x使用HTTPS"><a href="#通过Vert-x使用HTTPS" class="headerlink" title="通过Vert.x使用HTTPS"></a>通过Vert.x使用HTTPS</h4><h4 id="websockets"><a href="#websockets" class="headerlink" title="websockets"></a>websockets</h4><h4 id="为HTTP-HTTPS连接使用代理"><a href="#为HTTP-HTTPS连接使用代理" class="headerlink" title="为HTTP/HTTPS连接使用代理"></a>为HTTP/HTTPS连接使用代理</h4><h4 id="在verticles里自动清除-1"><a href="#在verticles里自动清除-1" class="headerlink" title="在verticles里自动清除"></a>在verticles里自动清除</h4><hr>
<h3 id="在Vert-x里使用Shared-Data"><a href="#在Vert-x里使用Shared-Data" class="headerlink" title="在Vert.x里使用Shared Data"></a>在Vert.x里使用Shared Data</h3><hr>
<h4 id="Local-shared-maps"><a href="#Local-shared-maps" class="headerlink" title="Local shared maps"></a>Local shared maps</h4><h4 id="Cluster-wide-asynchronous-maps"><a href="#Cluster-wide-asynchronous-maps" class="headerlink" title="Cluster-wide asynchronous maps"></a>Cluster-wide asynchronous maps</h4><h4 id="Cluster-wide-locks"><a href="#Cluster-wide-locks" class="headerlink" title="Cluster-wide locks"></a>Cluster-wide locks</h4><h4 id="Cluster-wide-counters"><a href="#Cluster-wide-counters" class="headerlink" title="Cluster-wide counters"></a>Cluster-wide counters</h4><hr>
<h3 id="通过Vert-x使用文件系统"><a href="#通过Vert-x使用文件系统" class="headerlink" title="通过Vert.x使用文件系统"></a>通过Vert.x使用文件系统</h3><hr>
<h4 id="异步文件"><a href="#异步文件" class="headerlink" title="异步文件"></a>异步文件</h4><hr>
<h3 id="数据报socket（UDP）"><a href="#数据报socket（UDP）" class="headerlink" title="数据报socket（UDP）"></a>数据报socket（UDP）</h3><hr>
<h4 id="创建一个DatagramSocket"><a href="#创建一个DatagramSocket" class="headerlink" title="创建一个DatagramSocket"></a>创建一个DatagramSocket</h4><h4 id="发送一个Datagram-packets"><a href="#发送一个Datagram-packets" class="headerlink" title="发送一个Datagram packets"></a>发送一个Datagram packets</h4><h4 id="接收一个Datagram-packets"><a href="#接收一个Datagram-packets" class="headerlink" title="接收一个Datagram packets"></a>接收一个Datagram packets</h4><h4 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h4><hr>
<h3 id="DNS客户端"><a href="#DNS客户端" class="headerlink" title="DNS客户端"></a>DNS客户端</h3><hr>
<h4 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h4><h4 id="lookup4"><a href="#lookup4" class="headerlink" title="lookup4"></a>lookup4</h4><h4 id="lookup6"><a href="#lookup6" class="headerlink" title="lookup6"></a>lookup6</h4><h4 id="resolveA"><a href="#resolveA" class="headerlink" title="resolveA"></a>resolveA</h4><h4 id="resolveAAAA"><a href="#resolveAAAA" class="headerlink" title="resolveAAAA"></a>resolveAAAA</h4><h4 id="resolveCNAME"><a href="#resolveCNAME" class="headerlink" title="resolveCNAME"></a>resolveCNAME</h4><h4 id="resolveMX"><a href="#resolveMX" class="headerlink" title="resolveMX"></a>resolveMX</h4><h4 id="resolveTXT"><a href="#resolveTXT" class="headerlink" title="resolveTXT"></a>resolveTXT</h4><h4 id="resolveNS"><a href="#resolveNS" class="headerlink" title="resolveNS"></a>resolveNS</h4><h4 id="resolveSRV"><a href="#resolveSRV" class="headerlink" title="resolveSRV"></a>resolveSRV</h4><h4 id="resolvePTR"><a href="#resolvePTR" class="headerlink" title="resolvePTR"></a>resolvePTR</h4><h4 id="reverseLookup"><a href="#reverseLookup" class="headerlink" title="reverseLookup"></a>reverseLookup</h4><h4 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h4><hr>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><hr>
<h4 id="ReadStream"><a href="#ReadStream" class="headerlink" title="ReadStream"></a>ReadStream</h4><h4 id="WriteStream"><a href="#WriteStream" class="headerlink" title="WriteStream"></a>WriteStream</h4><h4 id="Pump"><a href="#Pump" class="headerlink" title="Pump"></a>Pump</h4><hr>
<h3 id="记录解析"><a href="#记录解析" class="headerlink" title="记录解析"></a>记录解析</h3><hr>
<hr>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><hr>
<hr>
<h3 id="Metrics-SPI"><a href="#Metrics-SPI" class="headerlink" title="Metrics SPI"></a>Metrics SPI</h3><hr>
<hr>
<h3 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a>OSGi</h3><hr>
<hr>
<h3 id="vertx命令行"><a href="#vertx命令行" class="headerlink" title="vertx命令行"></a>vertx命令行</h3><hr>
<h4 id="运行verticles"><a href="#运行verticles" class="headerlink" title="运行verticles"></a>运行verticles</h4><h4 id="将一个Vert-x应用打包为一个jar包执行"><a href="#将一个Vert-x应用打包为一个jar包执行" class="headerlink" title="将一个Vert.x应用打包为一个jar包执行"></a>将一个Vert.x应用打包为一个jar包执行</h4><h4 id="显示Vert-x版本"><a href="#显示Vert-x版本" class="headerlink" title="显示Vert.x版本"></a>显示Vert.x版本</h4><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><h4 id="Live-Redeploy"><a href="#Live-Redeploy" class="headerlink" title="Live Redeploy"></a>Live Redeploy</h4><hr>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><hr>
<hr>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><hr>
<h4 id="配置JUL日志"><a href="#配置JUL日志" class="headerlink" title="配置JUL日志"></a>配置JUL日志</h4><h4 id="使用另一个日志框架"><a href="#使用另一个日志框架" class="headerlink" title="使用另一个日志框架"></a>使用另一个日志框架</h4><h4 id="记录你的应用"><a href="#记录你的应用" class="headerlink" title="记录你的应用"></a>记录你的应用</h4><hr>
<h3 id="主机名解决方案"><a href="#主机名解决方案" class="headerlink" title="主机名解决方案"></a>主机名解决方案</h3><hr>
<hr>
<h3 id="高可用和fail-over"><a href="#高可用和fail-over" class="headerlink" title="高可用和fail-over"></a>高可用和fail-over</h3><hr>
<h4 id="自动failover"><a href="#自动failover" class="headerlink" title="自动failover"></a>自动failover</h4><h4 id="HA组"><a href="#HA组" class="headerlink" title="HA组"></a>HA组</h4><h4 id="处理网络部分-Quora"><a href="#处理网络部分-Quora" class="headerlink" title="处理网络部分-Quora"></a>处理网络部分-Quora</h4><hr>
<h3 id="安全记录"><a href="#安全记录" class="headerlink" title="安全记录"></a>安全记录</h3><hr>
<h4 id="web应用"><a href="#web应用" class="headerlink" title="web应用"></a>web应用</h4><h4 id="集群event-bus交通"><a href="#集群event-bus交通" class="headerlink" title="集群event bus交通"></a>集群event bus交通</h4><h4 id="标准安全的最佳实践"><a href="#标准安全的最佳实践" class="headerlink" title="标准安全的最佳实践"></a>标准安全的最佳实践</h4><hr>
<h3 id="Vert-x命令行接口API"><a href="#Vert-x命令行接口API" class="headerlink" title="Vert.x命令行接口API"></a>Vert.x命令行接口API</h3><hr>
<h4 id="定义舞台"><a href="#定义舞台" class="headerlink" title="定义舞台"></a>定义舞台</h4><h4 id="解析舞台"><a href="#解析舞台" class="headerlink" title="解析舞台"></a>解析舞台</h4><h4 id="查询-审计舞台"><a href="#查询-审计舞台" class="headerlink" title="查询/审计舞台"></a>查询/审计舞台</h4><h4 id="类型选项和参数"><a href="#类型选项和参数" class="headerlink" title="类型选项和参数"></a>类型选项和参数</h4><h4 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h4><hr>
<h3 id="Vert-x启动器"><a href="#Vert-x启动器" class="headerlink" title="Vert.x启动器"></a>Vert.x启动器</h3><hr>
<h4 id="拓展vert-x启动器"><a href="#拓展vert-x启动器" class="headerlink" title="拓展vert.x启动器"></a>拓展vert.x启动器</h4><h4 id="在jar里使用启动器"><a href="#在jar里使用启动器" class="headerlink" title="在jar里使用启动器"></a>在jar里使用启动器</h4><h4 id="启动子类"><a href="#启动子类" class="headerlink" title="启动子类"></a>启动子类</h4><h4 id="启动器退出代码"><a href="#启动器退出代码" class="headerlink" title="启动器退出代码"></a>启动器退出代码</h4><hr>
<h3 id="配置Vert-x缓存"><a href="#配置Vert-x缓存" class="headerlink" title="配置Vert.x缓存"></a>配置Vert.x缓存</h3><hr>
]]></content>
    
    <summary type="html">
    
      翻译初衷是为了自己更好的学习和理解Vert.x，网上也有不少的已经翻译完成的，各位可以去搜索完成的版本查阅，英语好的可以直接看英文文档。计划先完成Vert.x core与Vert.x web的翻译，待初稿完成后，会校对自己的翻译。若各位等待，看我的翻译，我谨在此表示感谢。同时，我也预先声明，本人限于水平，翻译难免会有错漏之处，请各位看官见谅。其次，翻译基本上都是抽出自己的业余时间完成，难免会比较慢，请再次见谅。
    
    </summary>
    
      <category term="vertx" scheme="http://weiyiysw.com/categories/vertx/"/>
    
    
      <category term="vertx-core" scheme="http://weiyiysw.com/tags/vertx-core/"/>
    
  </entry>
  
</feed>
