<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[zsh下执行Java命令的解决方法]]></title>
      <url>http://weiyiysw.com/2017/08/30/zsh%E4%B8%8B%E6%89%A7%E8%A1%8CJava%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="问题1：java-classpath"><a href="#问题1：java-classpath" class="headerlink" title="问题1：java -classpath"></a>问题1：java -classpath</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>最近学习jooq，并按照其说明文档，学习第一个实例时，需要在命令行执行java命令生成代码。该命令如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -classpath jooq-<span class="number">3.9</span>.<span class="number">5</span><span class="selector-class">.jar</span>:jooq-codegen-<span class="number">3.9</span>.<span class="number">5</span><span class="selector-class">.jar</span>:jooq-meta-<span class="number">3.9</span>.<span class="number">5</span><span class="selector-class">.jar</span>:mysql-connector-java-<span class="number">6.0</span>.<span class="number">6</span><span class="selector-class">.jar</span>:. org<span class="selector-class">.jooq</span><span class="selector-class">.util</span><span class="selector-class">.GenerationTool</span> library.xml</div></pre></td></tr></table></figure>
<p>我在终端下，执行总是失败、报class not found的异常。想了半天、查了些资料，毫无头绪。后来灵光一闪，是不是因为我的终端环境问题呢？Linux或Mac默认的shell是使用的bash shell，而我将默认的shell修改为了zsh。</p>
<p>于是我在终端，输入<code>/bin/bash</code>切换到bash shell，然后执行上述命令，成功了！！！终于找到了问题所在了。</p>
<h2 id="zsh下该如何执行呢？"><a href="#zsh下该如何执行呢？" class="headerlink" title="zsh下该如何执行呢？"></a>zsh下该如何执行呢？</h2><p>查阅资料，发现如下解决方法</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -classpath “jooq-<span class="number">3.9</span>.<span class="number">5</span><span class="selector-class">.jar</span>:jooq-codegen-<span class="number">3.9</span>.<span class="number">5</span><span class="selector-class">.jar</span>:jooq-meta-<span class="number">3.9</span>.<span class="number">5</span><span class="selector-class">.jar</span>:mysql-connector-java-<span class="number">6.0</span>.<span class="number">6</span><span class="selector-class">.jar</span>:.” org<span class="selector-class">.jooq</span><span class="selector-class">.util</span><span class="selector-class">.GenerationTool</span> library.xml</div></pre></td></tr></table></figure>
<p>将jar包放到双引号（英文）内，然后在zsh下执行，成功解决该问题。</p>
<p>这是两个shell之间的区别，至于深层次的原因，暂时还未深入研究。等闲暇下来，在好好学习下，并记录。</p>
<h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>待补充~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vertx-Java开发者预览指南]]></title>
      <url>http://weiyiysw.com/2017/08/23/Vertx-Java%E5%BC%80%E5%8F%91%E8%80%85%E9%A2%84%E8%A7%88%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h1 id="Vertx-Java开发者预览指南"><a href="#Vertx-Java开发者预览指南" class="headerlink" title="Vertx Java开发者预览指南"></a>Vertx Java开发者预览指南</h1><blockquote>
<p>作者：<a href="http://github.com/jponge" target="_blank" rel="external">jponge</a><br>日期：2017.06.09<br>翻译日期：2017.08.23<br>翻译：weiyiysw</p>
</blockquote>
<p>上个秋天，我没能参加最后的Eclipse Vert.x社区面对面会议，但有一个议题目的是为特定类型的开发者提供手册。这也是我的任务，在我加入这个团队并开始工作后。我很乐意在今天分享给大家。</p>
<h1 id="企业应用开发者使用Eclipse-Vert-x异步编程的优雅指南"><a href="#企业应用开发者使用Eclipse-Vert-x异步编程的优雅指南" class="headerlink" title="企业应用开发者使用Eclipse Vert.x异步编程的优雅指南"></a>企业应用开发者使用Eclipse Vert.x异步编程的优雅指南</h1><p>这篇手册命名为<strong>“企业应用开发者使用Eclipse Vert.x异步编程的优雅指南”</strong>，它介绍了Vert.x的异步编程，主要面向熟悉主流的同步web开发框架和库的开发者（如：Java EE, Spring）。</p>
<p>引用介绍：</p>
<p>我们将从使用了关系型数据库和服务端渲染页面的WIKI后台web应用开始；我们将通过多个步骤逐步的开发应用直到它变成一个现代的单一页面应用并具有实时的web特性。通过这个方式，你将会学习到：</p>
<ol>
<li>通过模板设计一个服务端渲染页面的web应用，并使用关系型数据库存储数据。</li>
<li>干净的隔离每个技术组件作为可重用的事件处理单元，被称为verticle。</li>
<li>提取vert.x服务，使设计的verticles在同一个JVM进程内或群集中的分布式节点之间无缝通信。</li>
<li>测试异步操作代码。</li>
<li>与提供HTTP/JSON的web API的第三方服务集成。</li>
<li>提供HTTP/JSON的web API。</li>
<li>使用HTTPS实现安全访问控制，用于Web浏览器会话的用户身份验证和用于第三方客户端应用程序的JWT令牌。</li>
<li>重构一些代码以使用反应式编程与流行的RxJava库及其Vert.x集成。</li>
<li>使用AngularJS完成单一页面应用的客户端侧编程。</li>
<li>在集成sockjs之上使用统一的vert.x event bus实现实时编程。</li>
</ol>
<p>该指南采取渐进的方法，从“快速和肮脏”的解决方案开始，然后正确地重构，暴露了核心的Vert.x概念，添加功能，并从回调转移到RxJava。</p>
<h1 id="我们需要你的反馈"><a href="#我们需要你的反馈" class="headerlink" title="我们需要你的反馈"></a>我们需要你的反馈</h1><p>代码在<a href="https://github.com/vert-x3/vertx-guide-for-java-devs" target="_blank" rel="external">https://github.com/vert-x3/vertx-guide-for-java-devs</a>上是可用的。你可以在Github的该仓库的issues提供反馈甚至提供提交请求。</p>
<p>你可以从GitHub上检出代码（AsciiDoc从仓库接口上渲染的很好）或你可以查看我暂时分享预渲染HTML和PDF版本，并从我的Dropbox中保持最新状态：<a href="https://www.dropbox.com/sh/ni9znfkzlkl3q12/AABn-OCi1CZfgbTzOU0jYQpJa?dl=0" target="_blank" rel="external">https://www.dropbox.com/sh/ni9znfkzlkl3q12/AABn-OCi1CZfgbTzOU0jYQpJa?dl=0</a></p>
<p>非常感谢Thomas Segismont和Julien Viet，他们贡献了一些部分内容，还有私下校对的人们。</p>
<p>照常，我们欢迎您提供反馈！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[design-pattern]]></title>
      <url>http://weiyiysw.com/2017/08/19/design-pattern/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="https://quanke.gitbooks.io/design-pattern-java" target="_blank" rel="external">https://quanke.gitbooks.io/design-pattern-java</a></p>
</blockquote>
<h1 id="设计模式学习记录1"><a href="#设计模式学习记录1" class="headerlink" title="设计模式学习记录1"></a>设计模式学习记录1</h1><p>在工作开发的过程中，总是能看到很多地方用到了设计模式。好的设计模式能够让我们事半功倍。前人的基础上总结了许多好的设计模式，现在系统的学习并记录。</p>
<h1 id="面向对象的设计模式原则"><a href="#面向对象的设计模式原则" class="headerlink" title="面向对象的设计模式原则"></a>面向对象的设计模式原则</h1><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><p>这个很好理解。控制每个类的粒度，每个类只做该做的，便于提高代码的复用性。</p>
<p>单一职责原则，目的是实现高内聚、低耦合。</p>
<p>学会给类减负。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则由Bertrand Meyer于1988年提出，其定义如下：<br>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
<p>开闭原则，通俗的说就是对扩展开放，对修改关闭。</p>
<p>在Java的世界里，扩展即可通过接口或抽象类。需要对事物高度抽象化。这样，如果需要修改系统的行为，就无需对抽象层做任何改动，只需要增加新的具体类来实现新的业务功能即可。</p>
<p>例如：一个接口名为水果，具有一个抽象方法吃。现在系统有继承该接口的两个类，苹果和香蕉。当我们想吃其他水果的时候，只需要继承水果这个接口。如，想吃桃，实现名为桃的类，继承该接口即可。</p>
<h2 id="里氏代换"><a href="#里氏代换" class="headerlink" title="里氏代换"></a>里氏代换</h2><p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士Barbara Liskov教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。其严格表述如下：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个定义很拗口且难以理解，通俗定义： 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
<p>里氏代换原则需要注意：</p>
<p>子类中的方法应该都在父类中有声明。否则，该方法无法在以父类定义的对象使用。</p>
<p>设计上，一般将父类设计为基类或接口。</p>
<p>Java在编译时，会检查一个程序是否符合里氏代换原则，但检查是有局限的。</p>
<h2 id="依赖倒转"><a href="#依赖倒转" class="headerlink" title="依赖倒转"></a>依赖倒转</h2><p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则是Robert C. Martin在1996年为“C++Reporter”所写的专栏Engineering Notebook的第三篇，后来加入到他在2002年出版的经典著作“Agile Software Development, Principles, Patterns, and Practices”一书中。依赖倒转原则定义如下： 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
<p>针对抽象类或接口编程，将具体的子类配置在配置文件中。</p>
<p>在大多数情况下，开闭原则、里氏代换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[itunes-make-bell]]></title>
      <url>http://weiyiysw.com/2017/08/11/itunes-make-bell/</url>
      <content type="html"><![CDATA[<h1 id="给iPhone定制铃声"><a href="#给iPhone定制铃声" class="headerlink" title="给iPhone定制铃声"></a>给iPhone定制铃声</h1><p>使用iPhone，想着给自己电话制作需要的铃声，现将步骤记录如下（附图的话，之后再补）：</p>
<ol>
<li>下载好需要制作铃声的歌曲</li>
<li>打开iTunes，将下载好的歌曲添加到iTunes的歌曲中</li>
<li><p>选择歌曲，右键打开显示简介，并切换到<strong>选项</strong></p>
<p> <img src="/images/itunes-make-bell/1.png" alt=""></p>
</li>
<li><p>在<strong>开始</strong>和<strong>结束</strong>设定时间，不要超过40秒</p>
<p> <img src="/images/itunes-make-bell/2.png" alt=""></p>
</li>
<li><p>设置完成后点击<strong>确定</strong>（MAC下为 <strong>好</strong>）按钮即可。</p>
</li>
<li><p>Mac下，选择打开<strong>文件</strong>菜单，找到<strong>转换</strong>，选择<strong>创建ACC版本</strong></p>
<p> <img src="/images/itunes-make-bell/3.png" alt=""></p>
</li>
<li><p>这时就可以看到，生成了一个同名的但是时间更短的文件。</p>
<p> <img src="/images/itunes-make-bell/4.png" alt=""></p>
</li>
<li><p>点击生成的这个文件，在<strong>Finder中显示</strong>（windows下应为在Windows资源器中显示）</p>
</li>
<li><p>将文件拓展名M4A修改为M4R</p>
<p> <img src="/images/itunes-make-bell/5.png" alt=""></p>
</li>
<li><p>回到iTunes，右键选择从资源库删除这个文件，但不删除实际的文件</p>
<p><img src="/images/itunes-make-bell/6.png" alt=""></p>
</li>
<li><p>双击铃声文件，用iTunes打开，这个文件就默认在铃声里了</p>
<p><img src="/images/itunes-make-bell/7.png" alt=""></p>
</li>
<li><p>连接上iPhone，打开iPhone的界面。</p>
<p><img src="/images/itunes-make-bell/8.png" alt=""></p>
</li>
<li><p>点击同步或者选择铃声同步即可。注意每一次同步都会把以前同步过的铃声清楚。</p>
<p><img src="/images/itunes-make-bell/9.png" alt=""></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vertx-sendEmail]]></title>
      <url>http://weiyiysw.com/2017/08/05/vertx-sendEmail/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>vert.x邮件客户端完全是异步的，支持少量的传统验证方法如DIGEST-MD5，也全面支持TLS和SSL。vert.x邮件客户端支持连接池保持连接打开，便于重用。</p>
<h2 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h2><p><a href="https://github.com/weiyiysw/my-vertx-examples" target="_blank" rel="external">https://github.com/weiyiysw/my-vertx-examples</a></p>
<p>标准的maven项目，请查看示例demo中的SendMailUtil.java文件即可。</p>
<p>路径：src/main/java/com/weiyiysw/utils/SendMailUtil.java</p>
<h2 id="在Maven中使用"><a href="#在Maven中使用" class="headerlink" title="在Maven中使用"></a>在Maven中使用</h2><p>在<code>pom.xml</code>文件中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-mail-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="在Gradle中使用"><a href="#在Gradle中使用" class="headerlink" title="在Gradle中使用"></a>在Gradle中使用</h2><p>在<code>build.gradle</code>文件中添加</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'io.vertx:vertx-mail-client:3.4.2'</span></div></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建一个客户端"><a href="#创建一个客户端" class="headerlink" title="创建一个客户端"></a>创建一个客户端</h2><p>你可以邮件，通过创建一个客户端从本地的JVM打开SMTP连接。</p>
<p>这个客户端使用一个配置对象，默认配置是创建一个空对象并会连接本地的25端口，在一个标准的Linux环境并且在本地服务器上运行了Postfix或类似的邮件服务使用默认配置是没问题的。下面是所有配置对象的可能属性。</p>
<p>这个客户端可以使用SMTP连接池，避免每次都重新连接服务器、TLS重协商和登录（这个功能通过设置keepAlive=false可以被关闭掉）。一个客户端要么可以被共享要么不可以，如果是共享的，全部使用同一个标识的客户端将会使用相同的连接池。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">MailConfig config</span> = new MailConfig();</div><div class="line"><span class="attribute">MailClient mailClient</span> = MailClient.createShared(vertx, config, <span class="string">"exampleclient"</span>);</div></pre></td></tr></table></figure>
<p>第一次调用<code>MailClient.createShared</code>将会明确的室友特定的配置创建连接池。</p>
<p>随后的调用将会使用相同的连接池返回一个新的客户端实例，因此这个配置将不会被使用。</p>
<p>如果你忽略池标识，将会创建一个默认地额连接池。注意客户端仅在一个vert.x实例中共享（所以两个不同的vert.x实例有相同的标识也将会有不同的池）。</p>
<p>不共享的客户端可以用忽略标识相同的方式来创建。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">MailConfig config</span> = new MailConfig();</div><div class="line"><span class="attribute">MailClient mailClient</span> = MailClient.createNonShared(vertx, config);</div></pre></td></tr></table></figure>
<p>一个更详细的例子使用了一个邮件服务器并需要通过TLS登录。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MailConfig <span class="built_in">config</span> = new MailConfig()<span class="comment">;</span></div><div class="line"><span class="built_in">config</span>.setHostname(<span class="string">"mail.example.com"</span>)<span class="comment">;</span></div><div class="line"><span class="built_in">config</span>.setPort(<span class="number">587</span>)<span class="comment">;</span></div><div class="line"><span class="built_in">config</span>.setStarttls(StartTLSOptions.REQUIRED)<span class="comment">;</span></div><div class="line"><span class="built_in">config</span>.setUsername(<span class="string">"user"</span>)<span class="comment">;</span></div><div class="line"><span class="built_in">config</span>.setPassword(<span class="string">"password"</span>)<span class="comment">;</span></div><div class="line">MailClient mailClient = MailClient.createNonShared(vertx, <span class="built_in">config</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><p>一旦创建好了客户端对象，你就可以使用它来发送邮件了。由于在vert.x中发送邮件是异步的，当邮件操作完成时将会调用一个结果处理程序。你可以并行开始很多发送邮件操作，连接池将会限制并发的数量，所以如果没有客户端对象可用，那么新的操作将会在队列里等待。</p>
<p>邮件消息的构造是JSON的。邮件操作对象有这些属性：from、to、cc、bcc、subject、text、html等。根据设置的值，生成的MIME消息的格式会有所不同。接收地址的属性可以是单个地址也可以是多个地址。</p>
<p>MIME编码支持us-ascii（7bit）头/消息 和 utf8（通常打印引用）头/消息 格式。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MailMessage message = new MailMessage()<span class="comment">;</span></div><div class="line">message.setFrom(<span class="string">"user@example.com (Example User)"</span>)<span class="comment">;</span></div><div class="line">message.setTo(<span class="string">"recipient@example.org"</span>)<span class="comment">;</span></div><div class="line">message.setCc(<span class="string">"Another User &lt;another@example.net&gt;"</span>)<span class="comment">;</span></div><div class="line">message.setText(<span class="string">"this is the plain message text"</span>)<span class="comment">;</span></div><div class="line">message.setHtml(<span class="string">"this is html text &lt;a href=\"http://vertx.io\"&gt;vertx.io&lt;/a&gt;"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>附件可以通过MailAttachment对象创建，这个对象将数据存储在Buffer中，并支持base64附件。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MailAttachment attachment = new MailAttachment()<span class="comment">;</span></div><div class="line">attachment.setContentType(<span class="string">"text/plain"</span>)<span class="comment">;</span></div><div class="line">attachment.setData(Buffer.buffer(<span class="string">"attachment file"</span>))<span class="comment">;</span></div><div class="line"></div><div class="line">message.setAttachment(attachment)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>当使用一个内联附件（通常是图像），可以引用html消息中的图像来显示包含在邮件中的图像html。图形可以在HTML里被<code>&lt;img src=&quot;cid:contentid@domain&quot;&gt;</code>引用。相应的图像具有Disposition：inline和Content-ID标题为“<contentid @="" domain="">”。请注意，RFC 2392要求Content-ID值的结构类似于具有尖括号的Message-ID以及使用URL兼容编码的本地和域部分。 这些都不是强制执行的，大多数邮件客户端都支持没有尖括号或没有域名的ID，最佳做法是使用严格的格式。Content-ID值的有效示例是“<a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#102;&#105;&#108;&#101;&#x6e;&#x61;&#109;&#101;&#37;&#x32;&#48;&#x31;&#46;&#x6a;&#x70;&#103;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#111;&#114;&#103;">&#102;&#105;&#108;&#101;&#x6e;&#x61;&#109;&#101;&#37;&#x32;&#48;&#x31;&#46;&#x6a;&#x70;&#103;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#111;&#114;&#103;</a>”。</contentid></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MailAttachment attachment = new MailAttachment()<span class="comment">;</span></div><div class="line">attachment.setContentType(<span class="string">"image/jpeg"</span>)<span class="comment">;</span></div><div class="line">attachment.setData(Buffer.buffer(<span class="string">"image data"</span>))<span class="comment">;</span></div><div class="line">attachment.setDisposition(<span class="string">"inline"</span>)<span class="comment">;</span></div><div class="line">attachment.setContentId(<span class="string">"&lt;image1@example.com&gt;"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">message.setInlineAttachment(attachment)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>当发送邮件的时候，你可以提供一个<code>AsyncResult&lt;MailResult&gt;</code>处理程序，当发送操作完成或失败时会被调用。</p>
<p>邮件发送就像这样：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mailClient.sendMail(message, <span class="literal">result</span> -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">result</span>.succeeded()) &#123;</div><div class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>.<span class="literal">result</span>());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="literal">result</span>.cause().printStackTrace();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Mail-client数据对象"><a href="#Mail-client数据对象" class="headerlink" title="Mail-client数据对象"></a>Mail-client数据对象</h1><h2 id="MailMessage属性"><a href="#MailMessage属性" class="headerlink" title="MailMessage属性"></a>MailMessage属性</h2><p>Email变量都是String类型，可以使用带有或不带有真是名字的共同的格式。</p>
<ul>
<li><code>username@example.com</code></li>
<li><code>username@example.com (Firstname Lastname)</code></li>
<li><code>Firstname Lastname &lt;username@example.com&gt;</code></li>
</ul>
<p>MailMessage对象有接下来的这些属性：</p>
<ul>
<li><code>from</code>：String类型，代表邮件的发件人。</li>
<li><code>to</code>：String类型，代表邮件的收件人。</li>
<li><code>cc</code>：String类型，代表邮件的抄送人</li>
<li><code>bcc</code>：String类型，代表密送（b代表blind）。</li>
<li><code>bounceAddress</code>：String类型，代表错误的地址，如果没有设置from将会被使用。</li>
<li><code>text</code>：String类型，邮件的正文</li>
<li><code>html</code>：String类型，邮件中的HTML</li>
<li><code>attachment</code>：MailAttachment或者多个MailAttachment</li>
<li><code>inlineAttachment</code>：MailAttachment或者多个MailAttachment的内联附件，通常是图片</li>
<li><code>headers</code>：MultiMap表示除了MIME消息所需的标题之外还要添加的标题</li>
<li><code>fixedHeaders</code>：boolean类型，如果为true，只有作为headers属性提供的标题才会在生成的消息中设置。</li>
</ul>
<p>后两个属性允许操作产生带有自定义标题的消息，例如：提供一个message-id给调用程序选择或设置可以被默认产生的不同的标题。除非你知道你在做什么，这可能会产生无效的消息。</p>
<h2 id="MailAttachment属性"><a href="#MailAttachment属性" class="headerlink" title="MailAttachment属性"></a>MailAttachment属性</h2><p>MailAttachment对象有这些属性</p>
<ul>
<li><code>data</code>Buffer类型，包含了附件的二进制数据</li>
<li><code>contentType</code>String类型，附件的Content-Type（如：text/plain or text/plain; charset=”UTF8”, default is application/octet-stream）</li>
<li><code>description</code>String类型，附件的描述（这个值会放到附件的描述头里），可选的</li>
<li><code>disposition</code>String类型，描述附件的disposition（这要么是“inline”，要么是“attachment”，默认是attachment）</li>
<li><code>name</code>String类型，附件的文件名（这个值会放到附件的disposition和Content-Type头中），可选的</li>
<li><code>contentId</code>String类型，描述了附件的Content-Id（这用于标识内联图像），可选的</li>
<li><code>headers</code>MultiMap类型的附件头，除了默认的附件头，可选的</li>
</ul>
<h2 id="MailConfig选项"><a href="#MailConfig选项" class="headerlink" title="MailConfig选项"></a>MailConfig选项</h2><p>配置有这些属性：</p>
<ul>
<li><code>hostname</code>连接的SMTP服务器的主机名，默认是localhost</li>
<li><code>post</code>SMTP服务器的端口，默认是25</li>
<li><code>startTLS</code>StartTLSOptions要么是DISABLED、OPTIONAL或REQUIRED，默认是OPTIONAL</li>
<li><code>login</code>LoginOption要么是DISABLED、NONE或REQUIRED，默认是NONE</li>
<li><code>username</code>String类型，登录时的用户名（仅在LoginOption是REQUIRED时需要）</li>
<li><code>password</code>String类型，登录时的用户密码（仅在LoginOption是REQUIRED时需要）</li>
<li><code>ssl</code>boolean类型，连接邮件服务器时决定是否使用SSL，默认是false，设置为true时，需要使用465端口作SSL连接</li>
<li><code>ehloHostname</code>String类型，用在EHLO上，创建message-id，如果没设置，会使用主机名，这将不是一个好的选择如果它不包含一个FQDN或主机名为localhost。默认是可选的。</li>
<li><code>authMethods</code>字符串空间分开的允许的auth方法列表，这可以用于禁止某些auth方法或定义一个必需的auth方法</li>
<li><code>keepAlive</code>boolean类型，如果连接池开启了，默认为true。</li>
<li><code>maxPoolSize</code>连接池能够打开连接的最大数量，或者一次能够打开连接的最大数量，默认是10</li>
<li><code>trustAll</code>boolean类型，是否从服务器接受所有证书（默认是false）</li>
<li><code>keyStore</code>String类型，key store的文件名，可以用来信任服务器证书是否是自定义生成的。（默认可选）</li>
<li><code>keyStorePassword</code>String类型，用于解密key store。（默认可选）</li>
<li><code>allowRcptErrors</code>boolean类型，如果是true，一个接收人地址不用将会继续发送，邮件将会被发送直到一个地址接收了（默认是false）</li>
<li><code>disableEsmtp</code>boolean类型，如果是true，ESMTP相关命令将不会被使用（设置为true，如果你的SMTP服务器甚至不能用EHLO命令返回一个合适的错误码）（默认是false）</li>
</ul>
<h2 id="MailResult对象"><a href="#MailResult对象" class="headerlink" title="MailResult对象"></a>MailResult对象</h2><p>MailResult对象有这些成员：</p>
<ul>
<li><code>messageID</code>：生成邮件的Message-ID</li>
<li><code>recipients</code>：邮件需要发送的收件人列表（如果allowRcptError是true，这可能会少于想要的收件人）。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JNI-Basic-1.md]]></title>
      <url>http://weiyiysw.com/2017/07/04/JNI-Basic-1-md/</url>
      <content type="html"><![CDATA[<h1 id="0-开发环境准备"><a href="#0-开发环境准备" class="headerlink" title="0.开发环境准备"></a>0.开发环境准备</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>操作系统：debian 8</li>
<li>Java Version：jdk 8</li>
<li>gcc</li>
<li>make</li>
<li>vim</li>
</ul>
<h2 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h2><p>工作上中难免遇到一些需要调用C库的地方，有时候不得不写JNI来调用。查看别人的一些文章以及阅读The java native interface program’s guid and specification文档。在此简单做一些记录。</p>
<h1 id="1-HelloWorld"><a href="#1-HelloWorld" class="headerlink" title="1.HelloWorld"></a>1.HelloWorld</h1><h2 id="命令行编译java"><a href="#命令行编译java" class="headerlink" title="命令行编译java"></a>命令行编译java</h2><ol>
<li><p>在工作目录下，新建一个jni文件夹，并按照如下命令，新建Helloworld.java文件。</p>
<pre><code>mkdir jni
cd jni
mkdir -p src/com/jni/helloworld
vi src/com/jni/Helloworld.java
</code></pre></li>
<li><p>在HelloWorld.java文件中，声明一个native的方法。</p>
<pre><code>public native static void sayHello();
</code></pre></li>
<li><p>编译Helloworld.java文件，如果当前目录没有bin文件夹，创建即可。</p>
<pre><code>javac -d bin/ src/com/jni/Helloworld.java
</code></pre></li>
<li><p>生成头文件，如果没有headers文件夹，会基于当前目录创建一个headers文件夹，执行完后，打开headers文件夹，即可看到头文件</p>
<pre><code>javah -classpath bin -d headers -jni com.jni.Helloworld
</code></pre></li>
</ol>
<ul>
<li>-classpath：装入类的根目录，即“com.jni.helloworld.HelloWorld.class”所在的根目录</li>
<li>-d：选择要生成的头文件的目录</li>
<li>-jni：包名＋类名</li>
</ul>
<h1 id="2-生成头文件分析"><a href="#2-生成头文件分析" class="headerlink" title="2. 生成头文件分析"></a>2. 生成头文件分析</h1><p>生成的头文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></div><div class="line"><span class="comment">/* Header for class com_jni_helloworld_HelloWorld */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_jni_helloworld_HelloWorld</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_jni_helloworld_HelloWorld</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_jni_helloworld_HelloWorld</div><div class="line"> * Method:    sayHello</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_jni_helloworld_HelloWorld_sayHello</span> <span class="params">(JNIEnv *, jclass)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>参数简述</p>
<ul>
<li>JNIEnv *：指针</li>
<li>jclass：当Java中的方法为static方法时，第二个参数是jclass；当Java中的方法不为static时，第二个参数为jobject。</li>
</ul>
<h1 id="3-编辑C代码"><a href="#3-编辑C代码" class="headerlink" title="3. 编辑C代码"></a>3. 编辑C代码</h1><p>打开任意你喜欢的编辑器，编写C代码：</p>
<pre><code>#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
include “com_jni_HelloWorld.h”

JNIEXPORT void JNICALL Java_com_jni_helloworld_HelloWorld_sayHello (JNIEnv *env, jclass jclazz)
{
    printf(&quot;Hello World from jni!&quot;);
    return;
}
</code></pre><h1 id="4-生成动态链接库"><a href="#4-生成动态链接库" class="headerlink" title="4. 生成动态链接库"></a>4. 生成动态链接库</h1><p>这里，仅示例在Linux环境下生成动态链接库。</p>
<pre><code>gcc -I $JAVA_HOME/include -I $JAVA_HOME/include/linux -fPIC -o lib*.so -shared *.c
</code></pre><ul>
<li>-fPIC：显示同时编译器生成位置无关的代码</li>
</ul>
<h1 id="5-调用动态链接库"><a href="#5-调用动态链接库" class="headerlink" title="5. 调用动态链接库"></a>5. 调用动态链接库</h1><p>将代码添加到Java的static代码块中。</p>
<pre><code>static {
    System.load(&quot;Absolute path&quot;);
    // System.loadLibrary(&quot;java.library.path&quot;);
}
</code></pre><p>在Java代码中，通过System.load或System.loadLibrary来加载动态连接库，即前面生成的*.so文件。</p>
<ul>
<li>System.load：使用的是绝对路径</li>
<li>System.loadLibrary：使用的是java.library.path，生成*.so可以不包含库文件的扩展名。<ul>
<li>ex: libHelloWorld.so 在java.library.path下时，可以直接使用HelloWorld<br>可以使用</li>
<li>System.out.println(System.getProperty(“java.library.path”));在控制台打印这个路径值</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>建议</strong></p>
<p>使用System.load(“Absolutely path”)。<br>使用System.loadLibrary(“libname”)，需要将lib放到系统lib库里。查看系统lib库路径System.out.println(System.getProperty(“java.library.path”));。<br>在开始编写C／CPP代码时，将头文件的函数声明复制过去，然后再添加上形参。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Logback学习记录]]></title>
      <url>http://weiyiysw.com/2017/04/18/Logback%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="Logback架构"><a href="#Logback架构" class="headerlink" title="Logback架构"></a>Logback架构</h1><p>Logback分为了三个模块，logback-core、logback-classic、logback-access。</p>
<p>logback-core模块是其他两个模块的基础。classic模块拓展了core模块。access模块集成Servlet容器为HTTP-access提供日志功能。</p>
<blockquote>
<p>后面提到的Logback，指的是Logback-classic。</p>
</blockquote>
<h1 id="Logger、Appenders和Layouts"><a href="#Logger、Appenders和Layouts" class="headerlink" title="Logger、Appenders和Layouts"></a>Logger、Appenders和Layouts</h1><p>Logback建立在Logger、Appenders和Layouts三个主要类上。</p>
<p>Logger类是logger-classic模块的一部分，Appender和Layout接口来自Logback-core。</p>
<h2 id="Logger-context"><a href="#Logger-context" class="headerlink" title="Logger context"></a>Logger context</h2><p>任何比System.out.println更高级的logging API最重要的优点是能够在禁用特定的记录语句同时却不妨碍输出其他语句。</p>
<p>Logger是一个命名了的实体，大小写敏感。</p>
<p>命名规则：如果logger的名称带上一个点好后是另一个logger的名称前缀，那么，前者就被成为后者的祖先。如果logger与其后代的logger之间没有其他祖先，那么前者就被称为子logger的父logger。</p>
<p>所有的logger都可以通过静态方法getLogger获取到。用同一名字调用LoggerFactory.getLogger方法得到的永远都是同一个logger对象的引用。</p>
<p>如：<br>    logger x = LoggerFactory.getLogger(“weiyiysw”);<br>    logger y = LoggerFactory.getLogger(“weiyiysw”);</p>
<p>x 和 y指向同一个logger对象。</p>
<h2 id="输出有效级别的继承"><a href="#输出有效级别的继承" class="headerlink" title="输出有效级别的继承"></a>输出有效级别的继承</h2><p>Logger可以被分配级别。级别包括：TRACE、DEBUG、INFO、WARN、ERROR。</p>
<p>如果logger没有分配级别，那么它将从有被分配的级别的最近的祖先那里继承级别。</p>
<p>为确保每个logger最终都能继承一个级别，根logger总是有级别的，默认情况下，这个级别是DEBUG。</p>
<h2 id="打印方法和基本选择规则"><a href="#打印方法和基本选择规则" class="headerlink" title="打印方法和基本选择规则"></a>打印方法和基本选择规则</h2><p>基本选择规则：记录请求级别为P，其logger的有效级别为Q，只有在P &gt;= Q时，该请求才会执行。</p>
<p>级别排序 </p>
<pre><code>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR
</code></pre><h2 id="Appender-和-Layout"><a href="#Appender-和-Layout" class="headerlink" title="Appender 和 Layout"></a>Appender 和 Layout</h2><p>在logback里，一个输出目的地就是一个appender。</p>
<p>一个logger可以关联到多个appender。</p>
<p>Appender的叠加性：Logger L的记录语句的输出会发送给L及其祖先的全部appender。然而，如果Logger L的某个祖先P，设置additivity为FALSE，那么L的输出会发送给L与P之间的（含P）的所有Appender，但不会发送给P的任何祖先Appender。</p>
<p>additivity叠加性默认为TRUE。</p>
<p>Layout负责根据用户的意愿，格式化输出记录。Appender负责将格式化后的输出发送到目的地。</p>
<p>PatternLayout是标准logback发行包的一部分，允许用户按照类似于C语言的printf函数的转换模式设置输出格式。</p>
<p>例如: <code>%-4relative [%thread] %-5level %logger{32} - %msg%n</code></p>
<p>输出：<code>176 [main] DEBUG manual.architecture.HelloWorld2 - Hello world.</code></p>
<p>第一个字段是自程序启动以来的逝去时间，单位是毫秒。</p>
<p>第二个地段发出记录请求的线程。</p>
<p>第三个字段是记录请求的级别。</p>
<p>第四个字段是与记录请求关联的 logger 的名称。</p>
<p>“-”之后是请求的消息文字。</p>
<h2 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h2><p>对于某个Logger，下面的代码：</p>
<pre><code>logger.debug(&quot;Entry number:&quot; + i + &quot;is &quot; + String.valueOf(entry[i]));
</code></pre><p>在构造消息参数时有性能消耗，即把整数i和entry[i]都转换为字符串时、连接多个字符串时。不管消息是否被几率，都会造成上述消耗。</p>
<h3 id="替代方法"><a href="#替代方法" class="headerlink" title="替代方法"></a>替代方法</h3><p>假设entry是一个object，你可以编写：</p>
<pre><code>Object entry = new SomeObject();
logger.debug(&quot;The entry is {}.&quot;, entry);
</code></pre><p>在评估是否作记录后，仅当需要作记录时，logger才会格式化消息，用entry的字符串值替换为“{}”。即，当语句被禁用时，这种方法不会产生参数构造所带来的性能消耗。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下查看CPU信息、机器型号]]></title>
      <url>http://weiyiysw.com/2017/04/18/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8BCPU%E4%BF%A1%E6%81%AF%E3%80%81%E6%9C%BA%E5%99%A8%E5%9E%8B%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h1 id="记录常用的一些命令"><a href="#记录常用的一些命令" class="headerlink" title="记录常用的一些命令"></a>记录常用的一些命令</h1><pre><code>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c

cat /proc/cpuinfo | grep physical | uniq -c

# 说明当前CPU运行的模式，如32bit模式或64bit
getconf LONG_BIT 

# 查看内存信息
cat /proc/meminfo

# 查看当前操作系统内核信息
uname -a

# 查看当前操作系统发现版信息
cat /etc/issue | grep Linux

# 查看机器型号 
dmidecode | grep &quot;Product Name&quot;  

# 查看网卡信息 
dmesg | grep -i eth
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[how-to-maintain-changelog]]></title>
      <url>http://weiyiysw.com/2016/12/22/how-to-maintain-changelog/</url>
      <content type="html"><![CDATA[<h1 id="预先声明"><a href="#预先声明" class="headerlink" title="预先声明"></a>预先声明</h1><p>这篇文章并非原创，而是我转载记录使用。这篇文章原地址如下<a href="http://keepachangelog.com/zh-CN/0.3.0/" target="_blank" rel="external">如何维护更新日志</a>，大家可以查看原文获取更多内容。</p>
<a id="more"></a>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="更新日志是什么？"><a href="#更新日志是什么？" class="headerlink" title="更新日志是什么？"></a>更新日志是什么？</h2><p>更新日志（Change Log）是一个由人工编辑，以时间为倒叙的列表。 这个列表记录所有版本的重大变动。</p>
<h2 id="为何要提供更新日志？"><a href="#为何要提供更新日志？" class="headerlink" title="为何要提供更新日志？"></a>为何要提供更新日志？</h2><p>为了让用户和开发人员更好的知道每一个版本有哪些区别。</p>
<h2 id="为何我要在乎呢？"><a href="#为何我要在乎呢？" class="headerlink" title="为何我要在乎呢？"></a>为何我要在乎呢？</h2><p>因为归根结底软件是为人提供的。既然你不关心人，哪么为何写软件呢？ 多少你还是要关心你的受众。</p>
<p>本文档原作者和另外两个人的一个<a href="https://changelog.com/podcast/127" target="_blank" rel="external">博客</a>向大家介绍了， 为何代码的管理者和开发者应该在乎更新日志。如果你有一小时时间和很好的英文听力本领， 不放听听。</p>
<h1 id="定义好的更新日志"><a href="#定义好的更新日志" class="headerlink" title="定义好的更新日志"></a>定义好的更新日志</h1><p>一个好的更新日志，一定满足：</p>
<ul>
<li>给人而不是机器写的。记住，说人话。</li>
<li>快速跳转到任意段。采用markdown格式。</li>
<li>一个版本对应一个章节。</li>
<li>最新版本在上，最老版本在下面。</li>
<li>所有日期次哎哟个<strong>YYYY-MM-DD</strong>规范。</li>
<li>这个是国际通用，任何语言 都能理解的，并且还被<a href="http://xkcd.com/1179/" target="_blank" rel="external">xkcd</a>推荐呢！</li>
<li>标出来是否遵守<a href="http://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本格式</a></li>
<li>每一个软件的版本必须：<ul>
<li>表明日期（要用上面说过的规范）</li>
<li>标明分类（采用英文）。规范如下：<ul>
<li><code>Added</code> 添加新功能</li>
<li><code>Changed</code> 功能变更</li>
<li><code>Deprecated</code> 不建议使用，未来会删掉</li>
<li><code>Removed</code> 之前不建议的功能，这次真的删掉了</li>
<li><code>Fixed</code> 改的bug</li>
<li><code>Security</code> 改的有关安全相关的bug</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="怎么尽可能减少耗费的精力"><a href="#怎么尽可能减少耗费的精力" class="headerlink" title="怎么尽可能减少耗费的精力"></a>怎么尽可能减少耗费的精力</h1><p>永远在文档最上方提供一个<code>Unreleased</code>未发布区域，来记录当前的变化。 这佯作有两大意义。 </p>
<ul>
<li>大家可以看到接下来会有什么变化</li>
<li>在发布时，只需要把<code>Unreleased</code>改为当前的版本号，然后再添加一个新的<code>Unreleased</code>即可。</li>
</ul>
<h1 id="注意，以下做法不推荐"><a href="#注意，以下做法不推荐" class="headerlink" title="注意，以下做法不推荐"></a>注意，以下做法不推荐</h1><p>请一定要注意：</p>
<ul>
<li><strong>把git日志扔到更新日志里</strong>。看似有用，然并卵。</li>
<li><strong>不写<code>deprecations</code>就删功能。</strong> 不带这样坑队友的。</li>
<li><strong>采用各种不靠谱的格式，如 2016年12月22日。</strong> 日期这样写，也就中国人及懂中文的懂了。</li>
</ul>
<h1 id="更新日志文件名该叫什么？"><a href="#更新日志文件名该叫什么？" class="headerlink" title="更新日志文件名该叫什么？"></a>更新日志文件名该叫什么？</h1><blockquote>
<p>注意：原文提供了一个案例，案例的连接在文末。</p>
</blockquote>
<p>更新日志的名字最好的规范是：<code>CHANGELOG.md</code>，一定要注意大小写。</p>
<h1 id="撤下来的版本怎么办？"><a href="#撤下来的版本怎么办？" class="headerlink" title="撤下来的版本怎么办？"></a>撤下来的版本怎么办？</h1><p>因为各种安全/重大bug原因被撤下的版本被标记’YANKED’。这些版本一般不出现在更新日志里，但作者建议他们出现。 显示方式应该是：</p>
<pre><code>## 0.0.5 - 2014-12-13 [YANKED]
</code></pre><p><code>[YANKED]</code>采用大写更加显著，因为这个信息很重要。而采用方括号则容易被程序解析。</p>
<h1 id="是否可以重写更新日志"><a href="#是否可以重写更新日志" class="headerlink" title="是否可以重写更新日志"></a>是否可以重写更新日志</h1><p>当然。哪怕已经上线了，也可以重新更新更新日志。有许多开源项目更新日志不够新，所以作者就会帮忙更新。</p>
<p>另外，很有可能你忘记记录一个重大功能更新。所以这时候应该去重写更新日志。</p>
<h1 id="如何贡献"><a href="#如何贡献" class="headerlink" title="如何贡献?"></a>如何贡献?</h1><p>本文档并不是真理。这只是原作者的个人建议，并且包括许多收集的例子。哪怕本开源库提供一个<a href="https://github.com/olivierlacan/keep-a-changelog/blob/master/CHANGELOG.md" target="_blank" rel="external">更新日志案例</a>，我刻意没有提供一个 过于苛刻的规则列表（不像<a href="http://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本格式</a>）。</p>
<p>这是因为我希望通过社区达到统一观点，我认为中间讨论的过程与结果一样重要。</p>
<p>所以<a href="https://github.com/olivierlacan/keep-a-changelog" target="_blank" rel="external">欢迎贡献</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux下动态库及版本号控制]]></title>
      <url>http://weiyiysw.com/2016/12/19/linux%E4%B8%8B%E5%8A%A8%E6%80%81%E5%BA%93%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><p>我们都知道在Linux系统下，动态库的命名遵循了特定的规则</p>
<pre><code>lib{name}.so
</code></pre><p>如上所示，其中{name}可以替换为你自己声明的动态库名称。</p>
<p>可能大部分的人都了解就到这里，并没有关注动态库文件后面的版本控制。如果你已经关注了，那么后面的就可以不用看啦。</p>
<h1 id="Linux下动态库的命名规范"><a href="#Linux下动态库的命名规范" class="headerlink" title="Linux下动态库的命名规范"></a>Linux下动态库的命名规范</h1><p>Linux下引入了一套命名机制，但是这个机制仅是一个约定，并不强迫大家都按照这种方法。</p>
<h2 id="Real-Name"><a href="#Real-Name" class="headerlink" title="Real Name"></a>Real Name</h2><p>共享库本身的文件名，共享库的命名必须是<code>libname.so.x.y.z</code>，这里xyz代表的是此库文件的版本号。</p>
<ul>
<li>前缀： lib</li>
<li>后缀： so</li>
<li>name：自定义的库文件名</li>
<li>x: Major Version Number，主版本号，不兼容。重大升级，不同主版本之间的库是不兼容的。</li>
<li>y: Minor Version Number, 次版本号，向下兼容。增量升级，增加一些新的接口但保留原有接口。高次版本的库向后兼容低次版本的库。</li>
<li>z: Release Version Number，发布版本号，互相兼容。诸如库的一些错误修改、性能改进等，不会添加新接口，也不会更改接口。主版本和次版本完全相同的情况下，不同发行版本之间完全兼容。</li>
</ul>
<h2 id="SO-NAME"><a href="#SO-NAME" class="headerlink" title="SO-NAME"></a>SO-NAME</h2><p>在Linux系统中，每个共享库都有一个对应的SO-NAME（共享库文件名去掉次版本号和发布版本号）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综合上述两点，当我们遵循了Linux的这种机制并生成了自己的动态库文件后。咱们可以对库文件设置软连接，就可以避免真实库文件版本数字一直在变动，而不得不调整调用的代码。</p>
<p>例如：有一个 libHelloWorld.so.x.y.z</p>
<pre><code>ln -s libHelloWorld.so.x.y.z libHelloWorld.so.x
</code></pre><p>在代码中，查找库文件此软连接的名字，在主版本未改动的情况下，动态库版本变动只需调整软连接即可。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[setup-hexo]]></title>
      <url>http://weiyiysw.com/2016/12/18/setup-hexo/</url>
      <content type="html"><![CDATA[<h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装Hexo相当简单。在安装前，你必须检查电脑中是否已经安装了下列应用程序：</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>如果你的电脑已经安装好了上述必备程序，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><p>如果你的电脑尚未安装所需要的程序，请按照以下安装指示完成安装。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul>
<li>windows：下载并安装<a href="https://git-scm.com/download/win" target="_blank" rel="external">git</a></li>
<li>Mac：使用Homebrew，MacPorts或下载安装程序安装。</li>
<li>Linux(Ubuntu\Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux(Fedora\Red Hat\CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>。</p>
<p>cURL:</p>
<pre><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh
</code></pre><p>Wget:</p>
<pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh
</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>
<pre><code>$ nvm install stable
</code></pre><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="external">安装程序</a> 来安装。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>所有必备的应用程序安装完成后，即可以使用npm安装Hexo。</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><blockquote>
<p>注意：采用Hexo写文章，需要去了解一下Markdown语法。Markdown简单易学，可以找一款适合你的Markdown的编辑器。</p>
</blockquote>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p>安装Hexo完成后，请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。</p>
<pre><code>$ hexo init &lt;folder&gt;
$ cd &lt;folder&gt;
$ npm install
</code></pre><p>新建完成后，指定文件夹的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>这个是配置文件，大部分的配置都在这里，按需修改。</p>
<h2 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h2><p>这个是主题文件夹，把主题下载到这个文件夹下即可。</p>
<h2 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h2><p>这个是模板文件夹，新建文章时Hexo会根据scaffolds来生成。</p>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>这里是应用程序信息。保持默认即可。</p>
<h1 id="与GitHub-Pages绑定"><a href="#与GitHub-Pages绑定" class="headerlink" title="与GitHub Pages绑定"></a>与GitHub Pages绑定</h1><p>Hexo博客搭建完成之后，我们执行<code>hexo s</code>就可以在本地访问自己的blog了。</p>
<p>您还可以把您的博客托管到网上，以便于大家分享。托管的有很多，在这里仅记录与GitHub Pages绑定。</p>
<h2 id="注册一个GitHub账号"><a href="#注册一个GitHub账号" class="headerlink" title="注册一个GitHub账号"></a>注册一个GitHub账号</h2><p>首先，你需要有一个github账号。注册过程很简单，就不描述了。这里需要注意，注册时您选择的用户名很重要（英文），设置一个喜欢的用户名就好。github的通知几乎都是邮件通知的，所以邮箱一定要是常用邮箱。</p>
<h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><p>注册好账号之后，登录GitHub。然后创建一个仓库，我们创建的仓库用于个人博客，这样的仓库只能创建一个。创建的仓库名填写的是我们之前注册的用户名，其他的保持默认即可。例如，我的用户名是weiyiysw，那么我就创建一个weiyiysw的仓库。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>仓库建立好之后，我们需要将我们的博客发布到GitHub上。</p>
<p>首先，我们需要修改我们Hexo博客根目录下的<code>_config.yml</code>文件，找到deploy，并按照如下配置，其中仓库替换为前一步github仓库地址即可。</p>
<pre><code>deploy:
    type: git
    repository: https://github.com/weiyiysw/weiyiysw.github.io.git
    branch: master
    message: [自定义提交信息]
</code></pre><p>保存此配置文件。</p>
<p>然后安装插件：</p>
<pre><code>$ npm install hexo-deployer-git --save
</code></pre><p>最后，在终端下执行如下命令：</p>
<pre><code>hexo clean (清楚缓存文件和生成的静态文件)
hexo generate (缩写 hexo g，生成静态文件)
hexo deploy (缩写 hexo d，部署网站)
</code></pre><p>待<code>hexo d</code>执行结束，即部署成功。这时候，您就可以访问自己的博客了。以我的为例，例如：<a href="https://weiyiysw.github.io" target="_blank" rel="external">https://weiyiysw.github.io</a>。</p>
<p>您只需把替换成您自己的用户名访问，即可。</p>
<pre><code>https://yourusername.github.io
</code></pre><blockquote>
<p>注意：您还可以自己通过购买属于自己的域名，然后将域名绑定到这。即可通过自己的域名访问。具体，请网上搜索教程。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vertx-core翻译]]></title>
      <url>http://weiyiysw.com/2016/12/10/vertx-core/</url>
      <content type="html"><![CDATA[<h1 id="Vert-x的核心是一组被我们称为Vert-x-Core的Java-APIs"><a href="#Vert-x的核心是一组被我们称为Vert-x-Core的Java-APIs" class="headerlink" title="Vert.x的核心是一组被我们称为Vert.x Core的Java APIs"></a>Vert.x的核心是一组被我们称为Vert.x Core的Java APIs</h1><p>Vert.x core提供了下面这些功能：</p>
<ul>
<li>编写TCP clients和servers</li>
<li>编写HTTP clients和servers包括支持WebSockets</li>
<li>Event bus</li>
<li>Shared data - 本地的maps和分布式的集群式的maps</li>
<li>周期性和延迟运行</li>
<li>部署和卸载Verticles</li>
<li>数据包套接字</li>
<li>DNS客户端</li>
<li>访问文件系统</li>
<li>高可用</li>
<li>集群</li>
</ul>
<p>Vert.x core里的功能是相当底层的，在这里你不会找到像数据库访问、权限验证或者高层web功能的东西。那些东西你可以在Vert.x ext里找到。</p>
<p>Vert.x core很小并且很轻量级的。你可以仅使用你想要的那部分。它也可以完全的嵌入到你现在已经存在的应用。我们并不强迫你仅为了使用Vert.x而通过一种特殊的方式来架构你的应用。</p>
<p>你可以通过Vert.x支持的任何语言来使用Vert.x core。这有点酷，在这里我们并不强迫你直接使用Java API，换言之JavaScript或者Ruby都可以。毕竟不同的语言有不同的惯例和语法。强迫Ruby开发者使用Java语法来开发这是很奇怪的（例如）。相反，我们会为每一种语言生成一个符合语言习惯的、等效于Java APIs的Vert.x core。</p>
<p>从这开始，我们仅使用这个单词<strong>core</strong>代表Vert.x core。</p>
<p>如果你使用Maven或Gradle，添加接下来的依赖到你的项目中<code>dependencies</code>部分，这样你就可以使用Vert.x core API：</p>
<ul>
<li><p>Maven（在<code>pom.xml</code>文件里）</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.vertx&lt;/groupI&gt;
    &lt;artifactId&gt;vertx-core&lt;/artifactId&gt;
    &lt;version&gt;3.3.3&lt;/version&gt;    
&lt;/dependency&gt;
</code></pre></li>
<li><p>Gradle（在<code>build.gradle</code>文件里）</p>
<pre><code>compile io.vertx:vertx-core:3.3.3
</code></pre></li>
</ul>
<p>接下来，我们来讨论Vert.x core的不同的概念及特性。</p>
<hr>
<h3 id="从Vert-x开始"><a href="#从Vert-x开始" class="headerlink" title="从Vert.x开始"></a>从Vert.x开始</h3><hr>
<blockquote>
<p>注意：这里的大部分都是Java特有的 —— 换成其他语言时需要一些其他的特殊的部分</p>
</blockquote>
<p>在Vert.x的世界你几乎做不了什么，除非你可以和<code>Vertx</code>对象交流。</p>
<p>Vertx对象是Vert.x的控制中心，通过它，你几乎可以做任何事情，包括创建客户端及服务器、获取事件总线（event bus）的引用、设置定时器等及很多其他的东西。</p>
<p>因此，怎么来获取到一个实例呢？</p>
<p>如果你正在嵌入Vert.x，你可以简单的创建一个实例就像接下来这样：</p>
<pre><code>Vertx vertx = Vertx.vertx();
</code></pre><p>如果你要使用Verticles</p>
<blockquote>
<p>大多数的应用仅需要一个简单的Vert.x实例，但是如果你需要，创建多个Vert.x实例是可以的。例如，事件总线的隔离或不同组的服务器和客户端的隔离。</p>
</blockquote>
<h4 id="创建一个指定选项的Vertx对象"><a href="#创建一个指定选项的Vertx对象" class="headerlink" title="创建一个指定选项的Vertx对象"></a>创建一个指定选项的Vertx对象</h4><p>当创建一个Vertx对象时，如果默认的不适合，你可以指定一个选项。</p>
<pre><code>Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));
</code></pre><p><code>VertxOptions</code>对象有很多设置并且允许你配置它，如：集群、高可用、池大小及其他大量的设置。Javadoc文档详细的描述了全部的设置。</p>
<h4 id="创建一个集群式的Vert-x对象"><a href="#创建一个集群式的Vert-x对象" class="headerlink" title="创建一个集群式的Vert.x对象"></a>创建一个集群式的Vert.x对象</h4><p>如果你要创建一个集群的Vert.x（在event bus小节查看更多的关于集群event bus信息），通常你将使用异步的方式创建这个对象。</p>
<p>这是因为这通常会花费一些时间（可能几秒钟），在一个集群里将不同的Vert.x实例编组。在这段时间，我们并不希望阻塞调用线程，因此，我们把结果以异步的方式给你。</p>
<hr>
<h3 id="你用流式API编程吗？"><a href="#你用流式API编程吗？" class="headerlink" title="你用流式API编程吗？"></a>你用流式API编程吗？</h3><hr>
<p>你可能已经注意到了，前面的例子中都使用了流式API。</p>
<p>流式API是多个方法调用组成的链。例如：</p>
<pre><code>request.response().putHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;).write(&quot;some text&quot;).end();
</code></pre><p>流式的代码风格贯穿了整个Vert.x API。所以，你需要适应它。</p>
<p>链式的调用会让你写的代码紧凑些。当然，如果你不喜欢流式的方式，我们并不强迫你。你可以不管它，并按照你喜欢的方式写。你可能会这样写：</p>
<pre><code>HttpServerResponse response = request.response();
response.putHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);
response.write(&quot;some text&quot;);
response.end();
</code></pre><hr>
<h3 id="别调用我们，我们会通知你的"><a href="#别调用我们，我们会通知你的" class="headerlink" title="别调用我们，我们会通知你的"></a>别调用我们，我们会通知你的</h3><hr>
<p>Vert.x APIs大部分都是事件驱动的。这意味着，当Vert.x里发生了你感兴趣的事情时，Vert.x会通过回调的方式给你发送事件。</p>
<p>一些示例的事件如下:</p>
<ul>
<li>激活计时器</li>
<li>数据到达了socket</li>
<li>从磁盘中读取数据</li>
<li>发生了一个异常</li>
<li>Http server接收到了一个请求</li>
</ul>
<p>通过Vert.x APIs提供的<strong>handlers</strong>处理事件。例如：接收一个定时器事件，每一秒钟你都这样做：</p>
<pre><code>vertx.setPeriodic(1000, id -&gt; {
    // This handler will get called every second
    System.out.println(&quot;timer fired!&quot;);
});
</code></pre><p>或者接收一个Http请求：</p>
<pre><code>server.requestHandler(request -&gt; {
    // This handler will be called every time an Http request is received at the server
    request.response.end(&quot;Hello World!&quot;)
});
</code></pre><p>在过了一些时间之后，Vert.x有一个事件并将其传入到handler里，这在Vert.x里被称为异步性。</p>
<p>这为我们引导了Vert.x的一些重要的概念：</p>
<hr>
<h3 id="别阻塞我"><a href="#别阻塞我" class="headerlink" title="别阻塞我"></a>别阻塞我</h3><hr>
<p>除了很少的一些异常（例如：一些结尾为‘Sync’的文件系统的操作），在Vert.x里没有任何的APIs调用时会被阻塞。</p>
<p>如果一个结果可以马上提供，那么将会立刻把这个结果返回。要不然，你需要提供一个handler在一段时间之后来接收事件。</p>
<p>因为Vert.x APIs不会阻塞任何线程，这意味着你可以使用Vert.x来处理小数量线程的大量并发使用。</p>
<p>一个常规的阻塞API在调用时可能会以下这些情况阻塞：</p>
<ul>
<li>从一个socket读取数据</li>
<li>写数据到磁盘</li>
<li>发送一个消息给接收者并等待回复</li>
<li>其他很多的情况</li>
</ul>
<p>在所有上述的例子中，当你的线程正在等待一个结果时，这个线程其他什么都不能做，这实在是没有用的。</p>
<p>这意味着，当你需要大量的并发并且使用阻塞API时，你需要大量的线程来防止你的程序完全停止。</p>
<p>线程在它们所需要的内存（例如栈）和上下文切换时是有开销的。</p>
<p>对于现代应用的需要的并发水平，阻塞的方法并不适合扩展。</p>
<hr>
<h3 id="Reactor和Multi-Reactor"><a href="#Reactor和Multi-Reactor" class="headerlink" title="Reactor和Multi-Reactor"></a>Reactor和Multi-Reactor</h3><hr>
<p>我们前面提到了Vert.x APIs是事件驱动的，Vert.x传递事件到handlers当事件是可用的。</p>
<p>在大多数的例子中，Vert.x通过一个名为event loop的线程调用你的handler。</p>
<p>在Vert.x或你的应用中如果没有任何阻塞，这个event loop可以很愉快的运行，当事件到达的时候，可以成功的分发事件到不同的handlers。</p>
<p>因为没有任何阻塞，一个event loop可以在短时间内分发大量的时间。例如，一个单一的event loop可以很快的处理几千个HTTP请求。</p>
<p>我们把这个称为反应器模式。</p>
<p>你之前可能就听过这个，例如，Node.js就已经实现了这个模式。</p>
<p>在一个标准的反应堆模式的实现里，只有一个单一的event loop线程循环的运行并分发所有的事件到其对应的handlers里，当事件到达的时候。</p>
<p>使用一个单一的线程的麻烦在于这个线程同一事件只能运行在一个单一的核上，所以如果你想让你的单一线程的反应堆应用（例如你的Node.js应用）拓展到你的多核的服务器上，你不得不启动和管理很多不同的进程。</p>
<p>Vert.x的处理是不一样的。不同于一个单一的event loop，每个Vertx示例包含了多个event loop。默认的我们选择的数量是基于机器上可用的核心数量，但是这可以被覆盖。</p>
<p>这意味着一个单一的Vertx进程可以在整个服务器上扩展，不像Node.js需要多个进程。</p>
<p>我们将这种模式成为多核反应堆模式，用来区分单一线程的反应堆模式。</p>
<blockquote>
<p>即使一个Vertx实例包含了多个event loop，任何特别的handler将不会被并发执行，在大多数的例子中（除了worker verticles），他们总是会被完全相同的event loop调用。</p>
</blockquote>
<hr>
<h3 id="黄金法则——不要阻塞event-loop"><a href="#黄金法则——不要阻塞event-loop" class="headerlink" title="黄金法则——不要阻塞event loop"></a>黄金法则——不要阻塞event loop</h3><hr>
<p>我们已经知道Vert.x APIs是无阻塞的，也不会阻塞event loop，但是这并没有太多用如果你自己在你的handler里阻塞event loop。</p>
<p>如果你这样做了，event loop将不能做任何其他的事当它被阻塞了。如果你阻塞了Vertx实例所有的event loop，那么你的应用将会完全停止。</p>
<p>所以，不要去阻塞它！你已经被警告了。</p>
<p>阻塞的例子包括：</p>
<ul>
<li>Thread.sleep()</li>
<li>等待一个锁</li>
<li>等待互斥或监视器（如：同步代码）</li>
<li>做一个长时间数据库操作并且等待一个结果</li>
<li>做一个复杂的计算，会占用一些重要的时间</li>
<li>死循环</li>
</ul>
<p>如果上面提到的任何一个使event loop停止了做任何其他的事情并且大量时间，然后你应该马上到下一步(naughty step)，并且等待下一步指示。</p>
<p>所以…这个大量的时间具体多长呢？</p>
<p>一个string花多长时间呢？它真实的依赖于你的应用和你需要的并发量。</p>
<p>如果你有一个单一的event loop，你还想每秒处理10000个http请求，这是很明确的每个请求执行的时间最多不能超过0.1ms，因此，你的阻塞时间不能超过这个。</p>
<p>这个数学计算并不难，应该作为联系留给读者。</p>
<p>如果你的应用不响应，很可能你在某个地方阻塞了event loop。为了帮助你诊断这些问题，Vert.x会自动记录警告如果检测到一个event loop在一些时间内没有返回。如果你在日志中看到像这样的警告，你应该去检查你的代码了。</p>
<pre><code>Thread vertx-eventloop-thread-3 has been blocked for 20458ms
</code></pre><p>Vert.x还会提供堆栈跟踪来准确的定位阻塞发生的地方。</p>
<p>如果你想关闭这些警告或者修改设置，你可以在创建Vertx对象前，设置<code>VertxOptions</code>对象。</p>
<hr>
<h3 id="运行阻塞的代码"><a href="#运行阻塞的代码" class="headerlink" title="运行阻塞的代码"></a>运行阻塞的代码</h3><hr>
<p>在一个完美的世界中，那是没有战争或饥饿的。所有的API都是用异步的方式写的，阳光明媚，绿色的草地有跳来跳去的兔子和手牵手的小羊羔。</p>
<p>但是，真实的世界并不是这样子的。</p>
<p>事实上，大多数的库尤其是JVM的生态系统都是有同步的API，很多方法都有可能阻塞。一个很好的例子就是JDBC API，它本质上就是同步的，无论再怎么努力尝试，Vert.x即使使用魔法也不可能把它变成异步的。</p>
<p>我们不可能一晚上就将所有的同步API重写为异步的，所以我们需要提供一种方法让你能够在Vert.x应用中安全的使用使用传统的阻塞API。</p>
<p>就像前面讨论的，从一个event loop中你不能直接的调用一个阻塞的操作，如果那样做了，将会阻止event loop做其他有效的工作。那么，你该怎么做呢？</p>
<p>通过调用<code>executeBlocking</code>来完成，具体来说，将阻塞的代码放到此方法中执行，当阻塞代码执行结束后，通过异步的回调handler返回结果。</p>
<pre><code>vertx.executeBlocking(future -&gt; {
    // call some blocking api that takes a significant amount of time to return
    String result = someAPI.blockingMethod(&quot;Hello&quot;);
    future.complete(result);
}, res -&gt; {
    System.out.println(&quot;The result is: &quot; + res.result());
});
</code></pre><p>默认地，如果executeBlocking从相同的上下文里被调用多次（例如，相同的verticle实例），然后不同的executeBlocking是按序列执行的（一个按一个执行）。</p>
<p>如果你不关心你能调用的executeBlocking的执行顺序，指定<code>ordered</code>参数为<code>false</code>。这种情况下，任何一个executeBlocking可以在工作池上并行执行。</p>
<p>一个运行blocking代码可替换的方法是使用一个worker verticle。</p>
<p>默认地，阻塞代码被执行会阻塞Vert.x代码池，配置<code>setWorkerPoolSize</code>。</p>
<p>传统的池可以为了不同的目的而被创建：</p>
<pre><code>WorkerExecutor executor = vertx.createSharedWorkerExecutor(&quot;my-worker-pool&quot;);
executor.executeBlocking(future -&gt; {
// Call some blocking API that takes a significant amount of time to return
String result = someAPI.blockingMethod(&quot;hello&quot;);
future.complete(result);
}, res -&gt; {
System.out.println(&quot;The result is: &quot; + res.result());
});
</code></pre><p>工作执行必须被关闭，当它不再需要的时候：</p>
<pre><code>executor.close();
</code></pre><p>当多个工作者用相同的名字被创建后，它们将分享相同的池。这个工作池会被摧毁，当全部的工作执行者使用它被关闭后。</p>
<p>当一个执行者在Verticle里被创建后，Vert.x将会自动的为你关闭它，当Verticle卸载的时候。</p>
<p>工作执行者在被创建的时候可以被配置：</p>
<pre><code>int poolSize = 10;

// 2 minutes
long maxExecuteTime = 120000;

WorkerExecutor executor =     vertx.createSharedWorkerExecutor(&quot;my-worker-pool&quot;, poolSize, maxExecuteTime);
</code></pre><blockquote>
<p>当工作池被创建的时候配置文件就已经设置了。</p>
</blockquote>
<hr>
<h3 id="异步协调"><a href="#异步协调" class="headerlink" title="异步协调"></a>异步协调</h3><hr>
<p>协调多个异步的结果是可以通过Vert.x的<code>futures</code>来实现。它支持并行架构（并行运行多个异步的操作）和序列架构（异步链式操作）。</p>
<h4 id="并发架构"><a href="#并发架构" class="headerlink" title="并发架构"></a>并发架构</h4><p><code>CompositeFuture.all</code>携带了多个future参数（最多6个）并且返回一个future对象。如果返回的future成功了，那么所有的携带的所有future都成功了，如果返回的future失败了，那么至少是有一个携带的future失败了：</p>
<pre><code>Future&lt;HttpServer&gt; httpServerFuture = Future.future();
httpServer.listen(httpServerFuture.completer());

Future&lt;NetServer&gt; netServerFuture = Future.future();
netServer.listen(netServerFuture.completer());

CompositeFuture.all(httpServerFuture, netServerFuture).setHandler(ar -&gt; {
    if (ar.succeeded()) {
    // All servers started
    } else {
    // At least one server failed
    }
});
</code></pre><p>这些操作并发的运行，与返回的future对象关联的<code>handler</code>在上面的那些架构全部完成之后被调用。当一个操作失败了（传入的一个future被标记为失败），这个结果future也会被标记为失败。当全部的操作完成后，这个结果future成功的完成了。</p>
<p>或者，你可以传入一个future的List集合：</p>
<pre><code>CompositeFuture.all(Arrays.asList(future1, future2, future3));
</code></pre><p><code>all</code>构成方法等待知道所有的future对象都成功（或者一个失败），<code>any</code>构成方法等待第一个成功的future。<code>CompositeFuture.any</code>方法携带多个future参数（最多6个），返回一个future对象，当携带的多个future对象中有一个成功了则返回成功，如果携带的多个都失败了那么返回失败：</p>
<pre><code>CompositeFuture.any(future1, future2).setHandler(ar -&gt; {
    if (ar.succeeded()) {
        // At least one is succeeded
    } else {
        // All failed！
    }
});
</code></pre><p>也可以使用future的List集合：</p>
<pre><code>CompositeFuture.any(Arrays.asList(f1, f2, f3));
</code></pre><p><code>join</code>架构会等待直到所有的future都完成了，无论携带的future成功还是失败。<code>CompositeFuture.join</code>携带多个future参数（最多6个），返回一个future，当所有携带的future成功返回成功，当所有的future都已经执行完成并且至少有一个失败了返回失败。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">CompositeFuture</span><span class="selector-class">.join</span>(future1, future2, future3)<span class="selector-class">.setHandler</span>(ar -&gt; &#123;</div><div class="line">  <span class="selector-tag">if</span> (ar.succeeded()) &#123;</div><div class="line">    <span class="comment">// All succeeded</span></div><div class="line">  &#125; else &#123;</div><div class="line">    <span class="comment">// All completed and at least one failed</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>也可以使用future的List集合：</p>
<pre><code>CompositeFuture.join(Arrays.asList(future1, future2, future3));
</code></pre><h4 id="序列架构"><a href="#序列架构" class="headerlink" title="序列架构"></a>序列架构</h4><p>当<code>all</code>和<code>any</code>是并发架构的实现，<code>compose</code>可以被用作为链式的future（序列架构）。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">FileSystem fs = vertx.fileSystem();</div><div class="line">Future&lt;Void&gt; startFuture = Future.future();</div><div class="line"></div><div class="line">Future&lt;Void&gt; fut1 = Future.future();</div><div class="line">fs.createFile(<span class="string">"/foo"</span>, fut1.completer());</div><div class="line"></div><div class="line">fut1.compose(v -&gt; &#123;</div><div class="line">  // When the file is created (fut1),<span class="built_in"> execute </span>this:</div><div class="line">  Future&lt;Void&gt; fut2 = Future.future();</div><div class="line">  fs.writeFile(<span class="string">"/foo"</span>, Buffer.buffer(), fut2.completer());</div><div class="line"> <span class="built_in"> return </span>fut2;</div><div class="line">&#125;).compose(v -&gt; &#123;</div><div class="line">          // When the file is written (fut2),<span class="built_in"> execute </span>this:</div><div class="line">          Future&lt;Void&gt; fut3 = Future.future();</div><div class="line">          fs.move(<span class="string">"/foo"</span>, <span class="string">"/bar"</span>, fut3.completer());</div><div class="line">        &#125;,</div><div class="line">        // mark the start future as completed when all the chain has been completed,</div><div class="line">        //<span class="built_in"> or </span>mark it as failed<span class="built_in"> if </span>any step fails.</div><div class="line">        startFuture);</div></pre></td></tr></table></figure>
<p>在这个例子中，三个操作是链式的：</p>
<ol>
<li>一个文件被创建了（<code>fut1</code>）</li>
<li>写入某些东西到文件中（<code>fut2</code>）</li>
<li>移动这个文件（<code>fut3</code>）</li>
</ol>
<p>当这三步都成功了，这个最后的future(<code>startFuture</code>)将会完成并返回成功的结果。然而，如果其中一步失败了，这个最终的future也将会完成但返回失败的结果。</p>
<p>这个例子使用了：</p>
<ul>
<li><code>compose</code>：当当前的future完成了，运行提供的函数，然后返回一个future。当这个返回的future执行完成了，就表示这个架构执行完成了。</li>
<li><code>compose</code>：当当前的future完成了，运行提供的handler完成当前提供的<code>future</code>（下一个）。</li>
</ul>
<p>在第二个情形下，这个<code>Handler</code>应该执行完成，由<code>next</code>future报告是handler是否执行成功或失败。</p>
<p>你可以使用<code>completer</code>来完成一个future的操作结果或失败。这样避免了不得不像传统的那样写：<code>如果成功，然后这个future完成了或者这个future失败了</code>。</p>
<hr>
<h3 id="Verticles"><a href="#Verticles" class="headerlink" title="Verticles"></a>Verticles</h3><hr>
<p>Vert.x附带了一个简单，可扩展，类actor的部署和并发模型，你可以用它来保存你自己写的。</p>
<p>这个模型完全是可选的，Vert.x并不强迫你用这种方式创建你的应用，如果你不想的话。</p>
<p>该模型并不声称是严格的actor模型实现，但它确实具有相似之处，特别是在并发，扩展和部署方面。</p>
<p>为了使用这个模型，你把你的代码写成一些verticles。</p>
<p>Verticles是一大块的代码，需要通过Vert.x来部署。一个Vert.x实例默认包含N个event loop线程（N默认是CPU核心数*2）。可以用Vert.x支持的任何语言来写Verticles，一个单一的应用可以包含用多种语言写的verticles。</p>
<p>你可以认为一个verticle就像是一个<code>Actor Model</code>中的一个actor。</p>
<p>一个典型的应用将会由多个verticle实例组成，这些实例在同一时间运行在相同的Vert.x实例上。不同的verticle实例通过将消息发送到event bus上交流。</p>
<h4 id="写Verticles"><a href="#写Verticles" class="headerlink" title="写Verticles"></a>写Verticles</h4><p>一个Verticle类必须实现<code>Verticle</code>接口。</p>
<p>如果你想的话，你可以直接实现这个接口。但是，通常来说拓展抽象类<code>AbstractVerticle</code>是更加简单的。</p>
<p>下面就是一个verticle的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Called when verticle is deployed</span></div><div class="line">  public void start() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Optional - called when verticle is undeployed</span></div><div class="line">  public void stop() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常的，你想上面例子这样的重载这个开始方法就可以了。</p>
<p>当Vert.x部署verticle的时候，会调用它的start方法，当这个方法执行完成了，verticle将会被认为部署完成。</p>
<p>你也可以选择覆盖这个stop方法。这个方法在verticle卸载时会被Vert.x调用。当这个方法完成了，这个verticle会被认为卸载完成。</p>
<h4 id="异步的Verticle启动和停止"><a href="#异步的Verticle启动和停止" class="headerlink" title="异步的Verticle启动和停止"></a>异步的Verticle启动和停止</h4><p>某些时候，你想要在你的verticle启动的时候做一些事情，单着会花费一些时间，但是你并不想等这个verticle直到被认为部署好了。举个例子，你可能想要在开始方法中部署另外其他的verticles。</p>
<p>在start方法中，你不能阻塞并等待其他的verticle部署，因为那样将会打破Vert.x的黄金规则（永远不要阻塞它）。</p>
<p>那么，你该怎么做呢？</p>
<p>这个解决方式是通过实现一个异步的start方法。在这个版本里，这个异步的start方法带有了一个Future参数。当这个方法返回的时候，这个verticle并不会认为已经部署好了。</p>
<p>在一些时间之后，在你做完了你需要做的所有事情之后（例如：启动其他的verticles），你可以调用Future的complete方法（或fail方法）来通知你已经完成了。</p>
<p>下面是这个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  public void start(<span class="type">Future</span>&lt;<span class="type">Void</span>&gt; startFuture) &#123;</div><div class="line">    <span class="comment">// Now deploy some other verticle:</span></div><div class="line"></div><div class="line">    vertx.deployVerticle(<span class="string">"com.foo.OtherVerticle"</span>, res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">        startFuture.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        startFuture.fail(res.cause());</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相似的，这也有一个异步的stop方法。当你在verticle清除时需要占用一些时间时，你可以使用这个。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</div><div class="line"></div><div class="line">  public void start() &#123;</div><div class="line">    <span class="comment">// Do something</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void stop(<span class="type">Future</span>&lt;<span class="type">Void</span>&gt; stopFuture) &#123;</div><div class="line">    obj.doSomethingThatTakesTime(res -&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">        stopFuture.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        stopFuture.fail();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>INFO：你没有必要在verticle的stop方法中去说明卸载通过这个verticle启动的子verticle。Vert.x会自动的卸载所有的子verticle，当父verticle被卸载的时候。</p>
<h4 id="Verticle类型"><a href="#Verticle类型" class="headerlink" title="Verticle类型"></a>Verticle类型</h4><p>有三种不同类型的verticles：</p>
<p><strong>标准的verticles</strong></p>
<p>这是最普遍和有用的类型-这种类型的verticle执行时总是使用一个event loop线程。我们会在下一小节详细讨论。</p>
<p><strong>工作者verticles</strong></p>
<p>这种verticle从工作者池中获取一个线程来运行。一个实例从不会通过超过一个的线程并发执行。</p>
<p><strong>多线程的工作者Verticles</strong></p>
<p>这种Verticle从工作者池中获取一个线程来运行。一个实例可以被多个线程并发执行。</p>
<h4 id="标准的verticles"><a href="#标准的verticles" class="headerlink" title="标准的verticles"></a>标准的verticles</h4><p>标准的verticles被分配到一个event loop线程上，当它们被创建的时候这个start方法就被event loop调用了。当你从一个event loop上调用任何其他的Vert.x core API方法时，需要携带一个handler。然后Vert.x会保证这些handler会被调用，当被相同的event loop执行的时候。</p>
<p>这意味着，我们可以保证在你的verticle中的所有代码总是被同一个event loop执行（只要你不创建你自己的线程来调用它）。</p>
<p>这意味着你可以把你应用的所有代码写到一个单一的线程里，让Vert.x去操心线程及规模。不再需要担心同步和变化了，并且还可以避免许多其他情况下的竞态条件和死锁，防止普遍的手工处理的“传统”多线程应用程序开发。</p>
<h4 id="工作者verticles"><a href="#工作者verticles" class="headerlink" title="工作者verticles"></a>工作者verticles</h4><p>一个工作者verticle就像一个标准的verticle，但是它并不是由一个event loop执行的，它是通过在Vert.x工作者线程池中获取一个线程来执行。</p>
<p>工作者verticles为调用阻塞代码而设计的，因此他们并不会阻塞任何event loop。</p>
<p>如果你想要使用一个工作者verticle来运行阻塞代码，你也可以在event loop中通过executeBlocking来运行阻塞代码。</p>
<p>如果你想要部署一个工作者verticle，你需要设置<code>setWorker</code>为<code>true</code>。</p>
<pre><code>DeploymentOptions options = new DeploymentOptions().setWorker(true);
vertx.deployVerticle(&quot;com.mycompany.MyOrderProcessorVerticle&quot;, options);
</code></pre><p>工作者verticle实例从不会被Vert.x用超过一个的线程来并发执行，但是可以被多个线程在不同的时间执行。</p>
<h4 id="多线程工作者Verticles"><a href="#多线程工作者Verticles" class="headerlink" title="多线程工作者Verticles"></a>多线程工作者Verticles</h4><p>一个多线程工作者verticles就像一个普通的工作者线程verticle，但是它可以被不同的线程并发的执行。</p>
<blockquote>
<p>警告：多线程工作者Vertices是一个高级特性，大多数的应用并不需要这个。因为这些vertices里的并发性，你不得不非常的小心用标准的Java多线程编程技术来保持verticle状态的一致。</p>
</blockquote>
<h4 id="程序化部署verticles"><a href="#程序化部署verticles" class="headerlink" title="程序化部署verticles"></a>程序化部署verticles</h4><p>你可以使用一个<code>deployVerticle</code>方法来部署一个verticle，指定一个verticle名字或者你可以传入一个你自己的创建好的verticle实例。</p>
<blockquote>
<p>部署Verticle实例是Java独有的</p>
</blockquote>
<pre><code>Verticle myVerticle = new MyVerticle();
vertx.deployVerticle(myVerticle);
</code></pre><p>你也可以通过指定verticle的名字来部署verticles。</p>
<p>这个verticle名字用来查找特定的<code>VerticleFactory</code>——用来实例化真实的verticle实例。</p>
<p>不同的verticle工厂都可以用不同的语言来实例化verticles。由于众多其他的原因，例如加载服务或者从maven的运行时获取到verticles。</p>
<p>这允许你用采用任何Vert.x支持的语言来部署verticles，而不用关心这些verticles是用Vert.x支持的任何语言写的。</p>
<p>下面是一个示例：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.deployVerticle</span>(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Deploy a JavaScript verticle</span></div><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.deployVerticle</span>(<span class="string">"verticles/myverticle.js"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Deploy a Ruby verticle verticle</span></div><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.deployVerticle</span>(<span class="string">"verticles/my_verticle.rb"</span>);</div></pre></td></tr></table></figure>
<h4 id="映射verticle名字到verticle工厂的规则"><a href="#映射verticle名字到verticle工厂的规则" class="headerlink" title="映射verticle名字到verticle工厂的规则"></a>映射verticle名字到verticle工厂的规则</h4><p>当使用名字的方式部署verticles时，这个名字用来选择实际的verticle工厂实例化verticle。</p>
<p>verticle的名字可以有一个前缀——是一个字符串后跟着冒号，如果存在，那么久可以用来查找工厂。例如：</p>
<p>js:foo.js<br>groovy:com.mycompany.SomeGroovyCompiledVerticle // Use the Groovy verticle factory<br>service:com.mycompany:myorderservice // Uses the service verticle factory</p>
<p>如果没有前缀存在，Vert.x将会找一个后缀并用这个后缀来找队友的工厂。</p>
<p>foo.js // Will also use the JavaScript verticle factory<br>SomeScript.groovy // Will use the Groovy verticle factory</p>
<p>如果前缀和后缀都不存在，Vert.x将会假定它是一个Java的完全有资格的类名（FQCN），并尝试实例化它。</p>
<h4 id="Verticle工厂在哪"><a href="#Verticle工厂在哪" class="headerlink" title="Verticle工厂在哪"></a>Verticle工厂在哪</h4><p>大多数的Verticles工厂在Vert.x启动的时候从classpath加载。</p>
<p>如果你想的话，你可以使用<code>registerVerticleFactory</code>和<code>unregisterVerticleFactory</code>，程序化注册和取消注册一个verticle工厂。</p>
<h4 id="等待部署完成"><a href="#等待部署完成" class="headerlink" title="等待部署完成"></a>等待部署完成</h4><p>Verticle的部署是异步的并可能在调用部署返回之后的一段时间后完成。</p>
<p>如果你想要收到通知当部署完成的时候，你可以在部署时知道一个完成的handler：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Deployment id is: "</span> + res.<span class="literal">result</span>());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Deployment failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个完成的handler将会被传入一个包含了部署ID字符串的结果，如果部署成功了的话。</p>
<p>这个部署ID可以被在之后被使用，如果你想要卸载这次部署。</p>
<h4 id="卸载部署了的verticle"><a href="#卸载部署了的verticle" class="headerlink" title="卸载部署了的verticle"></a>卸载部署了的verticle</h4><p>部署是可以通过<code>undeploy</code>卸载的。</p>
<p>卸载对它自己来说是异步的，所以如果你想要被通知当卸载完成的时候，你可以部署一个指定完成的handler：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vertx.undeploy(deploymentID, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Undeployed ok"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Undeploy failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="指定verticle实例的数量"><a href="#指定verticle实例的数量" class="headerlink" title="指定verticle实例的数量"></a>指定verticle实例的数量</h4><p>当你使用一个verticle名字部署一个verticle时，你可以指定你想要部署verticle实例的数量：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DeploymentOptions <span class="keyword">options</span> = <span class="keyword">new</span> DeploymentOptions().setInstances(<span class="number">16</span>);</div><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, <span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>这对拓展到多核上是有用的。例如，你科恩个有一个web服务的verticle需要部署并且你的机器是是多核CPU，因此，你想部署多个实例以便充分使用上全部的核心数。</p>
<h4 id="给一个verticle传入配置文件"><a href="#给一个verticle传入配置文件" class="headerlink" title="给一个verticle传入配置文件"></a>给一个verticle传入配置文件</h4><p>配置使用JSON的格式可以传入到一个verticle里在部署的时候：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JsonObject <span class="built_in">config</span> = <span class="keyword">new</span> JsonObject().<span class="built_in">put</span>(<span class="string">"name"</span>, <span class="string">"tim"</span>).<span class="built_in">put</span>(<span class="string">"directory"</span>, <span class="string">"/blah"</span>);</div><div class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setConfig(<span class="built_in">config</span>);</div><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, options);</div></pre></td></tr></table></figure>
<p>这个配置可以通过<code>Context</code>对象或者直接使用<code>config</code>方法调用。</p>
<p>这个配置反悔了一个JSON格式的对象，所以你可以获取数据就像下面这样：</p>
<pre><code>System.out.println(&quot;Configuration: &quot; + config().getString(&quot;name&quot;));
</code></pre><h4 id="在verticle里访问环境变量"><a href="#在verticle里访问环境变量" class="headerlink" title="在verticle里访问环境变量"></a>在verticle里访问环境变量</h4><p>环境变量和系统属性是可以使用JAVA API来访问的。</p>
<pre><code>System.getProperty(&quot;prop&quot;);
System.getenv(&quot;HOME&quot;);
</code></pre><h4 id="verticle组隔离"><a href="#verticle组隔离" class="headerlink" title="verticle组隔离"></a>verticle组隔离</h4><p>默认地，Vert.x有一个平行的classpath。例如：当Vert.x部署verticles时，它是使用当前的classloader来做的，它并不创建一个新的。在大多数例子中，这是最简单、最清晰和最干净的事情。</p>
<p>然而，在一些例子中，你可能想在你的应用中部署一个verticle，它的类和其他的是隔离的。</p>
<p>这可能是个例子，例如，如果你想要在一个Vert.x实例中部署有着相同类名字两个不同版本的verticle，或者你想要两个不同的verticles使用不同的jar库版本。</p>
<p>当使用一个隔离组时，你需要提供一个你想要隔离的类名字的集合，将它放到<code>setIsolatedClasses</code>中。这可以是进入到一个全的类名，如<code>com.mycompany.myproject.engine.MyClass</code>，也可以是通配符的方式，可以匹配包或子包里的多个类，如：<code>com.mycompany.myproject.*</code>将会匹配在包<code>com.mycompany.myproject</code>下的任何类或任何子包。</p>
<p>请记住只有这个匹配的类会被隔离，任何其他的类都会通过当前的classloader加载。</p>
<p>额外的classpath也可以通过<code>setExtraClasspath</code>来设置，如果你想要加载的类或资源不在当前主classpath里。</p>
<blockquote>
<p>警告 使用这个特性时需要小心。Class-loaders可能会导致bug，并且会让调试变得困难，除其他外。</p>
</blockquote>
<p>下面是一个使用隔离组隔离verticle部署的例子：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DeploymentOptions <span class="keyword">options</span> = <span class="keyword">new</span> DeploymentOptions().setIsolationGroup(<span class="string">"mygroup"</span>);</div><div class="line"><span class="keyword">options</span>.setIsolatedClasses(Arrays.<span class="keyword">asList</span>(<span class="string">"com.mycompany.myverticle.*"</span>,</div><div class="line">                   <span class="string">"com.mycompany.somepkg.SomeClass"</span>, <span class="string">"org.somelibrary.*"</span>));</div><div class="line">vertx.deployVerticle(<span class="string">"com.mycompany.myverticle.VerticleClass"</span>, <span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>Verticles在部署的时候可以是高可用生效。在这个的内容中，当一个verticle部署在vert.x实力上后突然的死掉了，这个verticle会被集群里其他的vert.x实例重新部署。</p>
<p>为了运行一个启用高可用的verticle，只需要添加上<code>-ha</code>即可：</p>
<pre><code>vertx run my-verticle.js -ha
</code></pre><p>当启用了高可用是，不在需要添加<code>-cluster</code>。</p>
<p>关于高可用特性和配置的更多详细的信息在<a href="High Availability and Fail-Over">High Availability and Fail-Over</a>小节中。</p>
<h4 id="从命令行运行verticles"><a href="#从命令行运行verticles" class="headerlink" title="从命令行运行verticles"></a>从命令行运行verticles</h4><p>你可以在你的Maven或Gradle项目中通过添加Vert.x core库的dependency这个支持的方式直接使用Vert.x。</p>
<p>如果你原意，你可以可以直接在命令行这里执行Vert.x verticles。</p>
<p>为了这样做，你需要下载并按照整个Vert.x发行版，并且将<code>bin</code>目录添加到<code>PATH</code>环境变量里。也要确定环境变量中你有Java 8JDK。</p>
<blockquote>
<p>JDK是被需要来支持即时编译Java代码</p>
</blockquote>
<p>现在你就可以使用<code>vertx run</code>命令运行你的verticles。下面这就是例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Run a JavaScript verticle</span></div><div class="line">vertx <span class="keyword">run</span><span class="bash"> my_verticle.js</span></div><div class="line"></div><div class="line"><span class="comment"># Run a Ruby verticle</span></div><div class="line">vertx <span class="keyword">run</span><span class="bash"> a_n_other_verticle.rb</span></div><div class="line"></div><div class="line"><span class="comment"># Run a Groovy script verticle, clustered</span></div><div class="line">vertx <span class="keyword">run</span><span class="bash"> FooVerticle.groovy -cluster</span></div></pre></td></tr></table></figure>
<p>你甚至可以运行Java源代码而不用先编译。</p>
<pre><code>vertx run SomeJavaSource.java
</code></pre><p>Vert.x在运行前将会即时编译Java源码文件。这是真正有益于快速原型verticles和很好的演示。在执行的时候不再需要先设置Maven或Gradle环境。</p>
<p>当在命令行里执行vertx，为获取全部的信息有大量的选项可用，在命令行里输入<code>vertx</code>即可。</p>
<h4 id="Vert-x退出原因"><a href="#Vert-x退出原因" class="headerlink" title="Vert.x退出原因"></a>Vert.x退出原因</h4><p>Vert.x实例维护的线程并不是一个后台线程，所以他们将防止JVM退出。</p>
<p>如果你正在嵌入Vert.x并且你已经完成了它，你需要调用<code>close</code>方法结束它。</p>
<p>这将会关掉所有里面的线程池及关闭其他资源，并允许JVM退出。</p>
<h4 id="Context对象"><a href="#Context对象" class="headerlink" title="Context对象"></a>Context对象</h4><p>当Vert.x提供了一个时间给handler或调用Verticle的start或stop方法时，这个执行就已经被关联到了一个<code>Context</code>。通常的一个context是一个event-loop context并捆绑给一个特定的event loop线程。所以，content的执行总是会出现在完全相同的event loop线程上。在工作者verticle的例子中，运行阻塞代码，一个工作者context将会被关联到从工作者线程池获取到的执行的这个线程。</p>
<p>为获取这个context，使用<code>getOrCreateContext</code>方法：</p>
<pre><code>Context context = vertx.getOrCreateContext();
</code></pre><p>如果当前线程有一个context对象关联到它了，它会复用这个context对象。如果没有一个新的context实例被创建。你可以测试你获取到的这个context的类型：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Context context = vertx.getOrCreateContext();</div><div class="line"><span class="keyword">if</span> (context.isEventLoopContext()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context attached to Event Loop"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isWorkerContext()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context attached to Worker Thread"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isMultiThreadedWorkerContext()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context attached to Worker Thread - multi threaded worker"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (! Context.isOnVertxThread()) &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Context not attached to a thread managed by vert.x"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你获取到一个context对象，你可以在这个context上一步的运行代码。换言之，你提交了一个任务，之后最终将会被同一个context运行：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vertx.getOrCreateContext<span class="function"><span class="params">()</span>.<span class="title">runOnContext</span><span class="params">( (v) -&gt; &#123;</span></span></div><div class="line">  System.out.println(<span class="string">"This will be executed asynchronously in the same context"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当有多个handler运行在同一个context里时，他们可能想要更新数据。这个context对象提供了方法来存储和获取共享在这个context里的数据。例如，运行<code>runOnContext</code>可以让你传入数据到某个特定的动作上：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final <span class="built_in">Context</span> <span class="built_in">context</span> = vertx.getOrCreateContext()<span class="comment">;</span></div><div class="line"><span class="built_in">context</span>.put(<span class="string">"data"</span>, <span class="string">"hello"</span>)<span class="comment">;</span></div><div class="line"><span class="built_in">context</span>.runOnContext((v) -&gt; &#123;</div><div class="line">  String hello = <span class="built_in">context</span>.get(<span class="string">"data"</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>context对象允许你使用<code>config</code>方法访问verticle配置。检查传入配置到verticle小节获取配置更详细的信息。</p>
<h4 id="执行周期动作和延时动作"><a href="#执行周期动作和延时动作" class="headerlink" title="执行周期动作和延时动作"></a>执行周期动作和延时动作</h4><p>这是很普遍的，在Vert.x里想要获取一个延时或周期性的动作。</p>
<p>在标准的verticles里你不能简单的使用线程休眠来达到演示的效果，因为这将会阻塞event loop线程。</p>
<p>你需要使用Vert.x timers来代替。Timers可以被设置为一次性或周期性。两者我们都将会讨论。</p>
<p><strong>一次性的Timers</strong></p>
<p>在一个确定好的延迟时间后一次调用事件handler，延迟时间以微妙表示。</p>
<p>激活一个定时器一次，使用<code>setTimer</code>方法，传入一个延迟时间和一个handler即可。</p>
<pre><code>long timerID = vertx.setTimer(1000, id -&gt; {
    System.out.println(&quot;And one second later this is printed&quot;);
});

System.out.println(&quot;First this is printed&quot;);
</code></pre><p>这个返回值是一个独特的timer id，在之后可以用来取消这个timer。这个handler也传入了这个timer id。</p>
<p><strong>周期性的Timers</strong></p>
<p>你可以使用<code>setPeriodic</code>方法设置一个周期性触发的定时器。</p>
<p>将有一个等于该周期的首次延迟。</p>
<p><code>setPeriodic</code>有一个独特的timer id返回值。可以在之后用来取消这个周期性定时器。</p>
<p>这个参数也传入到了定时器时间handler里：</p>
<p>记住这个定时器会在一个基本的周期后触发。如果你的周期性处理占据了一个大量的时间来执行，你的定时器时间可以连续执行或者更糟：堆一起运行。</p>
<p>在这种情形下，你可以考虑使用<code>setTimer</code>来代替。一旦你的处理完成了，你可以设置下一个定时器。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> timerID = vertx.setPeriodic(<span class="number">1000</span>, id -&gt; &#123;</div><div class="line">  System.out.<span class="built_in">println</span>(<span class="string">"And every second this is printed"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"First this is printed"</span>);</div></pre></td></tr></table></figure>
<p><strong>取消定时器</strong></p>
<p>要取消一个周期性的定时器，调用<code>cancelTimer</code>方法并制定一个timer id即可。例如：</p>
<pre><code>vertx.cancelTimer(timerID);
</code></pre><p><strong>在verticles里自动清除</strong></p>
<p>如果你在一个verticles里创建了一个定时器，那么这个定时器将会被自动关闭当这个verticle被卸载的时候。</p>
<h4 id="Verticle工作池"><a href="#Verticle工作池" class="headerlink" title="Verticle工作池"></a>Verticle工作池</h4><p>verticle使用Vert.x工作者池来执行阻塞动作，如：<code>executeBlocking</code>或工作者verticle。</p>
<p>一个不同的工作者池可以在部署的选项里指定：</p>
<pre><code>vertx.deployVerticle(&quot;the-verticle&quot;, new DeploymentOptions().setWorkPoolName(&quot;the-specific-pool&quot;));
</code></pre><hr>
<h3 id="The-Event-Bus"><a href="#The-Event-Bus" class="headerlink" title="The Event Bus"></a>The Event Bus</h3><hr>
<p>event bus是Vert.x的神经系统。</p>
<p>每个Vert.x实例都有一个单一的event bus实例，通过<code>eventBus</code>方法获取到它。</p>
<p>event bus允许你的应用中不同的部分之间通信，不用在乎这些部分使用什么语言写的、是否是在同一个vert.x实例中或者在不同的vert.x实例。</p>
<p>它甚至可以被桥接以允许运行在客户端的JavaScript在同一事件总线上通信。</p>
<p>event bus形成跨越多个服务器节点和多个浏览器的分布式对等消息传递系统。</p>
<p>event bus支持发布和订阅、点对点、请求和回复消息传递。</p>
<p>event bus API是很简单的。基本的调用时注册一个handler、取消注册一个handler、发送和发布消息。</p>
<p>首先从一些理论开始：</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>地址</strong></p>
<p>event bus发送消息到一个地址上。</p>
<p>Vert.x没有花哨的寻址方案。在Vert.x里一个地址就是一个简单的字符串。任何字符串都是有效的。然而，使用某种方案是明智的。例如，使用英文句号来划分命名空间。</p>
<p>一些有效的地址的例子：europe.news.feed1，acme.games.pacman，sausages，and X。</p>
<p><strong>Handlers</strong></p>
<p>消息是在handler里接收的。你可以在地址上注册一个handler。</p>
<p>大多数不同的handlers可以被注册到相同的地址上。</p>
<p>一个单一的handler可以注册在多个不同的地址上。</p>
<p><strong>发布和订阅消息</strong></p>
<p>event bus支持发布消息。</p>
<p>消息需要被发布到一个地址上。发布意味着分发消息给全部注册到这个地址上的handler。</p>
<p>这和发布/订阅消息传递模式有点像。</p>
<p><strong>点对点和请求-回复消息传递</strong></p>
<p>event bus也支持点对点消息传递。</p>
<p>消息会被发送到一个地址上。 Vert.x然后将它路由到在该地址注册的handlers之一。</p>
<p>如果那有超过一个的handler注册在低智商，将使用非严格的循环算法选择一个。</p>
<p>点对点的消息传递，在发送消息的时候可以指定一个可选的回复handler。</p>
<p>当消息被一个接受者收到了，然后被处理，这个接受者可以选择决定回复这个消息。如果接受者回复了消息，那么一个回复handler将会被调用。</p>
<p>当这个回复发送会给发送者，它依旧可以回复消息。这可以无限重复，并允许在两个不同的verticles之间建立对话。</p>
<p>这个普遍的消息传递模式被称为请求-回复模式。</p>
<p><strong>尽力交付</strong></p>
<p>Vert.x尽它最大的努力交付消息，并不会无故的扔掉消息。这被称为尽力交付。</p>
<p>然而，在全部的失败情形或部分event bus中，消息仍然可能会丢失。</p>
<p>如果你的应用关心这些丢失消息，你应该编写你的handler为idempotent，并等你的发送者恢复后再重试。</p>
<p><strong>消息类型</strong></p>
<p>开箱即用的Vert.x允许你使用任何原始的、简单的类型，如String或buffers，都可以作为消息被发送。</p>
<p>然而，这是很方便和普遍的方式，在Vert.x里以JSON格式发送消息。</p>
<p>JSON在所有的Vert.x支持的语言都很容易创建、阅读和解析。所以，它已经变成了Vert.x的一种通用格式。</p>
<p>当然如果你不想使用JSON格式，Vert.x也不会强迫你使用。</p>
<p>event bus非常灵活，并且还支持通过event bus发送任意对象。你可以通过给要发送的对象定义一个编解码器来实现。</p>
<h4 id="Event-Bus-API"><a href="#Event-Bus-API" class="headerlink" title="Event Bus API"></a>Event Bus API</h4><p>让我们来跳到API。</p>
<p><strong>获取到event bus</strong></p>
<p>你可以像接下来这样获取到一个event bus的引用：</p>
<pre><code>EventBus eb = vertx.eventBus();
</code></pre><p>对每个Vert.x实例来说，有且只有一个event bus实例。</p>
<p><strong>注册Handlers</strong></p>
<p>注册一个handler最简单的方法就是使用<code>consumer</code>。下面就是一个例子：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">EventBus eb = vertx.eventBus()<span class="comment">;</span></div><div class="line"></div><div class="line">eb.consumer(<span class="string">"news.uk.sport"</span>, message -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"I have received a message: "</span> + message.<span class="keyword">body());</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>当一个消息到达了你的handler，你的handler将会被调用，然后传入这个<code>message</code>。</p>
<p>调用consumer()方法返回了一个<code>MessageConsumer</code>对象实例。</p>
<p>这个对象随后可以用来取消注册handler，或者作为流使用handler。</p>
<p>或者你可以使用<code>consumer</code>来返回一个没有设置handler的MessageConsumer对象。然后像这样来设置一个handler。例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventBus eb = vertx.eventBus()<span class="comment">;</span></div><div class="line"></div><div class="line">MessageConsumer&lt;String&gt; consumer = eb.consumer(<span class="string">"news.uk.sport"</span>)<span class="comment">;</span></div><div class="line">consumer.handler(message -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"I have received a message: "</span> + message.<span class="keyword">body());</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>当注册一个handler到一个集群event bus，这会花费一些时间来注册到集群的所有节点。</p>
<p>如果你想要收到通知，当注册已经全部结束了，你可以在MessageConsumer对象上注册一个<code>completion handler</code>。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">consumer.completionHandler(res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"The handler registration has reached all nodes"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Registration failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>取消注册Handlers</strong></p>
<p>取消注册一个handler，调用<code>unregister</code>。</p>
<p>如果是在一个集群上的event bus，取消注册会花费一些时间遍历到所有的节点，如果你想要接收到通知，当取消注册完成后，使用<code>unregister</code>。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">consumer.unregister(res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"The handler un-registration has reached all nodes"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Un-registration failed!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>发布消息</strong></p>
<p>发布消息时很简单的。只需要使用<code>publish</code>并指定要发布的地址就可以了。</p>
<pre><code>eventBus.publish(&quot;news.uk.sport&quot;, &quot;Yay! Someone kicked a ball&quot;);
</code></pre><p>消息就会被交付到所有注册了这个news.uk.sport地址上。</p>
<p><strong>发送消息</strong></p>
<p>发送消息将导致在接收消息的地址处仅注册一个处理程序。这是点对点消息模式。以非严格的循环方式选择handler。</p>
<p>你可以使用<code>send</code>发送一个消息</p>
<pre><code>eventBus.send(&quot;news.uk.sport&quot;, &quot;Yay! Someone kicked a ball&quot;);
</code></pre><p><strong>在消息上设置标题</strong></p>
<p>发送到event bus的消息可以包含头。</p>
<p>这可以通过提供一个指定的<code>DeliveryOptions</code>参数，当发送或发布消息时：</p>
<pre><code>DeliveryOptions options = new DeliveryOptions();
options.addHeader(&quot;some-header&quot;, &quot;some-value&quot;);
eventBus.send(&quot;news.uk.sport&quot;, &quot;Yay! Someone kicked a ball&quot;, options);
</code></pre><p><strong>消息排序</strong></p>
<p>Vert.x将会交付消息到任何一个特定的handler里，其顺序和从任何一个特定的发送者一致。</p>
<p><strong>消息对象</strong></p>
<p>这个对象在消息handler里接收到的是一个<code>Message</code>对象。</p>
<p>这个消息<code>body</code>和这个被发送或发布的对象是相符的。</p>
<p>通过<code>headers</code>消息的头是可用的。</p>
<p><strong>确认消息和发送回复</strong></p>
<p>当event bus尝试使用<code>send</code>方法发送消息给一个在event bus上注册的<code>MessageConsumer</code>对象。</p>
<p>在一些情形下，这对发送者是有用的，当知道了消费者接收到了消息并按加工了它。</p>
<p>为了确认消息已经被消费者加工过了，可以通过调用<code>reply</code>方法回复一个消息。</p>
<p>当这种情况发生时，它导致一个回复被发送回发送者，并且回复处理程序被调用与回复。</p>
<p>一个例子将会让这段话更加清晰：</p>
<p>接收者：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MessageConsumer&lt;<span class="keyword">String</span>&gt; consumer = eventBus.consumer(<span class="string">"news.uk.sport"</span>);</div><div class="line">consumer.handler(<span class="keyword">message</span> -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"I have received a message: "</span> + <span class="keyword">message</span>.body());</div><div class="line">  <span class="keyword">message</span>.reply(<span class="string">"how interesting!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>发送者：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eventBus.send(<span class="string">"news.uk.sport"</span>, <span class="string">"Yay! Someone kicked a ball across a patch of grass"</span>, ar -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Received reply: "</span> + ar.result().<span class="keyword">body</span>());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个回复可以包含一个消息体——能够携带有用的信息。</p>
<p>什么“处理”实际上意味着应用程序定义，完全取决于消息消费者做什么，而不是Vert.x event bus本身知道或关心的东西。</p>
<p>一些例子：</p>
<ul>
<li>一个简单的消息消费者实现了一个返回当天的时间的服务，这个服务将会确认这个在的回复体里包含了当天时间的消息。</li>
<li>一个消息消费者实现了一个持久队列，可能会返回<code>true</code>以此确认消息成功持久化存储了，返回<code>false</code>表示没有持久化存储。</li>
<li>一个消息消费者执行一个订单，可能会返回<code>true</code>来确认订单已经执行，然后就可以从数据库中删除了。</li>
</ul>
<p><strong>发送超时</strong></p>
<p>当发送一个消息带有回复的handler时，你可以在<code>DeliveryOptions</code>指定一个超时时间。</p>
<p>如果在这个超时时间内没有收到回复，这个回复handler将会调用失败。</p>
<p>默认的超时时间是30秒。</p>
<p><strong>发送失败</strong></p>
<p>消息发送失败可能是有其他原因导致的，包括：</p>
<ul>
<li>没有可用的handler发送消息。</li>
<li>接受者明确的用<code>fail</code>表示消息接收失败。</li>
</ul>
<p>在所有的情形中，回复的handler会用调用特定的失败。</p>
<p><strong>消息编解码</strong></p>
<p>你可以发送任何你喜欢的对象到event bus，如果你为它定义并注册了一个<code>message codec</code>。</p>
<p>消息编解码器有一个名字，你可以在<code>DeliverOptions</code>指定这个名字当发送或发布消息的时候：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eventBus.registerCodec(myCodec);</div><div class="line"></div><div class="line">DeliveryOptions <span class="keyword">options</span> = <span class="keyword">new</span> DeliveryOptions().setCodecName(myCodec.name());</div><div class="line"></div><div class="line">eventBus.send(<span class="string">"orders"</span>, <span class="keyword">new</span> MyPOJO(), <span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>如果你总是想要为一个特定的类型使用相同的编解码器，那么你可以注册一个默认的编解码器，然后你就可以不用在每次发送的<code>DeliveryOptions</code>里去指定编解码器了。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eventBus.registerDefaultCodec(<span class="type">MyPOJO</span>.<span class="keyword">class</span>, myCodec);</div><div class="line"></div><div class="line">eventBus.send(<span class="string">"orders"</span>, <span class="function"><span class="keyword">new</span> <span class="title">MyPOJO</span>());</span></div></pre></td></tr></table></figure>
<p>你可以用<code>unregisterCodec</code>取消注册一个消息编解码器。</p>
<p>消息解码器并不总是需要对相同类型编码和解码。例如，你可以写一个允许发送一个MyPOJO类对象的解码器，但是当消息送到这个handler时，这个消息是会被作为一个MyOtherPOJO类到达。</p>
<p><strong>集群Event Bus</strong></p>
<p>Event Bus并不仅仅存在一个单一的Vert.x实例中。通过在网络上将不同的Vert.x实例聚合在一起，他们可以形成一个单一的分布式事件总线。</p>
<p><strong>集群编程</strong></p>
<p>如果您以编程方式创建Vert.x实例，则通过将Vert.x实例配置为集群来获取集群事件总线；</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VertxOptions <span class="keyword">options</span> = <span class="keyword">new</span> VertxOptions();</div><div class="line">Vertx.clusteredVertx(<span class="keyword">options</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    Vertx vertx = res.result();</div><div class="line">    EventBus eventBus = vertx.eventBus();</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed: "</span> + res.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>你应该要确保在你的classpath中有一个<code>ClusterManager</code>实现，例如，默认地是<code>HazelcastClusterManager</code>。</p>
<p><strong>集群命令行</strong></p>
<p>你可以在命令行中运行Vert.x集群</p>
<pre><code>vertx run my-verticle.js -cluster
</code></pre><h4 id="在verticles里自动清除"><a href="#在verticles里自动清除" class="headerlink" title="在verticles里自动清除"></a>在verticles里自动清除</h4><p>如果你在verticles内部注册了event bus handlers，这些handlers将会被自动取消注册当这个verticle被卸载时。</p>
<hr>
<h3 id="配置event-bus"><a href="#配置event-bus" class="headerlink" title="配置event bus"></a>配置event bus</h3><hr>
<p>Event bus是可以被配置的。大概event bus是集群时，这是特别有用的。基于event bus使用TCP连接来发送和接收消息，<code>EventBusOptions</code>可以让你配置所有关于TCP连接的部分。当event bus扮演一个服务器和客户端，相关的配置为<code>NetClientOptions</code>和<code>NetServerOptions</code>。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">VertxOptions <span class="keyword">options</span> = <span class="keyword">new</span> VertxOptions()</div><div class="line">    .setEventBusOptions(<span class="keyword">new</span> EventBusOptions()</div><div class="line">        .setSsl(<span class="keyword">true</span>)</div><div class="line">        .setKeyStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"keystore.jks"</span>).setPassword(<span class="string">"wibble"</span>))</div><div class="line">        .setTrustStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"keystore.jks"</span>).setPassword(<span class="string">"wibble"</span>))</div><div class="line">        .setClientAuth(ClientAuth.REQUIRED)</div><div class="line">    );</div><div class="line"></div><div class="line">Vertx.clusteredVertx(<span class="keyword">options</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    Vertx vertx = res.result();</div><div class="line">    EventBus eventBus = vertx.eventBus();</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed: "</span> + res.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>前一个代码片段描述了通过event bus怎么使用一个SSL连接，代替了普通的TCP连接。</p>
<p><strong>警告</strong>：要在集群模式下强制实施安全性，必须将集群管理器配置为使用加密或强制执行安全性。想要更深入的了解，请翻阅到集群管理部分。</p>
<p>event bus配置在所有的集群节点上都是要保持一致。</p>
<p><code>EventBusOptions</code>也允许你指定event bus是否是一个集群、端口或者主机。你只需要设置<code>setClustered</code>、<code>getClusterHost</code>、<code>getClusterPort</code>。</p>
<p>当在容器中使用时，你可能需要配置Public主机和端口：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">VertxOptions <span class="keyword">options</span> = <span class="keyword">new</span> VertxOptions()</div><div class="line">    .setEventBusOptions(<span class="keyword">new</span> EventBusOptions()</div><div class="line">        .setClusterPublicHost(<span class="string">"whatever"</span>)</div><div class="line">        .setClusterPublicPort(<span class="number">1234</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">Vertx.clusteredVertx(<span class="keyword">options</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    Vertx vertx = res.result();</div><div class="line">    EventBus eventBus = vertx.eventBus();</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"We now have a clustered event bus: "</span> + eventBus);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed: "</span> + res.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>不像其他的语言，Java没有JSON的原生类支持，所以我们提供了两个类，使得在Vert.x应用程序中处理JSON有点容易。</p>
<h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><p><code>JsonObject</code>类表示JSON对象。</p>
<p>一个JSON对象基本上就是一个map，key为string类型，value为JSON支持的三种类型之一（string, number, boolean）。</p>
<p>JSON对象也支持null值。</p>
<p><strong>创建JSON对象</strong></p>
<p>用默认的构造方法可以创建一个空的JSON对象。</p>
<p>你可以从String类型表示形式创建JSON对象，像这样</p>
<pre><code>String jsonString = &quot;{\&quot;foo\&quot;:\&quot;bar\&quot;}&quot;;
JsonObject object = new JsonObject(jsonString);
</code></pre><p><strong>将条目放入到JSON对象</strong></p>
<p>使用<code>put</code>方法可以把值放入到一个JSON对象中。</p>
<p>这个方法可以被链式的调用，因为流式API：</p>
<pre><code>JsonObject object = new JsonObject();
object.put(&quot;foo&quot;, &quot;bar&quot;).put(&quot;num&quot;, 123).put(&quot;mybool&quot;, true);
</code></pre><p><strong>从JSON对象中获取值</strong></p>
<p>你可以从一个JSON对象中获取到一个值，你着急需要使用<code>getXXX</code>方法。例如：</p>
<pre><code>String val = jsonObject.getString(&quot;some-key&quot;);
int intVal = jsonObject.getInteger(some-other-key);
</code></pre><p><strong>重新编码JSON对象转为String</strong></p>
<p>你可以使用<code>encode</code>方法重新编码对象，使其转为一个String格式。</p>
<h4 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h4><p><code>JsonArray</code>类表示JSON数组。</p>
<p>一个JSON数组是值（string, number, boolean）的序列。</p>
<p>JSON数组可以包含null值。</p>
<p><strong>创建一个JSON数组</strong></p>
<p>可以用默认的构造方法创建一个空的JSON数组对象。</p>
<p>你可以从String表示形式创建JSON数组，就像这样：</p>
<pre><code>String jsonString = &quot;[\&quot;foo\&quot;,\&quot;bar\&quot;]&quot;;
JsonArray array = new JsonArray(jsonString);
</code></pre><p><strong>添加条目到JSON对象里</strong></p>
<p>你可以通过<code>add</code>方法添加条目到一个JSON数组对象中。</p>
<pre><code>JsonArray array = new JsonArray();
array.add(&quot;foo&quot;).add(123).add(false);
</code></pre><p><strong>从JSON数组中获取值</strong></p>
<p>你可以是用<code>getXXX</code>方法从JSON数组中获取值，例如：</p>
<pre><code>String val = array.getString(0);
Integer intVal = array.getInteger(1);
Boolean boolean = array.getBoolean(2);
</code></pre><p><strong>重新编码将JSON数组转为String</strong></p>
<p>你可以使用<code>encode</code>方法重新编码JSON数组，将其转变为String格式。</p>
<hr>
<h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><hr>
<p>大多数数据在Vert.x里都是是使用buffers传递。</p>
<p>一个buffer是一个0或多个字节的序列，可以从中读取或写入并且根据需要自动扩展以容纳写入到里面的任何字节。你可能想到buffer是一个智能字节数组。</p>
<h4 id="创建Buffers"><a href="#创建Buffers" class="headerlink" title="创建Buffers"></a>创建Buffers</h4><p>Buffer可以通过一个静态方法<code>Buffer.buffer</code>创建。</p>
<p>Buffer可以初始化为string数组或byte数组，或空的buffer也可以被创建。</p>
<p>下面是创建buffer的一些例子：</p>
<p>创建一个新的空buffer：</p>
<pre><code>Buffer buffer = Buffer.buffer();
</code></pre><p>根据一个String创建一个buffer，这个String将会在buffer中用UTF-8重新编码。</p>
<pre><code>Buffer buffer = Buffer.buffer(&quot;some string&quot;);
</code></pre><p>根据一个String创建一个buffer，并制定一个编码格式：</p>
<pre><code>Buffer buffer = Buffer.buffer(&quot;some string&quot;, &quot;UTF-16&quot;);
</code></pre><p>根据一个byte数组创建一个buffer</p>
<pre><code>byte[] bytes = new byte[]{1, 3, 5};
Buffer buff = Buffer.buffer(bytes);
</code></pre><p>创建一个buffer可以在初始化时制定大小。如果你知道你的buffer将会有一个确定的数量被写入，你在创建buffer时可以指定这个大小。这会让这个buffer在初始化的时候分配到足够的内存，并且比当数据被写入它时多次自动调整大小的缓冲器更高效。</p>
<p>注意，这种方式创建的buffer是空的。这并不会在创建buffer时用0来填充这指定的大小。</p>
<pre><code>Buffer buff = Buffer.buffer(10000);
</code></pre><h4 id="写入到一个Buffer"><a href="#写入到一个Buffer" class="headerlink" title="写入到一个Buffer"></a>写入到一个Buffer</h4><p>Buffer有两种写入的方式：追加和随机访问。在任意情况下，buffer为了包含这些字节数总是会自动的扩展大小。用buffer时不可能获取到一个<code>IndexOutOfBoundsException</code>。</p>
<p><strong>追加写入</strong></p>
<p>为了把数据以追加的方式写入到buffer里，你需要用<code>appendXXX</code>方法。Append方法存在多种追加的类型。</p>
<p><code>appendXXX</code>方法的返回值就是buffer本身，所以这可以写成链式的：</p>
<pre><code>Buffer buff = Buffer.buffer();
buff.appendInt(123).appendString(&quot;Hello\n&quot;);
socket.write(buff);
</code></pre><p><strong>随机写入</strong></p>
<p>你也可以把数据写入到buffer的指定位置，通过使用<code>setXXX</code>方法。Set方法存在多种数据类型。所有的set方法都可以把索引位置作为第一个参数，索引位置表示在这个buffer中从这个位置开始写入数据。</p>
<p>buffer为了容纳数据总是会自动扩展大小。</p>
<pre><code>Buffer buff = Buffer.buffer();

buff.setInt(1000, 123);
buff.setString(0, &quot;hello&quot;);
</code></pre><h4 id="从Buffer中读取内容"><a href="#从Buffer中读取内容" class="headerlink" title="从Buffer中读取内容"></a>从Buffer中读取内容</h4><p>从buffer中读取数据使用<code>getXXX</code>方法。Get方法存在多种数据类型。这些方法的第一个参数是buffer里的一个索引，表示从这个位置获取数据。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Buffer </span><span class="keyword">buff </span>= <span class="keyword">Buffer.buffer();</span></div><div class="line">for (int i = <span class="number">0</span><span class="comment">; i &lt; buff.length(); i += 4) &#123;</span></div><div class="line">  System.out.println(<span class="string">"int value at "</span> + i + <span class="string">" is "</span> + <span class="keyword">buff.getInt(i));</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用无符号数"><a href="#使用无符号数" class="headerlink" title="使用无符号数"></a>使用无符号数</h4><p>无符号数可以被读取或追加或设置到一个buffer中，使用<code>getUnsignedXXX</code>、<code>appendUnsignedXXX</code>、<code>setUnsignedXXX</code>方法。这有益于优化实现最小化带宽消耗的网络协议编解码器。</p>
<p>在接下来的例子中，值200被设置到特定的位置仅用了一个字节长度。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Buffer </span><span class="keyword">buff </span>= <span class="keyword">Buffer.buffer(128);</span></div><div class="line">int pos = <span class="number">15</span><span class="comment">;</span></div><div class="line"><span class="keyword">buff.setUnsignedByte(pos, </span>(<span class="keyword">short) </span><span class="number">200</span>)<span class="comment">;</span></div><div class="line">System.out.println(<span class="keyword">buff.getUnsignedByte(pos));</span></div></pre></td></tr></table></figure>
<p>控制台会显示200。</p>
<h4 id="Buffer长度"><a href="#Buffer长度" class="headerlink" title="Buffer长度"></a>Buffer长度</h4><p>使用<code>length</code>来获取buffer的长度。buffer的长度是buffer中字节的最大数量+1。</p>
<h4 id="复制Buffer"><a href="#复制Buffer" class="headerlink" title="复制Buffer"></a>复制Buffer</h4><p>使用<code>copy</code>方法可以复制一个buffer。</p>
<h4 id="分片buffer（Slicing-buffer）"><a href="#分片buffer（Slicing-buffer）" class="headerlink" title="分片buffer（Slicing buffer）"></a>分片buffer（Slicing buffer）</h4><p>一个切片buffer是在原始buffer上得到的一个新的buffer。例如，它并不复制基本的数据。使用<code>slice</code>是创建了一个分片的buffer。</p>
<h4 id="buffer复用"><a href="#buffer复用" class="headerlink" title="buffer复用"></a>buffer复用</h4><p>在将一个buffer写入到一个socket或者一个类似的地方，这个buffer将不能被复用。</p>
<hr>
<h3 id="写TCP服务器和客户端"><a href="#写TCP服务器和客户端" class="headerlink" title="写TCP服务器和客户端"></a>写TCP服务器和客户端</h3><hr>
<p>Vert.x让你很简单的编写一个无阻塞的TCP客户端和服务器。</p>
<h4 id="创建一个TCP服务器"><a href="#创建一个TCP服务器" class="headerlink" title="创建一个TCP服务器"></a>创建一个TCP服务器</h4><p>创建TCP服务器最近爱的的方式就是全部使用默认的选项，就像接下来这样：</p>
<pre><code>NetServer server = vertx.createNetServer();
</code></pre><h4 id="配置一个TCP服务器"><a href="#配置一个TCP服务器" class="headerlink" title="配置一个TCP服务器"></a>配置一个TCP服务器</h4><p>如果你不想要这个默认的，当创建一个服务器是，你可以传入一个<code>NetServerOptions</code>实例来配置它：</p>
<pre><code>NetServerOptions options = new NetServerOptions.setPort(4321);
NetServer server = vertx.createNetServer(options);
</code></pre><h4 id="服务器开始监听"><a href="#服务器开始监听" class="headerlink" title="服务器开始监听"></a>服务器开始监听</h4><p>为了告诉服务器监听到达的请求，你可以用其中一种<code>listen</code>方法。</p>
<p>为了告诉服务器监听主机和端口，如在选项中指定：</p>
<pre><code>NetServer server = vertx.createNetServer();
server.listen();
</code></pre><p>或者在调用listen方法时指定主机和端口，忽略在选项中的配置：</p>
<pre><code>NetServer server = vertx.createNetServer();
server.listen(1234, &quot;localhost&quot;);
</code></pre><p>默认的主机是<code>0.0.0.0</code>，这意味着监听所有可用的地址，同时默认的端口是0，这是个特殊的端口会教服务器去找一个本地没有使用的随机端口来监听。</p>
<p>实际上绑定端口是异步的，所以这个服务器可能实际上没有绑定上，直到一段时间后调用的listen方法获得了返回。</p>
<p>如果你想要收到通知，当服务器已经开始监听了，你可以在<code>listen</code>方法里提供一个handler调用。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetServer server = vertx.createNetServer();</div><div class="line">server.<span class="built_in">listen</span>(<span class="number">1234</span>, <span class="string">"localhost"</span>, res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now listening!"</span>);</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Failed to bind!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="监听一个随机端口"><a href="#监听一个随机端口" class="headerlink" title="监听一个随机端口"></a>监听一个随机端口</h4><p>如果0被用作监听端口，这个服务器将会找到一个没使用的随机端口来监听。</p>
<p>为了找到服务器监听的真实端口你可以调用<code>actualPort</code>。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetServer server = vertx.createNetServer();</div><div class="line">server.<span class="built_in">listen</span>(<span class="number">0</span>, <span class="string">"localhost"</span>, res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now listening on actual port: "</span> + server.actualPort());</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Failed to bind!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="有连接到达时获取到通知"><a href="#有连接到达时获取到通知" class="headerlink" title="有连接到达时获取到通知"></a>有连接到达时获取到通知</h4><p>当一个连接到达时，想要获得通知，你需要设置一个<code>connectHandler</code>：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NetServer <span class="keyword">server</span> = vertx.createNetServer();</div><div class="line"><span class="keyword">server</span>.connectHandler(socket -&gt; &#123;</div><div class="line">  <span class="comment">// Handle the connection in here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当一个链接到达时，handler会用<code>NetSocket</code>实例调用。</p>
<p>实际的连接是一个类socket接口，让你读取和写入数据也可以做很多其他的事情就如关闭socket。</p>
<h4 id="从socket读取数据"><a href="#从socket读取数据" class="headerlink" title="从socket读取数据"></a>从socket读取数据</h4><p>为了从socket读取收，你需要在socket上设置一个<code>handler</code>。</p>
<p>这个handler会用一个<code>Buffer</code>的实例调用，在socket上每次有数据到达的时候。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServer server = vertx.createNetServer()<span class="comment">;</span></div><div class="line">server.connectHandler(socket -&gt; &#123;</div><div class="line">  socket.handler(<span class="keyword">buffer </span>-&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"I received some bytes: "</span> + <span class="keyword">buffer.length());</span></div><div class="line">  &#125;)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h4 id="写数据到一个socket"><a href="#写数据到一个socket" class="headerlink" title="写数据到一个socket"></a>写数据到一个socket</h4><p>你可以通过<code>write</code>方法写入数据到socket。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Buffer <span class="built_in">buffer</span> = Buffer.<span class="built_in">buffer</span>().appendFloat(<span class="number">12.34</span>f).appendInt(<span class="number">123</span>);</div><div class="line">socket.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</div><div class="line"></div><div class="line"><span class="comment">// Write a string in UTF-8 encoding</span></div><div class="line">socket.<span class="built_in">write</span>(<span class="string">"some data"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Write a string using the specified encoding</span></div><div class="line">socket.<span class="built_in">write</span>(<span class="string">"some data"</span>, <span class="string">"UTF-16"</span>);</div></pre></td></tr></table></figure>
<p>写入操作是异步的，可能不会出现直到调用写入方法收到返回。</p>
<h4 id="关闭handler"><a href="#关闭handler" class="headerlink" title="关闭handler"></a>关闭handler</h4><p>如果你想收到通知当关闭一个socket时，你可以在socket上设置<code>closeHandler</code>：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">socket.<span class="keyword">closeHandler(v </span>-&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"The socket has been closed"</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>你可以设置一个<code>exceptionHandler</code>来接收任何发生在这个socket上的异常。</p>
<h4 id="event-bus写入handler"><a href="#event-bus写入handler" class="headerlink" title="event bus写入handler"></a>event bus写入handler</h4><p>每个socket自动注册一个handler到event bus上，当这个handler上收到了任何buffer时，它将buffer写入给它自己。</p>
<p>这能让你写数据到socket上，通过这个handler将buffer数据发送到不同的verticle中甚至不同的Vert.x实例中。</p>
<p>这个handler的地址通过<code>writeHandlerID</code>方法设置。</p>
<h4 id="本地和远程地址"><a href="#本地和远程地址" class="headerlink" title="本地和远程地址"></a>本地和远程地址</h4><p><code>NetSocket</code>的本地地址可以使用<code>localAddress</code>获取。</p>
<p><code>NetSocket</code>的远程地址可以使用<code>remoteAddress</code>获取。</p>
<h4 id="从classpath发送文件或资源"><a href="#从classpath发送文件或资源" class="headerlink" title="从classpath发送文件或资源"></a>从classpath发送文件或资源</h4><p>文件和classpath的资源可以使用<code>sendFile</code>直接被写入到socket里。这是一种很高效的发送文件的方式，因为只要操作系统支持，它就可以被操作系统内核直接处理。</p>
<p>请看从classpath服务文件那一章节了解限制及解决方式或禁用它。</p>
<pre><code>socket.sendFile(&quot;myfile.dat&quot;);
</code></pre><h4 id="流socket"><a href="#流socket" class="headerlink" title="流socket"></a>流socket</h4><p><code>NetSocket</code>实例也是<code>ReadStream</code>和<code>WriteStream</code>实例，所以他们可以用来导出数据或者从其他读取和写入流。</p>
<p>查看流和导出章节获取更多信息。</p>
<h4 id="升级连接到SSL-TLS"><a href="#升级连接到SSL-TLS" class="headerlink" title="升级连接到SSL/TLS"></a>升级连接到SSL/TLS</h4><p>一个不是SSL/TLS连接可以使用<code>upgradeToSsl</code>升级到SSL/TLS连接。</p>
<p>服务器或客户端必须配置为SSL/TLS才能正确的工作。请查看SSL/TLS章节获取更多信息。</p>
<h4 id="关闭一个TCP服务器"><a href="#关闭一个TCP服务器" class="headerlink" title="关闭一个TCP服务器"></a>关闭一个TCP服务器</h4><p>调用<code>close</code>方法关闭服务器。关闭服务器的时候回关闭所有打开的连接和释放服务器所有的资源。</p>
<p>这个关闭方法实际上是异步的，并且可能没有完成直到一段后收到了回调。如果你想要被通知，当实际上关闭完成了的时候，你可以传入一个handler。</p>
<p>这个handler将会被调用，当完全关闭的时候。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server.<span class="built_in">close</span>(res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now closed"</span>);</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"close failed"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="在verticles自动清除"><a href="#在verticles自动清除" class="headerlink" title="在verticles自动清除"></a>在verticles自动清除</h4><p>如果你在verticle里面创建TCP服务器和客户端，这些服务器和客户端将会自动的关闭当这个verticle关闭的时候。</p>
<h4 id="扩展和分享TCP服务器"><a href="#扩展和分享TCP服务器" class="headerlink" title="扩展和分享TCP服务器"></a>扩展和分享TCP服务器</h4><p>任何TCP服务器的handlers总是执行在相同的event loop线程上。</p>
<p>这意味着如果你运行了在多核处理器上运行了一个服务器，你仅有一个实例被部署了，并且在你的服务器上最多只有一个核心被使用了。</p>
<p>为了让你的服务器能够使用多个核心，你需要部署这个服务器多个实例。</p>
<p>你可以在你的代码中编程实例化更多实例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  NetServer server = vertx.createNetServer();</div><div class="line">  server.connectHandler(socket -&gt; &#123;</div><div class="line">    socket.handler(<span class="built_in">buffer</span> -&gt; &#123;</div><div class="line">      <span class="comment">// Just echo back the data</span></div><div class="line">      socket.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  server.<span class="built_in">listen</span>(<span class="number">1234</span>, <span class="string">"localhost"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者，如果你使用verticles，你只需要在命令行使用<code>-instancces</code>选项简单的部署多个服务器实例verticle：</p>
<pre><code>vertx run com.mycompany.MyVerticle -instances 10
</code></pre><p>或者在程序中部署你的verticle</p>
<pre><code>DeploymentOptions options = new DeploymentOptions().setInstances(10);
vertx.deployVerticle(&quot;com.mycompany.MyVerticle&quot;, options);
</code></pre><p>一旦你这样做了，你会发现这个回声服务器和之前工作的一样，但是你机器上全部的核心都可以被利用上并且更多的工作可以被处理。</p>
<p>在这一点上，你可能会问你自己“你怎么可能有多个服务器监听在相同的主机和端口？当然，你会得到端口冲突只要你尝试和部署多个实例。”</p>
<p>Vert.x在这里施了一点点小魔法。</p>
<p>当与现有的服务器相同的主机和端口上部署另一个服务器时，它实际上并不尝试创建一个新的服务器去监听主机和端口。</p>
<p>相反，在里面它会保持一个单一的服务器，并且随着传入连接的到达，它以循环的方式将其分配给任何连接的handlers。</p>
<p>因此Vert.x TCP服务器可以扩展到超过可用的核心数，而每个实例保持单线程。</p>
<h4 id="创建一个TCP客户端"><a href="#创建一个TCP客户端" class="headerlink" title="创建一个TCP客户端"></a>创建一个TCP客户端</h4><p>最简单的方式创建一个TCP客户端，全部使用默认的选项就像下面这样：</p>
<pre><code>NetClient client = vertx.createNetClient();
</code></pre><h4 id="配置TCP客户端"><a href="#配置TCP客户端" class="headerlink" title="配置TCP客户端"></a>配置TCP客户端</h4><p>如果你不想要默认的配置，你可以在创建的实例的时候传入一个<code>NetClientOptions</code>对象进行配置：</p>
<pre><code>NetClientOptions options = new NetClientOptions().setConnectTimeout(10000);
NetClient client = vertx.createNetClient(options);
</code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>为了连接到服务器你需要使用<code>connect</code>方法，指定端口和服务器主机。并且调用一个handler，当连接成功时返回一个包含了<code>NetSocket</code>的结果或者当连接失败时返回失败。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setConnectTimeout(<span class="number">10000</span>);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div><div class="line">client.connect(<span class="number">4321</span>, <span class="string">"localhost"</span>, res -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Connected!"</span>);</div><div class="line">    NetSocket socket = res.result();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Failed to connect: "</span> + res.cause().getMessage());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="尝试配置连接"><a href="#尝试配置连接" class="headerlink" title="尝试配置连接"></a>尝试配置连接</h4><p>一个客户端可以配配置为自动重连服务器在发生了不能连接的时间后。这个配置通过<code>setReconnectInterval</code>和<code>setReconnectAttempts</code>完成。</p>
<blockquote>
<p>当前Vert.x将不会尝试重连如果连接失败，间隔性尝试重连仅应用于初始化连接。</p>
</blockquote>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">NetClientOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetClientOptions</span>().</span></div><div class="line">    <span class="title">setReconnectAttempts</span>(<span class="number">10</span>).</div><div class="line">    <span class="title">setReconnectInterval</span>(<span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="title">NetClient</span> <span class="title">client</span> = <span class="title">vertx</span>.<span class="title">createNetClient</span>(options);</div></pre></td></tr></table></figure>
<p>默认地，多连接尝试是被禁用了。</p>
<h4 id="记录网络活动"><a href="#记录网络活动" class="headerlink" title="记录网络活动"></a>记录网络活动</h4><p>为了调试，网络活动应该被记录下来：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().setLogActivity(true);</div><div class="line"></div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().setLogActivity(true);</div><div class="line"></div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>网络活动被Netty记录了，使用的级别为<code>DEBUG</code>、名字为<code>io.netty.handler.logging.LoggingHandler</code>。当记录网络活动时，下面这些你需要记住：</p>
<ul>
<li>日志并不是Vert.x做的，而是由Netty</li>
<li>这并不是一个生产环境的属性</li>
</ul>
<p>Netty会尝试用这个顺序定位下面日志的实现：</p>
<ul>
<li>slf4j</li>
<li>log4j</li>
<li>JDK</li>
</ul>
<p>在类路径上存在slf4j和log4j类足以获取日志记录实现。</p>
<p>这个日志实现可以强制指定为一个特定的实现，通过直接设置Netty的内部日志实现：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Force logging to SLF4J</span></div><div class="line"><span class="selector-tag">InternalLoggerFactory</span><span class="selector-class">.setDefaultFactory</span>(Log4JLoggerFactory.INSTANCE);</div></pre></td></tr></table></figure>
<h4 id="配置服务器和客户端使用SSL-TLS"><a href="#配置服务器和客户端使用SSL-TLS" class="headerlink" title="配置服务器和客户端使用SSL/TLS"></a>配置服务器和客户端使用SSL/TLS</h4><p>TCP客户端和服务器可以被配置为使用TLS-早先的TLS版本就是大家熟知的SSL。</p>
<p>服务器和客户端的API是相同的不管SSL/TLS是否使用了，它能够通过配置<code>NetClientOptions</code>或<code>NetServerOptions</code>实例用来创建服务器和客户端。</p>
<p><strong>在服务器上启用SSL/TLS</strong></p>
<p>用<code>ssl</code>方法启用SSL/TLS。</p>
<p>默认是关闭的。</p>
<p><strong>为服务器指定密钥和证书</strong></p>
<p>SSL/TLS服务器通常需要提供证书给客户端，以便客户端确认服务器的身份。</p>
<p>证书和密钥在服务器端有几种配置的方法：</p>
<p>第一个方法是通过指定一个Java key-store的位置，Java key-store包含了证书和私钥。</p>
<p>Java key stores可以使用JDK附属的实用程序keytool管理。</p>
<p>key store的密码也应该提供：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setKeyStoreOptions(</div><div class="line">    <span class="keyword">new</span> JksOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/server-keystore.jks"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetServer server = vertx.createNetServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>或者你可以读取key store内容到你自己的buffer里并直接提供：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-keystore.jks"</span>);</div><div class="line"><span class="attribute">JksOptions jksOptions</span> = new JksOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setKeyStoreOptions(jksOptions);</div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的密钥和证书，通常以<code>.pfx</code>或<code>.p12</code>结尾，也可以通过和JKS key stores类似的方式加载：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setPfxKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PfxOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/server-keystore.pfx"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetServer server = vertx.createNetServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用Buffer来配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-keystore.pfx"</span>);</div><div class="line"><span class="attribute">PfxOptions pfxOptions</span> = new PfxOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPfxKeyCertOptions(pfxOptions);</div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>提供服务器私钥和证书的另一种方式是把他们分开成以<code>.pem</code>结尾的文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setPemKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PemKeyCertOptions().</div><div class="line">        setKeyPath(<span class="string">"/path/to/your/server-key.pem"</span>).</div><div class="line">        setCertPath(<span class="string">"/path/to/your/server-cert.pem"</span>)</div><div class="line">);</div><div class="line">NetServer server = vertx.createNetServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-key.pem"</span>);</div><div class="line"><span class="attribute">Buffer myCertAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-cert.pem"</span>);</div><div class="line"><span class="attribute">PemKeyCertOptions pemOptions</span> = new PemKeyCertOptions().</div><div class="line">    setKeyValue(myKeyAsABuffer).</div><div class="line">    setCertValue(myCertAsABuffer);</div><div class="line"><span class="attribute">NetServerOptions options</span> = new NetServerOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPemKeyCertOptions(pemOptions);</div><div class="line"><span class="attribute">NetServer server</span> = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>记住pem的配置，私钥并没有被加密。</p>
<p><strong>指定服务器的信任</strong></p>
<p>SSL/TLS服务器可以使用一个证书验证来确认客户端的身份。</p>
<p>服务器端证书验证有多种配置方式：</p>
<p>Java trust stores可以通过JDK附属的实用程序keytool管理。</p>
<p>trust store的密钥需要被提供：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>ClientAuth(ClientAuth.REQUIRED).</div><div class="line">    <span class="built_in">set</span>TrustStoreOptions(</div><div class="line">        new JksOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.jks"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>或者你可以读取trust store到你自己的buffer中，然后直接提供：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="type">Buffer</span> myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.jks"</span>);</div><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setTrustStoreOptions</span>(</div><div class="line">        new <span class="type">JksOptions</span>().</div><div class="line">            <span class="title">setValue</span>(myTrustStoreAsABuffer).</div><div class="line">            <span class="title">setPassword</span>("password-of-your-truststore")</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的证书通常以<code>.pfx</code>或<code>.p12</code>结尾，也可以通过和JKS trust store类似的方式加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>ClientAuth(ClientAuth.REQUIRED).</div><div class="line">    <span class="built_in">set</span>PfxTrustOptions(</div><div class="line">        new PfxOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.pfx"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="type">Buffer</span> myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.pfx"</span>);</div><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setPfxTrustOptions</span>(</div><div class="line">        new <span class="type">PfxOptions</span>().</div><div class="line">            <span class="title">setValue</span>(myTrustStoreAsABuffer).</div><div class="line">            <span class="title">setPassword</span>("password-of-your-truststore")</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p>另一种方式提供服务器验证是使用一系列的<code>.pem</code>文件。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setPemTrustOptions</span>(</div><div class="line">        new <span class="type">PemTrustOptions</span>().</div><div class="line">            <span class="title">addCertPath</span>("/path/to/your/server-ca.pem")</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="type">Buffer</span> myCaAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/server-ca.pfx"</span>);</div><div class="line"><span class="type">NetServerOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetServerOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setClientAuth</span>(<span class="type">ClientAuth</span>.<span class="type">REQUIRED</span>).</div><div class="line">    <span class="title">setPemTrustOptions</span>(</div><div class="line">        new <span class="type">PemTrustOptions</span>().</div><div class="line">            <span class="title">addCertValue</span>(myCaAsABuffer)</div><div class="line">    );</div><div class="line"><span class="title">NetServer</span> <span class="title">server</span> = <span class="title">vertx</span>.<span class="title">createNetServer</span>(options);</div></pre></td></tr></table></figure>
<p><strong>客户端启用SSL/TLS</strong></p>
<p>网络客户端配置使用SSL是很简单的。使用SSL和使用标准的sockets又完全相同的API。</p>
<p>在NetClient上调用函数setSSL(true)就可以启用SSL了。</p>
<p><strong>客户端信任配置</strong></p>
<p>在客户端如果<code>trustALL</code>方法被设置为true，那么客户端将会信任所有的服务器证书。这个连接依旧会被加密，但是这种模式是脆弱的，因为有中间人攻击的存在，你不能确定你连接的是谁。用这个模式需要很小心。默认这个值是false。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().</div><div class="line">    setSsl(<span class="keyword">true</span>).</div><div class="line">    setTrustAll(<span class="keyword">true</span>);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>如果<code>trustAll</code>没有设置，那么客户端trust store就必须配置，并要包含客户端信任的服务器证书。</p>
<p>默认地，客户端主机验证被禁用了。为了启用主机验证，在你的客户端上需要设置算法（仅支持HTTPS和LDAPS）：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">        setSsl(true).</div><div class="line">        setHostnameVerificationAlgorithm(<span class="string">"HTTPS"</span>);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>和服务器配置一样，客户端trust也有几种配置的方案：</p>
<p>第一种方法是指定Java trust-store的位置，Java trust-store包含了证书权限。</p>
<p>这仅是标准的Java key store，和服务器端的key store是一样的。客户端trust store的位置可以通过<code>jks options</code>对象的<code>path</code>函数设置。如果一个服务器在连接的时候提供了一个证书，这个证书并不被客户端的trust store信任，那么这个连接将不会成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetClientOptions options = new NetClientOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>TrustStoreOptions(</div><div class="line">        new JksOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.jks"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetClient client = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myTrustStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.jks"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setTrustStoreOptions(</div><div class="line">        new JksOptions().</div><div class="line">            setValue(myTrustStoreAsABuffer).</div><div class="line">            setPassword(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的证书，通常是以<code>.pfx</code>和<code>.p12</code>结尾，也可以通过和JKS trust stores相似的方式加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetClientOptions options = new NetClientOptions().</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>PfxTrustOptions(</div><div class="line">        new PfxOptions().</div><div class="line">            <span class="built_in">set</span>Path(<span class="string">"/path/to/your/truststore.pfx"</span>).</div><div class="line">            <span class="built_in">set</span>Password(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line">NetClient client = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>用Buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myTrustStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/truststore.pfx"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPfxTrustOptions(</div><div class="line">        new PfxOptions().</div><div class="line">            setValue(myTrustStoreAsABuffer).</div><div class="line">            setPassword(<span class="string">"password-of-your-truststore"</span>)</div><div class="line">    );</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>另一种提供服务器证书的方法是使用一个<code>.pem</code>文件的列表。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().</div><div class="line">    setSsl(<span class="keyword">true</span>).</div><div class="line">    setPemTrustOptions(</div><div class="line">        <span class="keyword">new</span> PemTrustOptions().</div><div class="line">            addCertPath(<span class="string">"/path/to/your/ca-cert.pem"</span>)</div><div class="line">    );</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myTrustStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/ca-cert.pem"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPemTrustOptions(</div><div class="line">        new PemTrustOptions().</div><div class="line">            addCertValue(myTrustStoreAsABuffer)</div><div class="line">    );</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p><strong>为客户端指定密钥和证书</strong></p>
<p>如果服务器端请求客户端验证，那么客户端必须在建立连接的时候给服务器提供自己的证书。客户端证书有下面几种配置方式：</p>
<p>第一种方法，通过指定包含了密钥和证书的Java key-store位置。这也是一个常规的Java key store。客户端keystore的位置也可以通过<code>jks options</code>的<code>path</code>方法设置。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setSsl(<span class="keyword">true</span>).setKeyStoreOptions(</div><div class="line">    <span class="keyword">new</span> JksOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/client-keystore.jks"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-keystore.jks"</span>);</div><div class="line"><span class="attribute">JksOptions jksOptions</span> = new JksOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setKeyStoreOptions(jksOptions);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>PKCS#12格式的证书通常以<code>.pfx</code>或<code>.p12</code>结尾，也可以通过和JKS key store类似的方式加载：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setSsl(<span class="keyword">true</span>).setPfxKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PfxOptions().</div><div class="line">        setPath(<span class="string">"/path/to/your/client-keystore.pfx"</span>).</div><div class="line">        setPassword(<span class="string">"password-of-your-keystore"</span>)</div><div class="line">);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyStoreAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-keystore.pfx"</span>);</div><div class="line"><span class="attribute">PfxOptions pfxOptions</span> = new PfxOptions().</div><div class="line">    setValue(myKeyStoreAsABuffer).</div><div class="line">    setPassword(<span class="string">"password-of-your-keystore"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPfxKeyCertOptions(pfxOptions);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>另一种提供分离的客户端私钥和证书的方式是使用<code>.pem</code>文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> NetClientOptions().setSsl(<span class="keyword">true</span>).setPemKeyCertOptions(</div><div class="line">    <span class="keyword">new</span> PemKeyCertOptions().</div><div class="line">        setKeyPath(<span class="string">"/path/to/your/client-key.pem"</span>).</div><div class="line">        setCertPath(<span class="string">"/path/to/your/client-cert.pem"</span>)</div><div class="line">);</div><div class="line">NetClient client = vertx.createNetClient(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myKeyAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-key.pem"</span>);</div><div class="line"><span class="attribute">Buffer myCertAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/client-cert.pem"</span>);</div><div class="line"><span class="attribute">PemKeyCertOptions pemOptions</span> = new PemKeyCertOptions().</div><div class="line">    setKeyValue(myKeyAsABuffer).</div><div class="line">    setCertValue(myCertAsABuffer);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setPemKeyCertOptions(pemOptions);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>记住在pem的配置中，私钥是没有被加密的。</p>
<p><strong>吊销证书</strong></p>
<p>信任是可以配置的，通过使用一个证书吊销列表（CRL）吊销的证书将不再被信任。使用<code>crlPath</code>配置crl的路径：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">NetClientOptions</span> options = <span class="function"><span class="keyword">new</span> <span class="title">NetClientOptions</span>().</span></div><div class="line">    <span class="title">setSsl</span>(true).</div><div class="line">    <span class="title">setTrustStoreOptions</span>(trustOptions).</div><div class="line">    <span class="title">addCrlPath</span>("/path/to/your/crl.pem");</div><div class="line"><span class="title">NetClient</span> <span class="title">client</span> = <span class="title">vertx</span>.<span class="title">createNetClient</span>(options);</div></pre></td></tr></table></figure>
<p>用buffer配置也是支持的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Buffer myCrlAsABuffer</span> = vertx.fileSystem().readFileBlocking(<span class="string">"/path/to/your/crl.pem"</span>);</div><div class="line"><span class="attribute">NetClientOptions options</span> = new NetClientOptions().</div><div class="line">    setSsl(true).</div><div class="line">    setTrustStoreOptions(trustOptions).</div><div class="line">    addCrlValue(myCrlAsABuffer);</div><div class="line"><span class="attribute">NetClient client</span> = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p><strong>配置加密套件</strong></p>
<p>默认地，TLS配置将会使在JVM里运行的Vert.x的加密套件。这个加密套件可以被配置启用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    addEnabledCipherSuite(<span class="string">"ECDHE-RSA-AES128-GCM-SHA256"</span>).</div><div class="line">    addEnabledCipherSuite(<span class="string">"ECDHE-ECDSA-AES128-GCM-SHA256"</span>).</div><div class="line">    addEnabledCipherSuite(<span class="string">"ECDHE-RSA-AES256-GCM-SHA384"</span>).</div><div class="line">    addEnabledCipherSuite(<span class="string">"CDHE-ECDSA-AES256-GCM-SHA384"</span>);</div><div class="line">NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>加密套件可以通过<code>NetServerOptions</code>和<code>NetClientOptions</code>配置。</p>
<p><strong>配置TLS协议版本</strong></p>
<p>默认地，TLS配置可以使用这些协议版本：SSLv2Hello，TLSv1，TLSv1.1，TLSv1.2。协议版本可以被明确的配置，增加可用协议：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = new NetServerOptions().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    addEnabledSecureTransportProtocol(<span class="string">"TLSv1.1"</span>).</div><div class="line">    addEnabledSecureTransportProtocol(<span class="string">"TLSv1.2"</span>);</div><div class="line">    NetServer server = vertx.createNetServer(options);</div></pre></td></tr></table></figure>
<p>协议版本可以通过<code>NetServerOptions</code>和<code>NetClientOptions</code>配置。</p>
<p><strong>SSL engine</strong></p>
<p>engine实现是可以被配置，用OpenSSL来代替JDK实现。OpenSSL比JDK engine提供了更好的实现和CPU使用率，以及与JDK版本独立性。</p>
<p>要使用的engine选项是</p>
<ul>
<li><code>getSslEngineOptions</code>选项当它被设置的时候</li>
<li>要不然<code>JdkSSLEngineOptions</code></li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NetServerOptions options = <span class="keyword">new</span> <span class="type">NetServerOptions</span>().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions);</div><div class="line"></div><div class="line"><span class="comment">// Use JDK SSL engine explicitly</span></div><div class="line">options = <span class="keyword">new</span> <span class="type">NetServerOptions</span>().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    setJdkSslEngineOptions(<span class="keyword">new</span> <span class="type">JdkSSLEngineOptions</span>());</div><div class="line"></div><div class="line"><span class="comment">// Use OpenSSL engine</span></div><div class="line">options = <span class="keyword">new</span> <span class="type">NetServerOptions</span>().</div><div class="line">    setSsl(<span class="literal">true</span>).</div><div class="line">    setKeyStoreOptions(keyStoreOptions).</div><div class="line">    setOpenSslEngineOptions(<span class="keyword">new</span> <span class="type">OpenSSLEngineOptions</span>());</div></pre></td></tr></table></figure>
<p><strong>应用层协议协商</strong></p>
<p>ALPN是TLS扩展的一部分，全称是应用层协议协商。它用在了HTTP/2：在TLS握手阶段客户端给出一个它支持的应用层协议列表，服务器告诉客户端它支持哪一个协议。</p>
<p>Java 8并不支持开箱即用的ALPN，所以ALPN应该通过其他的方式启用：</p>
<ul>
<li>OpenSSL支持</li>
<li>Jetty-ALPN支持</li>
</ul>
<p>要使用的engine选项是</p>
<ul>
<li><code>getSslEngineOptions</code>选项当设置的时候</li>
<li><code>JdkSSLEngineOptions</code>当ALPN可用于JDK时</li>
<li><code>OpenSSLEngineOptions</code>当ALPN可用于OpenSSL时</li>
</ul>
<p><strong>OpenSSL ALPN支持</strong></p>
<p>OpenSSL提供原生的ALPN支持。</p>
<p>OpenSSL需要配置<code>setOpenSslEngineOptions</code>和在classpath里使用<code>netty-tcnative</code>jar包。使用tcnnative可能需要OpenSSL已经安装在你的操作系统上，具体取决于实现。</p>
<p><strong>Jetty-ALPN</strong></p>
<p>Jetty-ALPN是一个小jar包覆盖了一些Java8发行版的类，以便于支持ALPN。</p>
<p>这个JVM必须在<code>bootclasspath</code>带有<em>alpn-boot-${version}.jar</em>启动：</p>
<pre><code>-Xbootclasspath/p:/path/to/alpn-boot${version}.jar
</code></pre><p>${version}依赖于JVM的版本。例如，8.1.7.v20160121用于OpenJDK1.8.0u74。完整的列表在Jetty-ALPN页面可看到。</p>
<p>这个主要的缺点就是以言语JVM的版本。</p>
<p>为了解决这个问题，可以使用Jetty ALPN agent替代。这个代理是一个JVM代理将会为JVM运行它时选择正确的ALPN版本：</p>
<pre><code>-javaagent:/path/to/plan/agent
</code></pre><h4 id="使用代理进行客户端连接"><a href="#使用代理进行客户端连接" class="headerlink" title="使用代理进行客户端连接"></a>使用代理进行客户端连接</h4><p><code>NetClient</code>支持HTTP/1.x、SOCKS4a或SOCKS5代理。</p>
<p>代理可以在<code>NetClientOptions</code>里配置，通过设置一个包含了代理类型、主机名、端口和可选的用户名和密码<code>ProxyOptions</code>对象。</p>
<p>下面是一个例子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NetClientOptions options = new NetClientOptions()</div><div class="line">    .<span class="built_in">set</span>ProxyOptions(new ProxyOptions().<span class="built_in">set</span>Type(ProxyType.SOCKS5)</div><div class="line">        .<span class="built_in">set</span>Host(<span class="string">"localhost"</span>).<span class="built_in">set</span>Port(<span class="number">1080</span>)</div><div class="line">        .<span class="built_in">set</span>Username(<span class="string">"username"</span>).<span class="built_in">set</span>Password(<span class="string">"secret"</span>));</div><div class="line">NetClient client = vertx.createNetClient(options);</div></pre></td></tr></table></figure>
<p>DNS解析总是在代理服务器上完成的，为了实现一个SOCKS4客户端代理的功能，它必须在本地解析DNS地址。</p>
<hr>
<h3 id="编写HTTP服务器和客户端"><a href="#编写HTTP服务器和客户端" class="headerlink" title="编写HTTP服务器和客户端"></a>编写HTTP服务器和客户端</h3><hr>
<p>Vert.x让你编写无阻塞的HTTP客户端和服务器是很简单的。</p>
<p>Vert.x支持HTTP/1.0、HTTP/1.1、HTTP/2协议。</p>
<p>HTTP基本的API和HTTP/1.x、HTTP/2是一样的，具体的API特性可用于处理HTTP/2协议。</p>
<h4 id="创建HTTP服务器"><a href="#创建HTTP服务器" class="headerlink" title="创建HTTP服务器"></a>创建HTTP服务器</h4><p>最简单的方式创建一个HTTP服务器，就是全是用默认的选项，像接下来这样：</p>
<pre><code>HttpServer server = vertx.createHttpServer();
</code></pre><h4 id="配置HTTP服务器"><a href="#配置HTTP服务器" class="headerlink" title="配置HTTP服务器"></a>配置HTTP服务器</h4><p>如果你不想要默认的配置，你可以在创建的时候通过传入<code>HttpServerOptions</code>实例来配置：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpServerOptions options</span> = new HttpServerOptions().setMaxWebsocketFrameSize(1000000);</div><div class="line"></div><div class="line"><span class="attribute">HttpServer server</span> = vertx.createHttpServer(options);</div></pre></td></tr></table></figure>
<h4 id="配置HTTP-2服务器"><a href="#配置HTTP-2服务器" class="headerlink" title="配置HTTP/2服务器"></a>配置HTTP/2服务器</h4><p>Vert.x支持HTTP/2 over TLS <code>h2</code>和TCP <code>h2c</code>。</p>
<ul>
<li><code>h2</code>标识通过ALPN在TLS上使用HTTP/2协议。</li>
<li><code>h2c</code>标识在TCP上使用明文HTTP/2协议，这种连接通过HTTP / 1.1升级请求或直接建立。</li>
</ul>
<p>为了处理<code>h2</code>请求，TLS必须通过<code>setUseAlpn</code>启用：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HttpServerOptions <span class="keyword">options</span> = <span class="keyword">new</span> HttpServerOptions()</div><div class="line">    .setUseAlpn(<span class="keyword">true</span>)</div><div class="line">    .setSsl(<span class="keyword">true</span>)</div><div class="line">    .setKeyStoreOptions(<span class="keyword">new</span> JksOptions().setPath(<span class="string">"/path/to/my/keystore"</span>));</div><div class="line"></div><div class="line">HttpServer server = vertx.createHttpServer(<span class="keyword">options</span>);</div></pre></td></tr></table></figure>
<p>ALPN是TLS的延展部分，用于在客户端和服务器开始交换数据之前协商协议。</p>
<p>客户端不支持ALPN，依旧能够使用一个经典的SSL握手。</p>
<p>ALPN通常会协商<code>h2</code>协议，当然<code>Http/1.1</code>协议也可以被使用，如果服务器和客户端决定这样。</p>
<p>为了处理<code>h2c</code>请求，TLS必须禁用，服务器将会升级到HTTP/2，在任何请求HTTP/1.1想要升级到HTTP/2。它将会直接接受一个用<code>PRI * HTTP/2.0\r\nSM\r\n</code>开头的<code>h2c</code>连接。</p>
<blockquote>
<p>大多数浏览器不支持<code>h2c</code>，所以服务web网站是，你应该使用<code>h2</code>而不是<code>h2c</code>。</p>
</blockquote>
<p>当一个服务器接受一个HTTP/2连接，它发送它的<code>初始化设置</code>给客户端。这个设置定义了客户端怎么使用连接，默认的服务器初始化设置为：</p>
<ul>
<li><code>getMaxConcurrentStreams</code>：100是HTTP/2 RFC文档推荐的。</li>
<li>给其他的默认HTTP/2设置值</li>
</ul>
<h4 id="记录服务器网络活动"><a href="#记录服务器网络活动" class="headerlink" title="记录服务器网络活动"></a>记录服务器网络活动</h4><p>为了调试的目的，网络活动可以被记录。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpServerOptions options</span> = new HttpServerOptions().setLogActivity(true);</div><div class="line"></div><div class="line"><span class="attribute">HttpServer server</span> = vertx.createHttpServer(options);</div></pre></td></tr></table></figure>
<p>查看记录网络活动章节获取详细信息。</p>
<h4 id="请求到了后获取到通知"><a href="#请求到了后获取到通知" class="headerlink" title="请求到了后获取到通知"></a>请求到了后获取到通知</h4><p>要让服务器监听到达的请求，你可以使用一个<code>listen</code>方法。</p>
<p>要让服务器监听主机和端口，在选项中指定即可：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServer server = vertx.createHttpServer()<span class="comment">;</span></div><div class="line">server.listen()<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>或者在调用listen的时候指定主机和端口，从而覆盖选项中配置的：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServer <span class="keyword">server</span> = vertx.createHttpServer();</div><div class="line"><span class="keyword">server</span>.listen(<span class="number">8080</span>, <span class="string">"myhost.com"</span>);</div></pre></td></tr></table></figure>
<p>默认的主机是<code>0.0.0.0</code>，意味着监听所有可用的地址，并且默认的端口是80.</p>
<p>实际的绑定是异步的所以服务器可能没有实际绑定上，直到一段时间过后这个listen方法返回了。</p>
<p>如果你想要接收到通知，当服务器在实际监听的时候，你可以提供一个handler给<code>listen</code>调用。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HttpServer server = vertx.createHttpServer();</div><div class="line">server.<span class="built_in">listen</span>(<span class="number">8080</span>, <span class="string">"myhost.com"</span>, res -&gt; &#123;</div><div class="line">  <span class="built_in">if</span> (res.succeeded()) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Server is now listening!"</span>);</div><div class="line">  &#125; <span class="built_in">else</span> &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Failed to bind!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="请求到达时获取到通知"><a href="#请求到达时获取到通知" class="headerlink" title="请求到达时获取到通知"></a>请求到达时获取到通知</h4><p>为了获取到通知当一个请求到达时，你需要设置一个<code>requestHandler</code>：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HttpServer <span class="keyword">server</span> = vertx.createHttpServer();</div><div class="line"><span class="keyword">server</span>.requestHandler(request -&gt; &#123;</div><div class="line">  <span class="comment">// Handle the request in here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>当一个请求到达时，这个请求handler被调用并传入一个<code>HttpServerRequest</code>实例。这个对象代表了服务器端的HTTP请求。</p>
<p>这个handler被调用，当请求头完全被读取的时候。</p>
<p>如果请求包含请求体，这个请求体将会在这个请求handler被调用一段时间后到达。</p>
<p>这个服务器请求对象允许你获取<code>uri</code>、<code>path</code>、<code>params</code>和<code>headers</code>，以及在里面的其他东西。</p>
<p>每个服务器请求对象都关联到了一个服务器回复对象。你使用<code>response</code>来获取一个<code>HttpServerResponse</code>对象的引用。</p>
<p>这有一个简单的例子，服务器处理一个请求并回复给它一个hello world。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">vertx</span><span class="selector-class">.createHttpServer</span>()<span class="selector-class">.requestHandler</span>(request -&gt; &#123;</div><div class="line">  <span class="selector-tag">request</span><span class="selector-class">.response</span>()<span class="selector-class">.end</span>(<span class="string">"Hello world"</span>);</div><div class="line">&#125;)<span class="selector-class">.listen</span>(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p><strong>请求版本</strong></p>
<p>HTTP的版本可以在请求中用<code>version</code>获取到。</p>
<p><strong>请求方法</strong></p>
<p>使用<code>method</code>获取HTTP请求的方法。（例如：它可能是GET、POST、PUT、DELETE、HEAD、OPTION等）。</p>
<p><strong>请求URI</strong></p>
<p>使用<code>uri</code>从请求中获取URI。</p>
<p>注意，这是在HTTP请求中传递的实际URI，它几乎总是相对的URI。</p>
<p>URI是定义在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="external">5.1.2节 HTTP说明——请求URI</a></p>
<p><strong>请求路径</strong></p>
<p>使用<code>path</code>返回URI的路径部分。</p>
<p>例如，如果请求URI是这样：<code>a/b/c/page.html？param1=abc&amp;param2=xyz</code></p>
<p>然后这个路径将是<code>/a/b/c/page.html</code>。</p>
<p><strong>请求查询</strong></p>
<p>使用<code>query</code>方法返回URI的查询部分。</p>
<p>例如，如果请求URI是这样：<code>a/b/c/page.html？param1=abc&amp;param2=xyz</code></p>
<p>然后这个查询将是<code>param1=abc&amp;param2=xyz</code></p>
<p><strong>请求头</strong></p>
<p>使用<code>headers</code>方法返回HTTP请求的头。</p>
<p>这返回了一个<code>MultiMap</code>的实例，<code>MultiMap</code>就像是一个普通的Map或Hash，但是它允许多个值对应一个相同的键值，这是因为HTTP允许一个键值对应多个头值。</p>
<p>它有大小写不敏感的键值，意味着你可以像下面这样做：</p>
<pre><code>MultiMap headers = request.headers();

// Get the User-Agent:
System.out.println(&quot;User agent is &quot; + headers.get(&quot;user-agent&quot;));

// You can also do this and get the same result:
System.out.println(&quot;User agent is &quot; + headers.get(&quot;User-Agent&quot;));
</code></pre><p><strong>请求主机</strong></p>
<p>使用<code>host</code>方法返回HTTP请求的主机。</p>
<p>HTTP/1.1请求是返回主机头，HTTP/1请求是返回<code>:authority</code>伪头。</p>
<p><strong>请求参数</strong></p>
<p>使用<code>params</code>方法返回HTTP请求的参数。</p>
<p>就像<code>headers</code>方法返回一个<code>MultiMap</code>一样，这可能有多个参数对应一个相同的名字。</p>
<p>请求参数是在请求URI上发送的，在路径后面。例如，如果一个URI是这样的：</p>
<pre><code>/page.html?param1=abc&amp;param2=xyz
</code></pre><p>然后这个参数将包含下面这些：</p>
<pre><code>param1：‘abc’
param2: &apos;xyz&apos;
</code></pre><p>注意，这些请求的参数可以从请求URL里获取。如果你有一个表格属性，并且提交属于HTML表格的一部分到请求体中发送，这将是一个<code>multi-part/form-data</code>请求，他们将不会出现在这个参数这里。</p>
<p><strong>远程地址</strong></p>
<p>请求里的发送者地址可以用<code>remoteAddress</code>方法获取。</p>
<p><strong>绝对URI</strong></p>
<p>传入到一个HTTP请求里的URI通常都是相对的。如果你想要从请求中获取一个绝对的URI，你可以用<code>absoluteURI</code>方法得到。</p>
<p><strong>结束handler</strong></p>
<p>当请求完成的时候，请求的<code>endHandler</code>方法被调用，包括任何请求体都已经被完全读取。</p>
<p><strong>从请求体中读取数据</strong></p>
<p>通常的一个HTTP请求包含了我们要读取的请求体。就像前面提到的请求handler在请求头到达的时候就被调用了，所以这个请求对象在那时候并没有一个请求体。</p>
<p>这是因为请求体可能会很大（例如：一个上传的文件），并且我们通常并不想在调用处理之前缓存整个请求体到内存中，如果那样做，将会导致耗尽服务器的可用内存。</p>
<p>为了获取请求体，你可以在请求上调用<code>handler</code>，这将会在每次请求体的块到达时被调用。下面这是例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.handler(<span class="built_in">buffer</span> -&gt; &#123;</div><div class="line">	System.out.<span class="built_in">println</span>(<span class="string">"I have received a chunk of the body of length "</span> + <span class="built_in">buffer</span>.length);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>传入到handler里的是一个<code>Buffer</code>对象，并且这个handler可以被多次调用当数据从网络中到达时，依赖于请求体的大小。</p>
<p>在一些情景中（例如，请求体很小）你想要将整个请求体缓存到内存中，所以你自己可以像接下来这样获取到全部的请求体：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Buffer </span>totalBuffer = <span class="keyword">Buffer.buffer();</span></div><div class="line"></div><div class="line">request.handler(<span class="keyword">buffer </span>-&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"I have received a chunk of the body of length "</span> + <span class="keyword">buffer.length());</span></div><div class="line">	totalBuffer.appendBuffer(<span class="keyword">buffer);</span></div><div class="line">&#125;)<span class="comment">;</span></div><div class="line"></div><div class="line">request.endHandler(v -&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"Full body received, length = "</span> + totalBuffer.length())<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>这是一个很普遍的例子，所以Vert.x给你提供了一个<code>bodyHandler</code>来这样做。当全部的请求体接收到后，这个<code>bodyHandler</code>将会被调用一次：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.<span class="keyword">bodyHandler(totalBuffer </span>-&gt; &#123;</div><div class="line">	System.out.println(<span class="string">"Full body received, length = "</span> + totalBuffer.length())</div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>导出请求</strong></p>
<p>请求对象是从一个<code>ReadStream</code>，所以你可以导出请求体到任何一个<code>WriteStream</code>实例。</p>
<p>查看章节<a href="">流和导出</a>获取更详细的解释。</p>
<p><strong>处理HTML表格</strong></p>
<p>HTML表格要么用<code>application/x-www-form-urlencoded</code>或者<code>multipart/form-data</code>内容类型来提交。</p>
<p>URL encode forms类型，表格属性在URL中被重新编码，就像普通的查询参数一样。</p>
<p>multi-partform类型，表格属性在请求体中被重新编码，因此，这些表格属性是不可用的直到请求体从电报中被完全的读取到。</p>
<p>Multi-part forms也可以包含文件上传。</p>
<p>如果你想要获取multi-part form的属性，你应该通过调用<code>setExcepMultipart</code>并设置为true来告诉Vert.x，在请求体被读取之前你期望获取到这样一个表格，然后一旦完整的请求体被读取完时，你应该使用<code>formAttributes</code>方法获取真实的属性。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">request</span>.requestHandler(request -&gt;</span> &#123;</div><div class="line">	request.setExcepMultipart(<span class="literal">true</span>);</div><div class="line">	<span class="function"><span class="title">request</span>.endHandler(v -&gt;</span> &#123;</div><div class="line">		<span class="comment">// The body has now been fully read, so retrieve the form attributes</span></div><div class="line">		MultiMap formAttributes = request.formAttributes();</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>处理文件上传</strong></p>
<p>Vert.x可以处理文件上传，在重新编码为一个multi-part的请求体里。</p>
<p>为了获取文件上传，你可以告诉Vert.x期望获取一个multi-part表格并且在请求上设置一个<code>uploadHandler</code>方法。</p>
<p>这个handler将会被调用一次，当所有的上传都到达服务器之后。</p>
<p>传入到这个handler里的对象是一个<code>HttpServerFileUpload</code>实例：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">server</span>.requestHandler(request -&gt;</span> &#123;</div><div class="line">	request.setExpectMultipart(<span class="literal">true</span>);</div><div class="line">	<span class="function"><span class="title">request</span>.uploadHandler(upload -&gt;</span> &#123;</div><div class="line">		System.out.println(<span class="string">"Got a file upload "</span> + upload.<span class="keyword">name</span>());</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>文件上传可能会很大，我们并不提供一个单一的buffer获取到完整的上传，因为那样做会导致耗尽内存，相反的，上传的数据是按块被接收的：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">request</span>.uploadHandler(upload -&gt;</span> &#123;</div><div class="line">	<span class="function"><span class="title">upload</span>.handler(chunk -&gt;</span> &#123;</div><div class="line">		System.out.println(<span class="string">"Received a chunk of the upload of length "</span> + chunk.length());</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上传对象是一个<code>ReadStream</code>，所以你可以导出请求体到任何<code>WriteStream</code>实例。查看章节<a href="">流和导出</a>获取更详细的内容。</p>
<p>如果你仅想要上传一个文件到磁盘的某个地方，你可以使用<code>streamToFileSystem</code>方法：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.uploadHandler(upload -&gt; &#123;</div><div class="line">	upload.streamToFileSystem(<span class="string">"myupload_directory/"</span> + upload.filename())<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>警告：确定你将在生成环境的系统上检查文件名，避免恶意的客户端上传文件到你文件系统的任意位置。查看<a href="">security notes</a>获取更多信息。</p>
</blockquote>
<p><strong>接收自定义HTTP/2帧</strong></p>
<p>HTTP/2是一个带有多个HTTP请求/回复模型的帧协议。这个协议允许大多数帧被发送和接收。</p>
<p>为了接收自定义帧，你可以是在请求上用<code>customFrameHandler</code>方法，这将会被调用在每次一个自定义帧到达时。下面这是例子：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">request</span>.customFrameHandler(frame -&gt; &#123;</div><div class="line"></div><div class="line">  <span class="type">System</span>.out.println(<span class="string">"Received a frame type="</span> + frame.<span class="keyword">type</span>() +</div><div class="line">      <span class="string">" payload"</span> + frame.payload().toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>HTTP/2帧并不受流控制——帧handler将会被马上调用当自定义帧到达的时候，无论请求是否停止。</p>
<p><strong>非标准HTTP方法</strong></p>
<p>这个<code>OTHER</code>的HTTP方法作为一个非标准方法使用，在这个例子中，<code>rawMethod</code>返回了客户端发送的HTTP方法。</p>
<h4 id="返回responses"><a href="#返回responses" class="headerlink" title="返回responses"></a>返回responses</h4><p>服务器返回的对象是<code>HttpServerResponse</code>的一个实例，是从具有响应的请求中获取的。</p>
<p>你可以使用响应对象把一个响应歇会给HTTP客户端。</p>
<p><strong>设置状态码和消息</strong></p>
<p>默认地HTTP状态码是返回200，代表OK。</p>
<p>使用<code>setStatusCode</code>设置一个不同的状态码。</p>
<p>你也可以用<code>setStatusMessage</code>指定一个自定义的状态信息。</p>
<p>如果你不指定状态信息，默认地与状态码相对于的信息会被返回。</p>
<blockquote>
<p>对于HTTP / 2，状态将不存在于响应中，因为协议将不向客户端发送消息</p>
</blockquote>
<p><strong>编写HTTP回复</strong></p>
<p>为了编写数据写回到HTTP回复中，你可以使用操作<code>write</code>。</p>
<p>在回复结束前可以被调用多次。这有几种调用的方式：</p>
<p>用单一的一个buffer：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(buffer);</div></pre></td></tr></table></figure>
<p>用一个字符串，在这个例子中，字符串将会用UTF-8重新编码，并将结果写到报文中。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(<span class="string">"hello world!"</span>);</div></pre></td></tr></table></figure>
<p>用一个带编码的字符串。在这个例子中，字符串将会使用特定的编码格式编码，并将结果写入到报文中。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(<span class="string">"hello world!"</span>, <span class="string">"UTF-16"</span>);</div></pre></td></tr></table></figure>
<p>编写一个响应是异步的，并总是立马返回在将写操作加入到队列中后。</p>
<p>如果你仅写一个单一的字符串或buffer到HTTP响应中，你可以在写完后在一个单一的调用中调用<code>end()</code>结束这个响应。</p>
<p>第一次调用write会将响应头中的结果写入响应。因此，如果你不使用HTTP分块，在写入响应前你必须设置<code>Content-Length</code>头，要不然就太晚了。如果你使用HTTP分块，你就不用担心了。</p>
<p><strong>结束HTTP响应</strong></p>
<p>一旦你完成了HTTP响应，你应该用<code>end</code>方法结束它。</p>
<p>这可以有好几种方式完成：</p>
<p>没有参数，这个响应只是简单的结束。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.write(<span class="string">"hello world!"</span>);</div><div class="line"><span class="built_in">response</span>.<span class="keyword">end</span>();</div></pre></td></tr></table></figure>
<p>这也可以用字符串或buffer调用，就和<code>write</code>方法一样。在这个情形下，这和用字符串或buffer调用写入函数并紧接着调用一个无参的结束方法是一样的。例如：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.<span class="keyword">end</span>(<span class="string">"hello world!"</span>);</div></pre></td></tr></table></figure>
<p><strong>关闭底层连接</strong></p>
<p>你可以使用<code>close</code>方法关闭这个底层的TCP连接。</p>
<p>没有keep-alive的连接将会被Vert.x自动关闭，当响应已经结束时。</p>
<p>Keep-alive连接默认的不会被Vert.x自动关闭。如果你想要关闭一个keep-alive连接在一段空闲时间之后，你可以配置<code>setIdleTimeout</code>。</p>
<p>HTTP/2连接在关闭响应之前会发送一个<code>GOAWAY</code>帧。</p>
<p><strong>设置响应头</strong></p>
<p>HTTP响应头可以用<code>headers</code>直接添加到响应中：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse response = request.response()<span class="comment">;</span></div><div class="line"><span class="keyword">MultiMap </span>headers = response.headers()<span class="comment">;</span></div><div class="line">headers<span class="meta">.set</span>(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)<span class="comment">;</span></div><div class="line">headers<span class="meta">.set</span>(<span class="string">"other-header"</span>, <span class="string">"wibble"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>或者你可以是用<code>putHeader</code></p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>).putHeader(<span class="string">"other-header"</span>, <span class="string">"wibble"</span>);</div></pre></td></tr></table></figure>
<p>响应头必须全部添加在任何部分的响应体被写入之前。</p>
<p><strong>分块的HTTP响应和trailers</strong></p>
<p>Vert.x支持HTTP分块传输编码。</p>
<p>这允许HTTP响应主体以块形式写入，并且通常在大的响应主体被流式传输到客户端并且总大小不是预先知道时使用。</p>
<p>设置HTTP响应为分块模式，像下面这样：</p>
<pre><code>HttpServerResponse response = request.response();
response.setChunked(true);
</code></pre><p>默认是不分块的。当在分块模式下，每次调用一个<code>write</code>方法将会产生一个新的HTTP分块被写入。</p>
<p>当在一个分块模式下，你也可以写一个HTTP响应trailers到响应中。这些实际上写入到了响应的最后一个分块。</p>
<blockquote>
<p>注意：分块的响应对HTTP/2流是没有效果的。</p>
</blockquote>
<p>为了在响应中添加一个trailers，把他们直接加入到<code>trailers</code>。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.setChunked(<span class="literal">true</span>);</div><div class="line">MultiMap trailers = <span class="built_in">response</span>.trailers();</div><div class="line">trailers.<span class="keyword">set</span>(<span class="string">"X-wibble"</span>, <span class="string">"woobble"</span>).<span class="keyword">set</span>(<span class="string">"X-quux"</span>, <span class="string">"flooble"</span>);</div></pre></td></tr></table></figure>
<p>或者使用<code>putTrailer</code></p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line"><span class="built_in">response</span>.setChunked(<span class="literal">true</span>);</div><div class="line"><span class="built_in">response</span>.putTrailer(<span class="string">"X-wibble"</span>, <span class="string">"woobble"</span>).putTrailer(<span class="string">"X-quux"</span>, <span class="string">"flooble"</span>);</div></pre></td></tr></table></figure>
<p><strong>直接从磁盘或类路径提供文件</strong></p>
<p>如果你想要写一个web服务器，一种方式是从磁盘提供文件，将会用<code>AsyncFile</code>打开它并且导入到HTTP响应。</p>
<p>否则你可以使用<code>readFile</code>加载它并直接将它写入到响应中。</p>
<p>或者，Vert.x提供了一个方法在一个操作中允许直接从磁盘或文件系统提供一个文件给一个HTTP响应。在底层操作系统支持的情况下，这可能导致OS直接将字节从文件传输到socket，而根本不通过用户空间被复制。</p>
<p>这个通过使用<code>sendFile</code>完成，并且对大文件来说都很有效，但是可能会导致小文件变慢。</p>
<p>这是一个很简单的web服务器，它使用sendFile从文件系统中提供文件：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(<span class="built_in">request</span> -&gt; &#123;</div><div class="line">  <span class="built_in">String</span> file = <span class="string">""</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">request</span>.path().equals(<span class="string">"/"</span>)) &#123;</div><div class="line">    file = <span class="string">"index.html"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">request</span>.path().contains(<span class="string">".."</span>)) &#123;</div><div class="line">    file = <span class="built_in">request</span>.path();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">request</span>.<span class="built_in">response</span>().sendFile(<span class="string">"web/"</span> + file);</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p>发送一个文件是异步的并且可能没有完成直到一段时间后这个调用已经返回了。如果你想要收到通知，当文件被写入的时候，你可以使用<code>sendFile</code>。</p>
<p>请看这个章节关于<a href="">从类路径提供文件</a>获取关于类路径的限制。</p>
<blockquote>
<p>注意：当你在HTTPS下使用<code>sendFile</code>，它将会复制到用户控件，因为如果直接从内核直接从磁盘拷贝数据到socket里，它不会给我们使用任何加密的机会。<br>警告：如果你想要用Vert.x直接编写web服务器。如果要使用Vert.x直接编写Web服务器，请注意用户不能利用路径访问要从中提供服务的目录或类路径之外的文件。使用Vert.x Web可能更安全。</p>
</blockquote>
<p>当需要只服务一个文件的一段，从一个给定的字节开始，你可以做到这一点：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(request -&gt; &#123;</div><div class="line">  <span class="keyword">long</span> offset = <span class="number">0</span>;</div><div class="line">  <span class="built_in">try</span> &#123;</div><div class="line">    offset = Long.parseLong(request.getParam(<span class="string">"start"</span>));</div><div class="line">  &#125; <span class="built_in">catch</span> (NumberFormatException e) &#123;</div><div class="line">    <span class="comment">// error handling...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> <span class="built_in">end</span> = Long.MAX_VALUE;</div><div class="line">  <span class="built_in">try</span> &#123;</div><div class="line">    <span class="built_in">end</span> = Long.parseLong(request.getParam(<span class="string">"end"</span>));</div><div class="line">  &#125; <span class="built_in">catch</span> (NumberFormatException e) &#123;</div><div class="line">    <span class="comment">// error handling...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  request.response().sendFile(<span class="string">"web/mybigfile.txt"</span>, offset, <span class="built_in">end</span>);</div><div class="line">&#125;).<span class="built_in">listen</span>(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p>如果要从偏移量开始发送文件直到结束，您不需要提供长度，在这种情况下，您可以执行以下操作：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(request -&gt; &#123;</div><div class="line">  <span class="keyword">long</span> offset = <span class="number">0</span>;</div><div class="line">  <span class="built_in">try</span> &#123;</div><div class="line">    offset = Long.parseLong(request.getParam(<span class="string">"start"</span>));</div><div class="line">  &#125; <span class="built_in">catch</span> (NumberFormatException e) &#123;</div><div class="line">    <span class="comment">// error handling...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  request.response().sendFile(<span class="string">"web/mybigfile.txt"</span>, offset);</div><div class="line">&#125;).<span class="built_in">listen</span>(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p><strong>导出响应</strong></p>
<p>服务器响应是<code>WriteStream</code>一个实例，所以你可以从任一的<code>ReadStream</code>导出它。例如：<code>AsyncFile</code>、<code>NetSocket</code>、<code>WebSocket</code>或<code>HttpServerRequest</code>。</p>
<p>这是一个例子，对任一的PUT方法都在响应中回显请求体。它对请求体进行导出，因此，它将会在任何情况下都会工作，即使HTTP请求体比能够适应的内存大的多的时候：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">vertx.createHttpServer().requestHandler(<span class="built_in">request</span> -&gt; &#123;</div><div class="line">  HttpServerResponse <span class="built_in">response</span> = <span class="built_in">request</span>.<span class="built_in">response</span>();</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">request</span>.method() == HttpMethod.PUT) &#123;</div><div class="line">    <span class="built_in">response</span>.setChunked(<span class="literal">true</span>);</div><div class="line">    Pump.pump(<span class="built_in">request</span>, <span class="built_in">response</span>).start();</div><div class="line">    <span class="built_in">request</span>.endHandler(v -&gt; <span class="built_in">response</span>.<span class="keyword">end</span>());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">response</span>.setStatusCode(<span class="number">400</span>).<span class="keyword">end</span>();</div><div class="line">  &#125;</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p><strong>编写HTTP/2帧</strong></p>
<p>HTTP/2是具有用于HTTP请求/响应模型大量的帧的帧协议。这个协议允许其他大量的帧被发送和接收。</p>
<p>为了发送这些真，你可以在响应里使用<code>writeCustomFrame</code>方法。这是一个例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> frameType = <span class="number">40</span>；</div><div class="line"><span class="keyword">int</span> frameStatus = <span class="number">10</span>;</div><div class="line"></div><div class="line">Buffer payload = Buffer.<span class="built_in">buffer</span>(<span class="string">"some data"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Sending a frame to the client</span></div><div class="line">response.writeCustomFrame(frameType, frameStatus, payload);</div></pre></td></tr></table></figure>
<p>这些帧会马上被发送并且不受流表控制。当这些帧被发送了，它可能将会在其他<code>DATA</code>帧之前完成。</p>
<p><strong>流重置</strong></p>
<p>HTTP/1.x并不允许一个干净的请求流或响应流重置。例如，当一个客户端上传一个服务器已经存在的资源时，这个服务器需要接受这个完整的响应。</p>
<p>HTTP/2支持在请求/响应的任何时间流重置：</p>
<pre><code>request.response().reset();
</code></pre><p>默认地一个<code>NO_ERROR</code>(0)的错误码会被发送，要用另一个错误码代替发送可以这样：</p>
<pre><code>request.response().reset(8);
</code></pre><p>HTTP/2指定定义了一系列的<a href="">错误码</a>可用。</p>
<p>流重置事件使用<code>request handler</code>和<code>response handler</code>，这个请求处理器会被通知：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">request</span>.<span class="built_in">response</span>().exceptionHandler(<span class="built_in">err</span> -&gt; &#123;</div><div class="line">	<span class="keyword">if</span> (<span class="built_in">err</span> instanceof StreamResetException) &#123;</div><div class="line">		StreamResetException reset = (StreamResetException) <span class="built_in">err</span>;</div><div class="line">		System.out.println(<span class="string">"Stream reset "</span> + reset.getCode());</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>服务器推送</strong></p>
<p>服务器推送是HTTP/2的一个新特性，可以为一个单一的客户端请求，平行的发送多个响应。</p>
<p>当服务器处理一个请求时，它可以推送一个请求/响应到客户端：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">HttpServerResponse response = request.response();</div><div class="line"></div><div class="line"><span class="comment">// Push main.js to the client</span></div><div class="line">response.push(HttpMethod.GET, <span class="string">"/main.js"</span>, ar -&gt; &#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// The server is ready to push the response</span></div><div class="line">    HttpServerResponse pushedResponse = ar.result();</div><div class="line"></div><div class="line">    <span class="comment">// Send main.js response</span></div><div class="line">    pushedResponse.</div><div class="line">        putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>).</div><div class="line">        end(<span class="string">"alert(\"</span>Push response hello\<span class="string">")"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Could not push client resource "</span> + ar.cause());</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Send the requested resource</span></div><div class="line">response.sendFile(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;script src=\"</span>/main.js\<span class="string">"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"</span>);</div></pre></td></tr></table></figure>
<p>当这个服务器准备好推送响应是，推送响应的handler被调用并且这个handler可以发送响应。</p>
<p>这个推送响应的handler可能接受一个失败，例如客户端可能取消推送因为它在缓存中已经有<code>main.js</code>并且不再需要了。</p>
<p>这个<code>push</code>方法必须被调用在初始化响应结束之前，然而推送的响应可以在之后被重写。</p>
<h4 id="HTTP压缩"><a href="#HTTP压缩" class="headerlink" title="HTTP压缩"></a>HTTP压缩</h4><p>Vert.x提供了开箱即用的HTTP压缩支持。</p>
<p>这意味着在响应时可以自动压缩响应体，在响应体被发送到客户端之前。</p>
<p>如果客户端不支持HTTP压缩，响应体将会以不压缩的方式发回到客户端。</p>
<p>这支持同时处理客户端支持HTTP压缩和不支持HTTP压缩的情况。</p>
<p>为启用压缩，你可以用<code>setCompressionSupported</code>方法配置。</p>
<p>默认地，压缩是不支持的。</p>
<p>当HTTP压缩启用了，服务器将会检查客户端是否包含了<code>Accept-Encoding</code>头，这个头信息包含了是否支持压缩。普遍的压缩方式是deflate和gzip。这两种压缩方式Vert.x都支持。</p>
<p>如果这样一个头信息在服务器端找到了，那么响应体将会用一种支持的压缩方式自动压缩后发回到客户端。</p>
<p>需要注意的是，压缩可能会减少网络拥塞但是更多的CPU密集型。</p>
<h4 id="创建HTTP客户端"><a href="#创建HTTP客户端" class="headerlink" title="创建HTTP客户端"></a>创建HTTP客户端</h4><p>你可以像下面这样用默认的选项创建一个<code>HttpClient</code>实例：</p>
<pre><code>HttpClient client = vertx.createHttpClient();
</code></pre><p>如果你需要给客户端配置选项，创建客户端按下面这样：</p>
<pre><code>HttpCientOptions options = new HttpClientOptions().setKeepAlive(false);
HttpClient client = vertx.createHttpClient(options);
</code></pre><p>Vert.x支持HTTP/2 over TLS <code>h2</code>和HTTP/2 over TCP <code>h2c</code>。</p>
<p>默认地，http客户端发送的是HTTP/1.1请求，要发送HTTP/2请求，方法<code>setProtocolVersion</code>需要被设置为<code>HTTP_2</code>。</p>
<p>对于<code>h2</code>请求，必须启用带有ALPN的TLS。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HttpClientOptions options = new HttpClientOptions().</div><div class="line">    <span class="built_in">set</span>ProtocolVersion(HttpVersion.HTTP_2).</div><div class="line">    <span class="built_in">set</span>Ssl(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>UseAlpn(<span class="literal">true</span>).</div><div class="line">    <span class="built_in">set</span>TrustAll(<span class="literal">true</span>);</div><div class="line"></div><div class="line">HttpClient client = vertx.createHttpClient(options);</div></pre></td></tr></table></figure>
<p>对于<code>h2c</code>请求，TLS必须禁用，客户端会先发一个HTTP/1.1请求并尝试升级到HTTP/2：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpClientOptions options</span> = new HttpClientOptions().setProtocolVersion(HttpVersion.HTTP_2);</div><div class="line"></div><div class="line"><span class="attribute">HttpClient client</span> = vertx.createHttpClient(options);</div></pre></td></tr></table></figure>
<p><code>h2c</code>连接也可以直接建立，例如，连接启动需要有一个预先的知识，当<code>setHttp2ClearTextUpgrade</code>选项设置为false时：在连接建立后，客户端需要发送一个HTTP/2连接开场白并且期望从服务器接收到一个相同的开场白。</p>
<p>http服务器可能不支持HTTP/2，实际的版本可以用<code>version</code>检查，当响应到达的时候。</p>
<p>当一个客户端连接到一个HTTP/2服务器，它会给服务器发送它的初始化设置。这个设置定义了服务器怎么使用这个连接，客户端默认的初始化设置是一个定义在HTTP/2 RFC文档的默认值。</p>
<h4 id="记录客户端网络活动"><a href="#记录客户端网络活动" class="headerlink" title="记录客户端网络活动"></a>记录客户端网络活动</h4><p>为了调试的目的，网络活动可以被日志记录。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpClientOptions options</span> = new HttpClientOptions().setLogActivity(true);</div><div class="line"><span class="attribute">HttpClient client</span> = vertx.createHttpClient(options);</div></pre></td></tr></table></figure>
<p>查看章节记录网络活动获取更多的信息。</p>
<h4 id="发出请求"><a href="#发出请求" class="headerlink" title="发出请求"></a>发出请求</h4><p>http客户端是很灵活的，并且有各种方式使用它发出请求。</p>
<p>通常你想通过一个客户端给同一个主机/端口发出多个请求。为了避免每次你都重复主机/端口发出请求，你可以给客户端配置一个默认的主机/端口。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HttpClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> HttpClientOptions().setDefaultHost(<span class="string">"wibble.com"</span>);</div><div class="line"><span class="comment">// Can also set default port if you want...</span></div><div class="line">HttpClient client = vertx.createHttpClient(<span class="keyword">options</span>);</div><div class="line">client.getNow(<span class="string">"/some-uri"</span>, response -&gt; &#123;</div><div class="line">  System.out.<span class="keyword">println</span>(<span class="string">"Received response with status code "</span> + response.statusCode());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>或者，如果你发现你用相同的客户端会发出大量的请求到不同的主机/端口。你可以简单的指定主机/端口当发出请求的时候。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HttpClientOptions <span class="keyword">options</span> = <span class="keyword">new</span> HttpClientOptions().setDefaultHost(<span class="string">"wibble.com"</span>);</div><div class="line"><span class="comment">// Can also set default port if you want...</span></div><div class="line">HttpClient client = vertx.createHttpClient(<span class="keyword">options</span>);</div><div class="line">client.getNow(<span class="string">"/some-uri"</span>, response -&gt; &#123;</div><div class="line">  System.out.<span class="keyword">println</span>(<span class="string">"Received response with status code "</span> + response.statusCode());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>指定主机/端口的两种方法都支持所有不同的方式向客户端发出请求。</p>
<p><strong>没有请求体的简单请求</strong></p>
<p>有时候，你想要发出一个没有请求体的请求。通常这个例子是用HTTP GET、OPTIONS和HEAD请求。</p>
<p>用Vert.x http客户端做这个最简单的方式是给<code>Now</code>加上方法前缀。例如<code>getNow</code>。</p>
<p>这些方法将会创建这个http请求并在一个单一调用的方法中发送它，还允许你提供一个handler，用一个http响应来调用当它返回的时候。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">HttpClient</span> client = vertx.createHttpClient();</div><div class="line"></div><div class="line"><span class="comment">// Send a GET request</span></div><div class="line">client.getNow(<span class="string">"/some-uri"</span>, response -&gt; &#123;</div><div class="line">  System.out.<span class="built_in">println</span>(<span class="string">"Received response with status code "</span> + response.statusCode());</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Send a GET request</span></div><div class="line">client.headNow(<span class="string">"/other-uri"</span>, response -&gt; &#123;</div><div class="line">  System.out.<span class="built_in">println</span>(<span class="string">"Received response with status code "</span> + response.statusCode());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>编写一个通用的请求</strong></p>
<p>在其他时候，直到运行时前，你不知道你想要发送的请求方法。在这种使用情形下，我们提供一个通用目的的请求方法，就像<code>request</code>可以允许你在运行时指定HTTP方法：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HttpClient client = vertx.createHttpClient();</div><div class="line"></div><div class="line">client.<span class="built_in">request</span>(HttpMethod.<span class="keyword">GET</span>, <span class="string">"some-uri"</span>, <span class="built_in">response</span> -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"Received response with status code "</span> + <span class="built_in">response</span>.statusCode());</div><div class="line">&#125;).<span class="keyword">end</span>();</div><div class="line"></div><div class="line">client.<span class="built_in">request</span>(HttpMethod.POST, <span class="string">"foo-uri"</span>, <span class="built_in">response</span> -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"Received response with status code "</span> + <span class="built_in">response</span>.statusCode());</div><div class="line">&#125;).<span class="keyword">end</span>(<span class="string">"some-data"</span>);</div></pre></td></tr></table></figure>
<p><strong>编写请求体</strong></p>
<p>某些时候你想要编写带有请求体的请求，或者可能在发送之前你想要编写一个带有头的请求。</p>
<p>为了做这个你可以调用一个特定的请求方法，就像<code>post</code>或者一个通用的请求方法就像<code>request</code>。</p>
<p>这些方法并不会立刻发送请求，并且相反的会返回一个<code>HttpClientRequest</code>实例，这个实例可以用来写一个请求体或写一个头。</p>
<p>这是一些编写一个带有请求体的POST请求的例子：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">HttpClient client = vertx.createHttpClient();</div><div class="line"></div><div class="line">HttpClientRequest request = client.post(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Received response with status code "</span> + response.statusCode());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// Now <span class="keyword">do</span> stuff <span class="keyword">with</span> the request</div><div class="line">request.putHeader(<span class="string">"content-length"</span>, <span class="string">"1000"</span>);</div><div class="line">request.putHeader(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>);</div><div class="line">request.write(<span class="keyword">body</span>);</div><div class="line"></div><div class="line">// Make sure the request <span class="keyword">is</span> ended <span class="keyword">when</span> you<span class="symbol">'re</span> done <span class="keyword">with</span> it</div><div class="line">request.<span class="keyword">end</span>();</div><div class="line"></div><div class="line">// <span class="keyword">Or</span> fluently:</div><div class="line"></div><div class="line">client.post(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Received response with status code "</span> + response.statusCode());</div><div class="line">&#125;).putHeader(<span class="string">"content-length"</span>, <span class="string">"1000"</span>).putHeader(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>).write(<span class="keyword">body</span>).<span class="keyword">end</span>();</div><div class="line"></div><div class="line">// <span class="keyword">Or</span> event more simply:</div><div class="line"></div><div class="line">client.post(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line">  System.<span class="keyword">out</span>.println(<span class="string">"Received response with status code "</span> + response.statusCode());</div><div class="line">&#125;).putHeader(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>).<span class="keyword">end</span>(<span class="keyword">body</span>);</div></pre></td></tr></table></figure>
<p>存在以UTF-8编码和任何特定编码写入字符串和写入缓冲区的方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">request.<span class="built_in">write</span>(<span class="string">"some data"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Write string encoded in specific encoding</span></div><div class="line">request.<span class="built_in">write</span>(<span class="string">"some other data"</span>, <span class="string">"UTF-16"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Write a buffer</span></div><div class="line">Buffer <span class="built_in">buffer</span> = Buffer.<span class="built_in">buffer</span>();</div><div class="line"><span class="built_in">buffer</span>.appendInt(<span class="number">123</span>).appendLong(<span class="number">245</span>l);</div><div class="line">request.<span class="built_in">write</span>(<span class="built_in">buffer</span>);</div></pre></td></tr></table></figure>
<p>如果你仅要编写一个单一的字符串或buffer到一个HTTP请求中，你可以在调用的<code>end</code>方法里编写它并结束请求。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request.<span class="keyword">end</span>(<span class="string">"some simple data"</span>);</div><div class="line"></div><div class="line">// Write <span class="keyword">buffer</span> <span class="keyword">and</span> <span class="keyword">end</span> the request (send it) <span class="keyword">in</span> a single call</div><div class="line"><span class="keyword">Buffer</span> <span class="keyword">buffer</span> = <span class="keyword">Buffer</span>.<span class="keyword">buffer</span>().appendDouble(<span class="number">12.34</span>d).appendLong(<span class="number">432</span>l);</div><div class="line">request.<span class="keyword">end</span>(<span class="keyword">buffer</span>);</div></pre></td></tr></table></figure>
<p>当你写一个请求，第一次调用write将导致请求头被写出到报文中。</p>
<p>事实的写是一个异步的并且可能不会发生，知道一段时间后调用返回了。</p>
<p>不分块的HTTP请求带有一个请求体需要提供一个<code>Content-Length</code>头。</p>
<p>因此，如果你不使用分块的HTTP，然后你需要在请求之前设置一个<code>Content-Length</code>头，要不然就太晚了。</p>
<p>如果你调用的一个歹意字符串或者buffer的<code>end</code>方法，然后Vert.x将会自动计算并设置<code>Content-Length</code>头在写请求体之前。</p>
<p>如果你使用一个分块的HTTP，一个<code>Content-Length</code>头并不是必须的，所以你不需要提前计算这个大小。</p>
<p><strong>编写请求头</strong></p>
<p>你可以编写头到一个请求中，可以使用多映射的头就像这样：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MultiMap </span>headers = request.headers()<span class="comment">;</span></div><div class="line">headers<span class="meta">.set</span>(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)<span class="meta">.set</span>(<span class="string">"other-header"</span>, <span class="string">"foo"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>这个头是<code>MultiMap</code>的一个实例，可以提供添加、设置和移除实例的操作。HTTP头允许多个值对应一个指定的键。</p>
<p>你也可以使用<code>putHeader</code>编写头。</p>
<pre><code>request.putHeader(&quot;content-type&quot;, &quot;application/json&quot;).putHeader(&quot;other-header&quot;, &quot;foo&quot;);
</code></pre><p>如果你想要编写一个请求头，你必须在任何请求体部分写入之前完成。</p>
<p><strong>非标准的HTTP方法</strong></p>
<p>这个<code>OTHER</code>http方法是一个非标准的方法，当这个方法被使用时，<code>setRawMethod</code>必须被用来设置原生的方法发送给服务器。</p>
<p><strong>结束HTTP请求</strong></p>
<p>一旦你完成了HTTP请求，你必须调用一个<code>end</code>操作结束它。</p>
<p>结束一个请求会导致任何头被写入，如果你还没准备好写入，这个请求应该被标记为完成。</p>
<p>请求可以用几种方式结束。请求用一个无参的end方法结束是很简单的：</p>
<pre><code>request.end();
</code></pre><p>或者一个字符串或者buffer也可以在调用时提供给<code>end</code>方法。这就像用一个字符串或buffer调用<code>write</code>方法，在调用无参的<code>end</code>方法之前。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request.<span class="keyword">end</span>(<span class="string">"some-data"</span>);</div><div class="line"></div><div class="line">// <span class="keyword">End</span> it <span class="keyword">with</span> a <span class="keyword">buffer</span></div><div class="line"><span class="keyword">Buffer</span> <span class="keyword">buffer</span> = <span class="keyword">Buffer</span>.<span class="keyword">buffer</span>().appendFloat(<span class="number">12.3</span>f).appendInt(<span class="number">321</span>);</div><div class="line">request.<span class="keyword">end</span>(<span class="keyword">buffer</span>);</div></pre></td></tr></table></figure>
<p><strong>分块的HTTP请求</strong></p>
<p>Vert.x支持请求的HTTP分块传输编码。</p>
<p>这允许HTTP请求体分块写入，并且通常来说当一个大的请求体以流的方式发送到服务器上使用，同时预先并不知道请求体的大小。</p>
<p>你可以使用<code>setChunked</code>设置HTTP请求为一个分块的模式。</p>
<p>在分块模式下，每个写调用会引发一个新的块写入到报文中。在此模式下，无需在请求前设置<code>Content-Length</code>。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">request.setChunked(true);</div><div class="line"></div><div class="line"><span class="comment">// Write some chunks</span></div><div class="line"><span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  request.<span class="built_in">write</span>(<span class="string">"this-is-chunk-"</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">request.<span class="built_in">end</span>();</div></pre></td></tr></table></figure>
<p><strong>请求超时</strong></p>
<p>你可以使用<code>setTimeout</code>为一个特定的http请求设置超时。</p>
<p>如果请求没有返回任何数据在一个超时时间间隔内，一个异常将会传入到一个异常handler（如果提供了的话）并且这个请求将会关闭。</p>
<p><strong>处理异常</strong></p>
<p>你可以处理一个请求相关的异常通过在<code>HttpClientRequest</code>实例上设置一个异常handler:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HttpClientRequest request = client.post(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"Received response with status code "</span> + response.statusCode())<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div><div class="line">request.exceptionHandler(e -&gt; &#123;</div><div class="line">  System.out.println(<span class="string">"Received exception: "</span> + e.getMessage())<span class="comment">;</span></div><div class="line">  e.printStackTrace()<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>异常handler并不会处理任何2XX响应，需要被处理的在<code>HttpCilentResponse</code>代码里：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">HttpClientRequest request = client.post(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (response.statusCode() == <span class="number">200</span>) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Everything fine"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (response.statusCode() == <span class="number">500</span>) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Unexpected behavior on the server side"</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">request.end();</div></pre></td></tr></table></figure>
<blockquote>
<p>XXXNow</p>
</blockquote>
<p><strong>在客户端请求上指定一个handler</strong></p>
<p>创建一个客户端请求对象来代替在调用时提供一个响应handler，或者，当请求被创建的时候，你不能提供一个handler，可以之后在请求对象本身上设置使用handler，例如：</p>
<pre><code>HttpClientRequest request = client.post(&quot;some-uri&quot;);
request.handler(response -&gt; {
    System.out.println(&quot;Received response with status code &quot; + response.statusCode());
});
</code></pre><p><strong>将请求作为流使用</strong></p>
<p><code>HttpClientRequest</code>实例也是一个<code>WriteStream</code>对象，这意味着你可以从任一的<code>ReadStream</code>实例中导出它。</p>
<p>例如，你可以用http请求体导出一个磁盘上的文件，像接下来这样：</p>
<pre><code>request.setChunked(true);
Pump pump = Pump.pump(file, request);
file.endHandler(v -&gt; request.end());
pump.start();
</code></pre><p><strong>编写HTTP/2帧</strong></p>
<p>HTTP/2是具有用于HTTP请求/响应模型大量的帧的帧协议。这个协议允许其他大量的帧被发送和接收。</p>
<p>为了发送这样的帧，你可以使用请求上的<code>write</code>方法。这是例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> frameType = <span class="number">40</span>;</div><div class="line"><span class="keyword">int</span> frameStatus = <span class="number">10</span>;</div><div class="line">Buffer payload = Buffer.<span class="built_in">buffer</span>(<span class="string">"some data"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Sending a frame to the server</span></div><div class="line">request.writeCustomFrame(frameType, frameStatus, payload);</div></pre></td></tr></table></figure>
<p><strong>重置流</strong></p>
<p>HTTP/1.x不允许一个干净的重置一个请求或响应流，例如，当一个客户端上传服务器上已经存在的资源，这个服务器需要接受完整的响应。</p>
<p>HTTP/2支持在请求/响应的任何时候重置流。</p>
<pre><code>request.reset();
</code></pre><p>默认地，发送<code>NO_ERROR(0)</code>错误码，可以用另一个代码代替并发送：</p>
<pre><code>request.reset(8);
</code></pre><p>HTTP/2具体说明定义在<a href="http://httpwg.org/specs/rfc7540.html#ErrorCodes" target="_blank" rel="external">错误码</a>列表中，选择一个错误码并使用。</p>
<p>用<code>request handler</code>和<code>response handler</code>重置流可以在请求handler里被通知：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">request.exceptionHandler(<span class="keyword">err</span> -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">err</span> instanceof StreamResetException) &#123;</div><div class="line">    StreamResetException reset = (StreamResetException) <span class="keyword">err</span>;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Stream reset "</span> + reset.getCode());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>处理http响应</strong></p>
<p>您会在请求方法中指定的处理程序中接收HttpClientResponse的实例，或者直接在HttpClientRequest对象上设置处理程序。</p>
<p>你可以用<code>statusCode</code>和<code>statusMessage</code>查询状态码和状态信息。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">client.getNow(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line">  <span class="regexp">//</span> the status code - e.g. <span class="number">200</span> <span class="keyword">or</span> <span class="number">404</span></div><div class="line">  System.out.println(<span class="string">"Status code is "</span> + response.statusCode());</div><div class="line"></div><div class="line">  <span class="regexp">//</span> the status message e.g. <span class="string">"OK"</span> <span class="keyword">or</span> <span class="string">"Not Found"</span>.</div><div class="line">  System.out.println(<span class="string">"Status message is "</span> + response.statusMessage());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>将流作为响应使用</strong></p>
<p><code>HttpClientResponse</code>实例也是一个<code>ReadStream</code>，这意味着你可以导出它到任何一个<code>WriteStream</code>实例中国。</p>
<p><strong>响应头和trailers(预告？)</strong></p>
<p>Http响应可以包含头。使用<code>headers</code>获取到http头。</p>
<p>返回的是一个<code>MultiMap</code>对象，因为http头一个键可以包含多个值。</p>
<pre><code>String contentType = response.headers().get(&quot;content-type&quot;);
String contentLength = response.headers().get(&quot;content-length&quot;);
</code></pre><p>块式的HTTP响应可以包含预告（trailers）-预告将会在响应体的最后一个块发送。</p>
<p>你可以使用<code>trailers</code>获取预告。预告也是一个<code>MultiMap</code>对象。</p>
<p><strong>读取请求体</strong></p>
<p>当响应头从报文中读取完毕时，响应处理handler被调用。</p>
<p>如果请求有一个请求体，这可能在头部读取后的这段时间里到达请求体的几个部分。在调用响应handler之前我们不会等到所有的主体都到达，因为响应可能会很大并且我们可能需要等待很长一段时间，或者大响应导致内存溢出。</p>
<p>当部分响应主体到达，这个handler将会用代表部分主体的<code>buffer</code>调用：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">client.getNow(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line"></div><div class="line">  response.handler(<span class="keyword">buffer </span>-&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"Received a part of the response body: "</span> + <span class="keyword">buffer);</span></div><div class="line">  &#125;)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>如果你知道响应主体并不是很大，并希望在处理它之前将它聚合在内存中，你可以自己聚合：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">client.getNow(<span class="string">"some-uri"</span>, response -&gt; &#123;</div><div class="line"></div><div class="line">  <span class="comment">// Create an empty buffer</span></div><div class="line">  Buffer totalBuffer = Buffer.<span class="built_in">buffer</span>();</div><div class="line"></div><div class="line">  response.handler(<span class="built_in">buffer</span> -&gt; &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Received a part of the response body: "</span> + <span class="built_in">buffer</span>.length());</div><div class="line"></div><div class="line">    totalBuffer.appendBuffer(<span class="built_in">buffer</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  response.endHandler(v -&gt; &#123;</div><div class="line">    <span class="comment">// Now all the body has been read</span></div><div class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Total response body length is "</span> + totalBuffer.length());</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>或者你可以使用更方便的<code>bodyHandler</code>，当响应被完全读取的时候，调用它获取到全部的主体：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">client</span>.getNow("some-uri", response -&gt;</span> &#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">response</span>.bodyHandler(totalBuffer -&gt;</span> &#123;</div><div class="line">    <span class="comment">// Now all the body has been read</span></div><div class="line">    System.out.println(<span class="string">"Total response body length is "</span> + totalBuffer.length());</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>响应结束处理程序</strong></p>
<p>响应<code>endHandler</code>会当响应主体完全被读取被调用，或在头被读取并且如果没有任何主体且响应处理程序被调用后立刻调用。</p>
<p><strong>从响应中读取cookies</strong></p>
<p>你可以使用<code>cookies</code>从响应中获取到cookies的列表。</p>
<p>或者，你可以在响应中自行解析<code>Set-cookie</code>的头。</p>
<p><strong>100-继续处理</strong></p>
<p>根据<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank" rel="external">HTTP1.1说明</a>，客户端可以设置<code>Expect: 100-Continue</code>头，并且在剩余请求体发送之前发送请求主体。</p>
<p>服务器可以用一个内置的响应状态<code>Status: 100 (Continue)</code>响应来表示已经准备好了，客户端可以发送剩余的主体了。</p>
<h4 id="处理http-response"><a href="#处理http-response" class="headerlink" title="处理http response"></a>处理http response</h4><h4 id="允许客户端压缩"><a href="#允许客户端压缩" class="headerlink" title="允许客户端压缩"></a>允许客户端压缩</h4><h4 id="HTTP-1-x池和keep-alive"><a href="#HTTP-1-x池和keep-alive" class="headerlink" title="HTTP/1.x池和keep alive"></a>HTTP/1.x池和keep alive</h4><h4 id="HTTP-1-1-pipe-lining"><a href="#HTTP-1-1-pipe-lining" class="headerlink" title="HTTP/1.1 pipe-lining"></a>HTTP/1.1 pipe-lining</h4><h4 id="HTTP-2-multiplexing"><a href="#HTTP-2-multiplexing" class="headerlink" title="HTTP/2 multiplexing"></a>HTTP/2 multiplexing</h4><h4 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h4><h4 id="HTTPClient用法"><a href="#HTTPClient用法" class="headerlink" title="HTTPClient用法"></a>HTTPClient用法</h4><h4 id="服务器分享"><a href="#服务器分享" class="headerlink" title="服务器分享"></a>服务器分享</h4><h4 id="通过Vert-x使用HTTPS"><a href="#通过Vert-x使用HTTPS" class="headerlink" title="通过Vert.x使用HTTPS"></a>通过Vert.x使用HTTPS</h4><h4 id="websockets"><a href="#websockets" class="headerlink" title="websockets"></a>websockets</h4><h4 id="为HTTP-HTTPS连接使用代理"><a href="#为HTTP-HTTPS连接使用代理" class="headerlink" title="为HTTP/HTTPS连接使用代理"></a>为HTTP/HTTPS连接使用代理</h4><h4 id="在verticles里自动清除-1"><a href="#在verticles里自动清除-1" class="headerlink" title="在verticles里自动清除"></a>在verticles里自动清除</h4><hr>
<h3 id="在Vert-x里使用Shared-Data"><a href="#在Vert-x里使用Shared-Data" class="headerlink" title="在Vert.x里使用Shared Data"></a>在Vert.x里使用Shared Data</h3><hr>
<h4 id="Local-shared-maps"><a href="#Local-shared-maps" class="headerlink" title="Local shared maps"></a>Local shared maps</h4><h4 id="Cluster-wide-asynchronous-maps"><a href="#Cluster-wide-asynchronous-maps" class="headerlink" title="Cluster-wide asynchronous maps"></a>Cluster-wide asynchronous maps</h4><h4 id="Cluster-wide-locks"><a href="#Cluster-wide-locks" class="headerlink" title="Cluster-wide locks"></a>Cluster-wide locks</h4><h4 id="Cluster-wide-counters"><a href="#Cluster-wide-counters" class="headerlink" title="Cluster-wide counters"></a>Cluster-wide counters</h4><hr>
<h3 id="通过Vert-x使用文件系统"><a href="#通过Vert-x使用文件系统" class="headerlink" title="通过Vert.x使用文件系统"></a>通过Vert.x使用文件系统</h3><hr>
<h4 id="异步文件"><a href="#异步文件" class="headerlink" title="异步文件"></a>异步文件</h4><hr>
<h3 id="数据报socket（UDP）"><a href="#数据报socket（UDP）" class="headerlink" title="数据报socket（UDP）"></a>数据报socket（UDP）</h3><hr>
<h4 id="创建一个DatagramSocket"><a href="#创建一个DatagramSocket" class="headerlink" title="创建一个DatagramSocket"></a>创建一个DatagramSocket</h4><h4 id="发送一个Datagram-packets"><a href="#发送一个Datagram-packets" class="headerlink" title="发送一个Datagram packets"></a>发送一个Datagram packets</h4><h4 id="接收一个Datagram-packets"><a href="#接收一个Datagram-packets" class="headerlink" title="接收一个Datagram packets"></a>接收一个Datagram packets</h4><h4 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h4><hr>
<h3 id="DNS客户端"><a href="#DNS客户端" class="headerlink" title="DNS客户端"></a>DNS客户端</h3><hr>
<h4 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h4><h4 id="lookup4"><a href="#lookup4" class="headerlink" title="lookup4"></a>lookup4</h4><h4 id="lookup6"><a href="#lookup6" class="headerlink" title="lookup6"></a>lookup6</h4><h4 id="resolveA"><a href="#resolveA" class="headerlink" title="resolveA"></a>resolveA</h4><h4 id="resolveAAAA"><a href="#resolveAAAA" class="headerlink" title="resolveAAAA"></a>resolveAAAA</h4><h4 id="resolveCNAME"><a href="#resolveCNAME" class="headerlink" title="resolveCNAME"></a>resolveCNAME</h4><h4 id="resolveMX"><a href="#resolveMX" class="headerlink" title="resolveMX"></a>resolveMX</h4><h4 id="resolveTXT"><a href="#resolveTXT" class="headerlink" title="resolveTXT"></a>resolveTXT</h4><h4 id="resolveNS"><a href="#resolveNS" class="headerlink" title="resolveNS"></a>resolveNS</h4><h4 id="resolveSRV"><a href="#resolveSRV" class="headerlink" title="resolveSRV"></a>resolveSRV</h4><h4 id="resolvePTR"><a href="#resolvePTR" class="headerlink" title="resolvePTR"></a>resolvePTR</h4><h4 id="reverseLookup"><a href="#reverseLookup" class="headerlink" title="reverseLookup"></a>reverseLookup</h4><h4 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h4><hr>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><hr>
<h4 id="ReadStream"><a href="#ReadStream" class="headerlink" title="ReadStream"></a>ReadStream</h4><h4 id="WriteStream"><a href="#WriteStream" class="headerlink" title="WriteStream"></a>WriteStream</h4><h4 id="Pump"><a href="#Pump" class="headerlink" title="Pump"></a>Pump</h4><hr>
<h3 id="记录解析"><a href="#记录解析" class="headerlink" title="记录解析"></a>记录解析</h3><hr>
<hr>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><hr>
<hr>
<h3 id="Metrics-SPI"><a href="#Metrics-SPI" class="headerlink" title="Metrics SPI"></a>Metrics SPI</h3><hr>
<hr>
<h3 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a>OSGi</h3><hr>
<hr>
<h3 id="vertx命令行"><a href="#vertx命令行" class="headerlink" title="vertx命令行"></a>vertx命令行</h3><hr>
<h4 id="运行verticles"><a href="#运行verticles" class="headerlink" title="运行verticles"></a>运行verticles</h4><h4 id="将一个Vert-x应用打包为一个jar包执行"><a href="#将一个Vert-x应用打包为一个jar包执行" class="headerlink" title="将一个Vert.x应用打包为一个jar包执行"></a>将一个Vert.x应用打包为一个jar包执行</h4><h4 id="显示Vert-x版本"><a href="#显示Vert-x版本" class="headerlink" title="显示Vert.x版本"></a>显示Vert.x版本</h4><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><h4 id="Live-Redeploy"><a href="#Live-Redeploy" class="headerlink" title="Live Redeploy"></a>Live Redeploy</h4><hr>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><hr>
<hr>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><hr>
<h4 id="配置JUL日志"><a href="#配置JUL日志" class="headerlink" title="配置JUL日志"></a>配置JUL日志</h4><h4 id="使用另一个日志框架"><a href="#使用另一个日志框架" class="headerlink" title="使用另一个日志框架"></a>使用另一个日志框架</h4><h4 id="记录你的应用"><a href="#记录你的应用" class="headerlink" title="记录你的应用"></a>记录你的应用</h4><hr>
<h3 id="主机名解决方案"><a href="#主机名解决方案" class="headerlink" title="主机名解决方案"></a>主机名解决方案</h3><hr>
<hr>
<h3 id="高可用和fail-over"><a href="#高可用和fail-over" class="headerlink" title="高可用和fail-over"></a>高可用和fail-over</h3><hr>
<h4 id="自动failover"><a href="#自动failover" class="headerlink" title="自动failover"></a>自动failover</h4><h4 id="HA组"><a href="#HA组" class="headerlink" title="HA组"></a>HA组</h4><h4 id="处理网络部分-Quora"><a href="#处理网络部分-Quora" class="headerlink" title="处理网络部分-Quora"></a>处理网络部分-Quora</h4><hr>
<h3 id="安全记录"><a href="#安全记录" class="headerlink" title="安全记录"></a>安全记录</h3><hr>
<h4 id="web应用"><a href="#web应用" class="headerlink" title="web应用"></a>web应用</h4><h4 id="集群event-bus交通"><a href="#集群event-bus交通" class="headerlink" title="集群event bus交通"></a>集群event bus交通</h4><h4 id="标准安全的最佳实践"><a href="#标准安全的最佳实践" class="headerlink" title="标准安全的最佳实践"></a>标准安全的最佳实践</h4><hr>
<h3 id="Vert-x命令行接口API"><a href="#Vert-x命令行接口API" class="headerlink" title="Vert.x命令行接口API"></a>Vert.x命令行接口API</h3><hr>
<h4 id="定义舞台"><a href="#定义舞台" class="headerlink" title="定义舞台"></a>定义舞台</h4><h4 id="解析舞台"><a href="#解析舞台" class="headerlink" title="解析舞台"></a>解析舞台</h4><h4 id="查询-审计舞台"><a href="#查询-审计舞台" class="headerlink" title="查询/审计舞台"></a>查询/审计舞台</h4><h4 id="类型选项和参数"><a href="#类型选项和参数" class="headerlink" title="类型选项和参数"></a>类型选项和参数</h4><h4 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h4><hr>
<h3 id="Vert-x启动器"><a href="#Vert-x启动器" class="headerlink" title="Vert.x启动器"></a>Vert.x启动器</h3><hr>
<h4 id="拓展vert-x启动器"><a href="#拓展vert-x启动器" class="headerlink" title="拓展vert.x启动器"></a>拓展vert.x启动器</h4><h4 id="在jar里使用启动器"><a href="#在jar里使用启动器" class="headerlink" title="在jar里使用启动器"></a>在jar里使用启动器</h4><h4 id="启动子类"><a href="#启动子类" class="headerlink" title="启动子类"></a>启动子类</h4><h4 id="启动器退出代码"><a href="#启动器退出代码" class="headerlink" title="启动器退出代码"></a>启动器退出代码</h4><hr>
<h3 id="配置Vert-x缓存"><a href="#配置Vert-x缓存" class="headerlink" title="配置Vert.x缓存"></a>配置Vert.x缓存</h3><hr>
]]></content>
    </entry>
    
  
  
</search>
